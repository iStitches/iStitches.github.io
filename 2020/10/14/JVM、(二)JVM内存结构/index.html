<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JVM、(二)JVM的内存结构 | iStitches</title><meta name="keywords" content="JVM"><meta name="author" content="XjX-zc"><meta name="copyright" content="XjX-zc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、程序计数器(PC)定义：  Program counter Register作用：记住下一条JVM指令的执行地址。(通过寄存器来实现的)">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM、(二)JVM的内存结构">
<meta property="og:url" content="http://example.com/2020/10/14/JVM%E3%80%81(%E4%BA%8C)JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="iStitches">
<meta property="og:description" content="一、程序计数器(PC)定义：  Program counter Register作用：记住下一条JVM指令的执行地址。(通过寄存器来实现的)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/jvm.jpg">
<meta property="article:published_time" content="2020-10-14T12:13:00.000Z">
<meta property="article:modified_time" content="2022-04-02T02:37:01.666Z">
<meta property="article:author" content="XjX-zc">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/jvm.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/10/14/JVM%E3%80%81(%E4%BA%8C)JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM、(二)JVM的内存结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-02 10:37:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/mybkcss.css"><link rel="stylesheet" href="/css/myfootercss.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_3294417_y9wnoregopg.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/myfont.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="iStitches" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/jvm.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">iStitches</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM、(二)JVM的内存结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-14T12:13:00.000Z" title="发表于 2020-10-14 20:13:00">2020-10-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T02:37:01.666Z" title="更新于 2022-04-02 10:37:01">2022-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/">JAVA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM、(二)JVM的内存结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、程序计数器-PC"><a href="#一、程序计数器-PC" class="headerlink" title="一、程序计数器(PC)"></a>一、程序计数器(PC)</h1><h3 id="定义：-Program-counter-Register"><a href="#定义：-Program-counter-Register" class="headerlink" title="定义：  Program counter Register"></a>定义：  Program counter Register</h3><h3 id="作用：记住下一条JVM指令的执行地址。-通过寄存器来实现的"><a href="#作用：记住下一条JVM指令的执行地址。-通过寄存器来实现的" class="headerlink" title="作用：记住下一条JVM指令的执行地址。(通过寄存器来实现的)"></a>作用：记住下一条JVM指令的执行地址。(通过寄存器来实现的)</h3><p> <img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301110052481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<span id="more"></span>

<p>二进制字节码通过解释器被解释为机器码，然后机器码才能够交给CPU去执行。<br>当第1条JVM指令被解释翻译执行后 程序计数器会去记录下一条JVM指令的执行地址然后接着执行。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><pre><code>* **线程私有的**。程序运行时会开启多个线程，CPU会对这些线程进行调度，每个线程有着自己的时间片。当时间到但是线程1还未执行完，线程1的程序计数器便会记录此时执行到的指令的位置；然后切换到线程2去执行，同理线程2也有自己的程序计数器。
</code></pre>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/2021030111052214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    * <strong>不会存在内存溢出</strong>。</p>
<h1 id="二、虚拟机栈-Virtual-Stack"><a href="#二、虚拟机栈-Virtual-Stack" class="headerlink" title="二、虚拟机栈(Virtual Stack)"></a>二、虚拟机栈(Virtual Stack)</h1><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><ol>
<li>栈 - 线程运行需要的内存空间；由多个栈帧(Frame)组成。</li>
<li>栈帧 - 每个方法调用时需要的内存；</li>
<li>栈与栈帧的关系 - 每个线程只能有一个活动栈帧，对应着正在执行的那个方法(位于栈顶部的那个栈帧)；</li>
<li>一个栈中可能存在多个栈帧。<br>比如说某个方法执行时会需要一些参数、局部变脸、返回地址。这些都被记录在栈帧这个内存空间中。也可能在执行该方法时还调用了其余的方法，此时该栈中就会存储多个栈帧，当方法执行完后栈帧便会出栈，内存自动释放掉。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301111739866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="面试问题："><a href="#面试问题：" class="headerlink" title="面试问题："></a>面试问题：</h3></li>
<li>垃圾回收是否涉及栈内存？<br>不涉及，因为栈内存是随着线程中方法执行的结束而弹出栈自动释放掉的。</li>
<li>栈内存分配越大越好吗？<br>不是，因为物理内存的大小是一定的。如果栈内存划分大，那么能够执行的线程数就会减少，它只能够方便进行更多次的方法递归调用，不会增大方法运行的效率。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301112623779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>方法内的局部变量是否是线程安全的？<br>如果方法内局部变量没有逃离方法的作用范围就是线程安全的；反之不安全，比如局部变量作为方法返回值返回，有可能被其它线程使用。<br>举例：<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301113800529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>方法1中的 StringBuilder是线程私有的，因为它是作为局部变量出现的；<br>方法2中的不是线程安全的，因为作为引用类型出现它可能还会被其它线程所引用，比如说在main 方法中开启了新线程调用 m2(StringBuilder sb)方法。<br>方法3中的 StringBuilder不是线程安全的，因为它将 StringBuilder作为返回值返回，那么其它线程就有可能拿到这个值去修改 。</li>
</ol>
<h3 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h3><ul>
<li>栈帧过多(递归爆炸)；</li>
<li>栈帧过大(不太容易出现)；</li>
<li>实例：<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/2021030111524247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301115410241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301115506978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h3></li>
</ul>
<ol>
<li>CPU占用过多：</li>
</ol>
<ul>
<li>使用 <code>top</code>  定位哪个进程对CPU的占用过高；</li>
<li><code>ps H -eo pid,tid,%cpu | grep 进程id</code> (使用ps命令进一步定位是哪个线程引起的cpu占用过高)</li>
<li><code>jstack 进程id</code>  获取指定进程的线程运行情况；可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301132132807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是 jstack 打印出的线程编号是 16进制的，需要首先将 十进制的存在问题的线程编号换算为16进制然后去 jstack 打印结果中寻找。</li>
</ul>
<ol start="2">
<li>程序运行很长时间没有结果</li>
</ol>
<ul>
<li>比如说死锁问题<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301132915467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h1 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h1><ul>
<li>概念：Java代码调用本地方法时所占用的内存。给本地方法的运行提供内存空间。<br>本地方法举例：<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301133729544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h1 id="四、堆"><a href="#四、堆" class="headerlink" title="四、堆"></a>四、堆</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>概念： 通过 new 关键字创建的对象都会使用到堆内存；</li>
<li>特点： <ul>
<li>堆是线程共享的，堆中的对象都需要考虑线程安全问题；</li>
<li>有垃圾回收机制。</li>
</ul>
</li>
</ul>
<h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><ul>
<li>举例：<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301134606201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>报错：<code> java.lang.OutOfMemoryError:java heap space</code><br>可以通过  <code>-Xmx堆内存大小</code>  来设置程序中堆的内存<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301134724553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h3></li>
</ul>
<ol>
<li>jps 工具： 查看当前系统中有哪些 java进程；</li>
<li>jmap 工具：查看堆内存占用情况；</li>
<li>jconsole 工具：图形界面的，多功能的监测工具，可以连续监测；<br>注意使用时需要保证 项目jdk版本和 idea版本一致。<br>详细参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/sugar_cookie/article/details/100575726">jhsdb jmap –heap –pid 进程号** **报错</a><br>   <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32360995/article/details/91849864">IntelliJ IDEA设置JDK版本</a></li>
</ol>
<p>应用实例1：<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/2021030113573367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301135801726.png" alt="在这里插入图片描述"><br><code>jps</code>   : 查看系统中的java进程。 如果报错需要切换到 jdk安装目录的bin目录下进行。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301135835330.png" alt="在这里插入图片描述"><br><code>jmap -heap  进程id</code>：查看对应进程的堆内存占用情况</p>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/2021030114002979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>堆分配前：<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301140045624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>堆分配后：<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301140148894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>gc回收后：<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301140210273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>应用案例2：<br> <img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301141102502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用 <code>jvisualvm</code> 来监控进程的堆内存分配：<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/2021030114121995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301141333702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301141412959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301141443431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="五、方法区"><a href="#五、方法区" class="headerlink" title="五、方法区"></a>五、方法区</h1><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><ol>
<li><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p>
</li>
<li><p>方法区与堆一样都是各个线程共享的内存区域；</p>
</li>
<li><p>方法区在JVM启动的时候被创建，并且它的实际物理内存空间中和Java堆区一样都可以是不连续的；</p>
</li>
<li><p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutOfMemoryError:PermGen space </code> 或者 <code>java.lang.OutOfMemoryError:Metaspace</code><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301163220965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301163230888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>   <img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/2021030116220754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ol>
<ul>
<li>jvm1.6 用了一个永久代(PermGen)作为方法区的实现，永久代中包含了运行时常量池(<code>StringTable</code>)、类加载器(<code>ClassLoader</code>)、类的相关信息(<code>Class</code>)；</li>
<li>jvm1.8 后用元空间代替了永久代作为方法区的实现。元空间和方法区类似，都是对JVM中方法区的实现，不过元空间与永久代的最大区别在于：元空间不在虚拟机设置的内存中、而是使用本地内存。不过1.8将 StringTable移动到了堆中。这是因为永久代的回收效率很低(需要 FULLGC时才能触发垃圾回收 )这样会占用大量的内存，而StringTable在堆中只需要 Minor GC时便能够触发垃圾回收，能够大大减轻字符串对内存的占用。</li>
<li>运行时常量池 VS 常量池：<br>方法区中包含了运行时常量池；字节码文件中包含了常量池；一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用。</li>
<li>为什么需要常量池？<br>一个Java 源文件中的类、接口 编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存储在字节码中，换另一种方式，可以存到常量池中，这个字节码包含了指向常量池的引用。在动态连接的时候回到运行时常量池。</li>
<li>常量池中有什么？<br>数量值、字符串值、类引用、字段引用、方法引用。</li>
<li>运行时常量池：<ul>
<li>运行时常量池是在jvm虚拟机完成类装载操作之后，将class文件中的常量池载入到内存中，并保存在方法区中。</li>
<li>运行时常量池中包含多种不同的常量，包括编译器期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</li>
<li>运行时常量池相对于Class文件中的常量池的另一重要特征是：具备动态性。</li>
</ul>
</li>
</ul>
<h3 id="方法区的内存溢出"><a href="#方法区的内存溢出" class="headerlink" title="方法区的内存溢出"></a>方法区的内存溢出</h3><p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301171455803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过循环20000次来往方法区中加载多个类的信息，使得方法区内存溢出。</p>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301171440744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是只有在 JVM1.6之前才有可能产生方法区内存溢出，因为它使用的是虚拟机的内存，而JVM1.8以后使用的是本地内存很大不会溢出。但是在修改了虚拟机参数后可以做到内存溢出。 <code>-XX:MaxMetaspaceSize=8m</code><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301171819834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ul>
<li>常量池就是一张表，字节码文件中的虚拟机指令根据这张表找到需要执行的类名、方法名、参数类型、字面量等信息。</li>
<li>字节码文件中包含了 类的基本信息(版本号、字段)，常量池，类方法定义，虚拟机指令。 查看字节码信息： <code>javap -v xxx.class</code></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301173643345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/2021030117360181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301173628887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301173708375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301173722937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301173756330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul>
<li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入到运行时常量池，并把里面的符号地址变为真实地址。<h4 id="StringTable-面试题："><a href="#StringTable-面试题：" class="headerlink" title="StringTable 面试题："></a>StringTable 面试题：</h4><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301205918569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h4 id="StringTable-实例："><a href="#StringTable-实例：" class="headerlink" title="StringTable 实例："></a>StringTable 实例：</h4><ol>
<li><p>基础的  <code>String str = &quot;xxx&quot;</code><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/202103011750588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>常量池中的信息，都会被加载到运行时常量池中。开始时 a、b、ab 都是作为常量池中的符号，还没有变为 java字符串对象。等到程序运行到这里时，字节码中的虚拟机指令(<code>ldc</code>)会将该符号变为字符串对象，并且放入到串池(<code>StringTable</code>，是一个 hashtable结构，不能扩容)中。每次都会先到串池中检查是否有对应的字符串，如果不存在再创建然后加入。</p>
</li>
<li><p>字符串拼接 <code>String s4 = s1 + s2</code><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301202156296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301202249922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301202317710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因此得到结果为 false</p>
</li>
<li><p>字符串拼接 <code>String s4 = &quot;a&quot; + &quot;b&quot;</code><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301202654467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>底层做法：javac在编译期间的优化，结果已经在编译期间确定为 “ab”；而 <code>String s4 = s1 + s2</code> 中s1与 s2均为变量可能在之后发生变化，因此不能提前确定，必须在运行期间使用 <code>StringBuilder</code> 获取。</p>
</li>
<li><p>使用 <code>intern</code> 方法主动将字符串放入串池<br>JDK 1.8下：<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301204143372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301205445998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301204643456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>JDK 1.6下：<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210301205310831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><code>s.intern()</code> ：</p>
<ul>
<li>会尝试将字符串s  放入到串池中，如果串池中有则不会放入，如果没有则放入。最终会返回串池中的对象。（1.7、1.8中）；</li>
<li>会将字符串s 拷贝一份并将该拷贝的那份放入串池中，而原本的字符串s 如果存在于堆中，此时仍然在堆中。最终返回串池中的对象(1.6中)</li>
</ul>
<h4 id="StringTable特性："><a href="#StringTable特性：" class="headerlink" title="StringTable特性："></a>StringTable特性：</h4><ol>
<li>常量池中的字符串仅是符号，第一次用到才变为对象；</li>
<li>利用串池的机制，来避免重复创建字符串对象；</li>
<li>字符串变量拼接的原理是 StringBuilder（1.8中）；</li>
<li>字符串常量拼接的原理是编译期优化；</li>
<li>可以使用 <code>intern</code> 方法，主动将串池中还没有的字符串对象放入串池。</li>
</ol>
<h4 id="StringTable位置："><a href="#StringTable位置：" class="headerlink" title="StringTable位置："></a>StringTable位置：</h4><p>1.8以前 StringTable 位于永久代中，需要满足 FULLGC时才能触发垃圾回收，会造成大量内存空间无法被回收；<br>1.8以后 StringTable 位于堆中，需要满足 MinorGC 时才能触发垃圾回收，因此能够大大减少字符串占用的内存空间，及时回收。</p>
<ul>
<li>证明如下：<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302093721121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>jvm1.6 下循环26000次往 StringTable中放入字符串，同时设置永久代的最大内存空间：<code>-XX:MaxPermSize=10m</code>；<br>此时会报错 <code>OutOfMemoryError ：PermGen space</code>，说明1.6中 StringTable确实位于永久代中。</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302093935796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>jvm1.8下会报错 <code>GC overhead limit exceeded</code>，这是由于垃圾回收的一个限制导致的<code>UseGCOverheadLimit</code>(如果98%的时间花费到垃圾回收上，但是只有2%的堆空间被回收，就会触发该错误)。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302094234300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时需要添加相应的虚拟机参数：<code>-Xmx10m -XX:-UseGCOverheadLimit</code><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302094405474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如图所示，此时报错 <code>Java heap space</code> 堆空间不足，证明1.8中 StringTable位于堆中。<br><br></p>
<h4 id="StringTable垃圾回收机制："><a href="#StringTable垃圾回收机制：" class="headerlink" title="StringTable垃圾回收机制："></a>StringTable垃圾回收机制：</h4><p> 虚拟机配置： <code>-Xmx10m -XX:+PrintStringTableStatisttics -XX:+PrintGCDetails -verbose:gc</code><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302095211383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302095257312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302095347265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302095413919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="StringTable性能调优："><a href="#StringTable性能调优：" class="headerlink" title="StringTable性能调优："></a>StringTable性能调优：</h4><ol>
<li>调整StringTable 中桶的个数：</li>
</ol>
<ul>
<li>命令： <code>-XX:StringTableSize=桶个数(最小1009)</code><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302102004343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302102047504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302102127928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302102211523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<ol start="2">
<li>考虑将字符串对象是否入池<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302102759510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302102829319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开 jvisualvm可以发现String、char数组占用了80%的内存；</li>
</ol>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302102942140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302103025985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以发现字符串入池后 占用的内存只有30%左右</p>
<h1 id="六、直接内存"><a href="#六、直接内存" class="headerlink" title="六、直接内存"></a>六、直接内存</h1><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>Direct Memory，直接内存是属于操作系统的内存；</li>
<li>常见于 NIO操作时，用于数据缓冲区；</li>
<li>分配回收成本较高，但是读写性能高；</li>
<li>不受 JVM 内存回收管理；<h3 id="案例对比"><a href="#案例对比" class="headerlink" title="案例对比"></a>案例对比</h3><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/2021030210422312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302110142430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302110149677.png" alt="在这里插入图片描述"></li>
</ul>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302111801870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>首先Java代码本身不具有读写文件的能力，它需要调用操作系统的方法来进行文件读写。CPU 方面会由用户态切换为内核态；内存方面会在系统内存划分一块系统缓存区，将磁盘文件读取到系统缓冲区然后再将系统缓冲区中的文件数据读取到Java 缓冲区(堆内存分配的)。<br>但是这样依赖就需要开辟两份缓冲区，这样会造成不必要的数据复制，效率不高。</p>
<br>

<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302112134280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用 ByteBuffer 后则会开辟一块Java和系统都能够共享的区域 <code>direct memory</code>（直接内存），这样一来就不用重复复制效率便提高了。</p>
<h3 id="内存释放原理"><a href="#内存释放原理" class="headerlink" title="内存释放原理"></a>内存释放原理</h3><p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302113400388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302113458711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>使用     <code>Unsafe</code> 对象完成直接内存的分配(<code>allocateMemory</code>)回收(<code>freeMemory</code>)，并且回收需要主动调用     <code>freeMemory</code> 方法。</li>
<li><code>ByteBuffer</code> 的实现类内部，使用了 <code>Cleaner</code>(虚引用) 来监测<code>ByteBuffer</code> 对象，一旦 <code>ByteBuffer</code> 对象被垃圾回收，那么就会由     <code>ReferenceHandler</code> 线程通过 <code>Cleaner</code> 的clean 方法调用 <code>freeMemory</code> 来释放直接内存。</li>
</ol>
<ul>
<li>源码分析：<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302113729174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302113748955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/2021030211414456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302115534270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/20210302114019946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="禁用显示回收对直接内存的影响"><a href="#禁用显示回收对直接内存的影响" class="headerlink" title="禁用显示回收对直接内存的影响"></a>禁用显示回收对直接内存的影响</h3><p>一般会禁用 <code>System.gc()</code> 来避免显式的进行垃圾回收。但是显式gc被禁用 ByteBuffer就不能被回收，相应的直接内存就得不到释放。因此一般推荐使用 <code>UnSafe</code> 对象直接 <code>freeMemory</code> 进行释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_1GB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射获取UnSafe 实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            unsafe = (Unsafe) f.get(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配直接内存并且回收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line">        <span class="comment">//分配内存</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> unsafe.allocateMemory(_1GB);</span><br><span class="line">        unsafe.setMemory(base,_1GB,(<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放内存</span></span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考文章：<br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000014395186">JVM 完整深入解析</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43279292">JVM系列(二) - JVM内存区域详解</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44556968/article/details/109270921">JVM –方法区（超详细）</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lxcmyf/p/7044998.html">Java常量池详解</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">XjX-zc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2020/10/14/JVM%E3%80%81(%E4%BA%8C)JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">http://example.com/2020/10/14/JVM、(二)JVM内存结构/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">iStitches</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="/img/jvm.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/15/%E7%89%9B%E5%AE%A2%E5%89%91%E6%8C%87offer_t1~t20/"><img class="prev-cover" src="/img/loading.gif" data-original="/img/%E7%89%9B%E5%AE%A2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">牛客剑指offer(1~20题总结)</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/14/JVM%E3%80%81(%E4%B8%80)JVM%E5%BC%80%E7%AF%87/"><img class="next-cover" src="/img/loading.gif" data-original="/img/jvm.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM、(一)JVM开篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/10/15/JVM%E3%80%81(%E4%B8%89)%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="JVM、(三)垃圾回收机制"><img class="cover" src="/img/loading.gif" data-original="/img/jvm.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-15</div><div class="title">JVM、(三)垃圾回收机制</div></div></a></div><div><a href="/2020/10/14/JVM%E3%80%81(%E4%B8%80)JVM%E5%BC%80%E7%AF%87/" title="JVM、(一)JVM开篇"><img class="cover" src="/img/loading.gif" data-original="/img/jvm.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-14</div><div class="title">JVM、(一)JVM开篇</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">XjX-zc</div><div class="author-info__description">生活原本沉闷,但跑起来就会有风</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/iStitches"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="iconfont icon-social-rss card_icon"></i></a><a class="social-icon" href="https://github.com/iStitches" target="_blank" title="Github"><i class="iconfont icon-icon-Github card_icon"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_43684985?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><i class="iconfont icon-icon-csdn card_icon"></i></a><a class="social-icon" href="https://space.bilibili.com/407787894" target="_blank" title="Bilibili"><i class="iconfont icon-icon_bilibili card_icon"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1093453695&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="iconfont icon-icon-QQ card_icon"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">开发菜鸡,欢迎大家光临,一起学习进步！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-PC"><span class="toc-number">1.</span> <span class="toc-text">一、程序计数器(PC)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-Program-counter-Register"><span class="toc-number">1.0.1.</span> <span class="toc-text">定义：  Program counter Register</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A%E8%AE%B0%E4%BD%8F%E4%B8%8B%E4%B8%80%E6%9D%A1JVM%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E5%9C%B0%E5%9D%80%E3%80%82-%E9%80%9A%E8%BF%87%E5%AF%84%E5%AD%98%E5%99%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.0.2.</span> <span class="toc-text">作用：记住下一条JVM指令的执行地址。(通过寄存器来实现的)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.0.3.</span> <span class="toc-text">特点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88-Virtual-Stack"><span class="toc-number">2.</span> <span class="toc-text">二、虚拟机栈(Virtual Stack)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">2.0.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">2.0.2.</span> <span class="toc-text">面试问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">2.0.3.</span> <span class="toc-text">栈内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%AF%8A%E6%96%AD"><span class="toc-number">2.0.4.</span> <span class="toc-text">线程运行诊断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">3.</span> <span class="toc-text">三、本地方法栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A0%86"><span class="toc-number">4.</span> <span class="toc-text">四、堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.0.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">4.0.2.</span> <span class="toc-text">堆内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E8%AF%8A%E6%96%AD"><span class="toc-number">4.0.3.</span> <span class="toc-text">堆内存诊断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">5.</span> <span class="toc-text">五、方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E6%88%90"><span class="toc-number">5.0.1.</span> <span class="toc-text">构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">5.0.2.</span> <span class="toc-text">方法区的内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">5.0.3.</span> <span class="toc-text">常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">5.0.4.</span> <span class="toc-text">运行时常量池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StringTable-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A"><span class="toc-number">5.0.4.1.</span> <span class="toc-text">StringTable 面试题：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringTable-%E5%AE%9E%E4%BE%8B%EF%BC%9A"><span class="toc-number">5.0.4.2.</span> <span class="toc-text">StringTable 实例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringTable%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">5.0.4.3.</span> <span class="toc-text">StringTable特性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringTable%E4%BD%8D%E7%BD%AE%EF%BC%9A"><span class="toc-number">5.0.4.4.</span> <span class="toc-text">StringTable位置：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringTable%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">5.0.4.5.</span> <span class="toc-text">StringTable垃圾回收机制：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringTable%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%9A"><span class="toc-number">5.0.4.6.</span> <span class="toc-text">StringTable性能调优：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">6.</span> <span class="toc-text">六、直接内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">6.0.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">6.0.2.</span> <span class="toc-text">案例对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA"><span class="toc-number">6.0.3.</span> <span class="toc-text">图示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E5%8E%9F%E7%90%86"><span class="toc-number">6.0.4.</span> <span class="toc-text">内存释放原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E6%98%BE%E7%A4%BA%E5%9B%9E%E6%94%B6%E5%AF%B9%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">6.0.5.</span> <span class="toc-text">禁用显示回收对直接内存的影响</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/hello-world/" title="Hello World"><img src="/img/loading.gif" data-original="https://upimage.alexhchu.com/2020/10/21/f5ac68ddaaf64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2022/03/31/hello-world/" title="Hello World">Hello World</a><time datetime="2022-03-31T09:49:07.771Z" title="发表于 2022-03-31 17:49:07">2022-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/26/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B(1)/" title="计算机网络 自顶向下方法(应用层)"><img src="/img/loading.gif" data-original="https://blogimg-1303834209.cos.ap-guangzhou.myqcloud.com/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络 自顶向下方法(应用层)"/></a><div class="content"><a class="title" href="/2021/10/26/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B(1)/" title="计算机网络 自顶向下方法(应用层)">计算机网络 自顶向下方法(应用层)</a><time datetime="2021-10-26T08:47:02.000Z" title="发表于 2021-10-26 16:47:02">2021-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" title="深入理解Java虚拟机—垃圾收集器与内存分配策略"><img src="/img/loading.gif" data-original="/img/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解Java虚拟机—垃圾收集器与内存分配策略"/></a><div class="content"><a class="title" href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" title="深入理解Java虚拟机—垃圾收集器与内存分配策略">深入理解Java虚拟机—垃圾收集器与内存分配策略</a><time datetime="2021-07-11T14:06:00.000Z" title="发表于 2021-07-11 22:06:00">2021-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" title="深入理解Java虚拟机—Java内存区域"><img src="/img/loading.gif" data-original="/img/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解Java虚拟机—Java内存区域"/></a><div class="content"><a class="title" href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" title="深入理解Java虚拟机—Java内存区域">深入理解Java虚拟机—Java内存区域</a><time datetime="2021-07-11T13:06:00.000Z" title="发表于 2021-07-11 21:06:00">2021-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/10/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E6%8B%93%E5%B1%95/" title="TCP三握四挥知识拓展"><img src="/img/loading.gif" data-original="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TCP三握四挥知识拓展"/></a><div class="content"><a class="title" href="/2021/05/10/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E6%8B%93%E5%B1%95/" title="TCP三握四挥知识拓展">TCP三握四挥知识拓展</a><time datetime="2021-05-10T10:12:00.000Z" title="发表于 2021-05-10 18:12:00">2021-05-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By XjX-zc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>