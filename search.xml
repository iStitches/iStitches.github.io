<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络 自顶向下方法(应用层)</title>
      <link href="/2021/10/26/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B(1)/"/>
      <url>/2021/10/26/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B(1)/</url>
      
        <content type="html"><![CDATA[<blockquote><p> WireShark 抓包指南：   <a href="https://zhuanlan.zhihu.com/p/82498482">https://zhuanlan.zhihu.com/p/82498482</a></p></blockquote><h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>协议规定了发送者、接收者和所有中间设备为了高效通信需要遵守的规则。</p><p>协议分层允许我们将一个复杂的任务分解成几个较小的、简单的任务。</p><p><strong>协议分层的好处：</strong></p><ul><li>第一，它允许我们将服务从实现中分离出来。一层需要能够接收较低一层的一系列服务，同时向较高层提供服务，而我们不需要关心这一层是如何实现的。</li><li>第二，在通信过程中中间系统只需要一些层次而不是所有的层次，如果不使用协议分层，形成的中间系统就不得不像端系统一样复杂，这样会提高整个系统的造价。</li></ul><span id="more"></span><h2 id="TCP-x2F-IP-各层描述"><a href="#TCP-x2F-IP-各层描述" class="headerlink" title="TCP&#x2F;IP 各层描述"></a>TCP&#x2F;IP 各层描述</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层通信处于两个进程之间，是端到端的一种通信方式。常见的涉及到的协议包括： 超文本传输协议(HTTP，是访问万维网的载体)；简单邮件传输协议(SMTP，是电子邮件服务的主要协议)；文件传输协议(FTP)；远程登陆(TELNET)；安全外壳(SSH，用于访问远端的站点)；简单的网络管理协议(SNMP)；域名系统(DNS)；因特网组管理协议(IGMP，用于管理一个组的成员资格)；</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层也是端到端的，主要负责从运行于应用层的程序得到信息，并将它投递到目的主机相应的应用程序。常见的协议包括：传输控制协议(TCP) 是面向连接的，提供流量控制(匹配源主机的发送速率与目的主机的接收速率，以防止目的主机溢出)、差错控制(保证数据段无差错到达目的地和重新发送受损的数据段)、拥塞控制(减少由于网络拥塞造成的数据段丢失)；用户数据报协议(UDP)，无连接但是是比较简单的协议，不提供流量控制、差错控制或者拥塞控制；流控制传输协议(SCTP)，结合了TCP与UDP的优点。</p><p>UDP协议：</p><ul><li>UDP提供了无连接的、不可靠的数据包服务。无连接意味着两个交换报文的终端之间没有逻辑连接。每个报文都是独立的实体，它被封装在一个称为数据报的分组中。</li><li>UDP常用在邮件发送、视频通信、多媒体应用等场景。</li></ul><p>TCP协议：</p><ul><li>TCP提供面向连接的可靠字节流传输，TCP要求两个终端首先通过交换一些连接建立分组来建立一个逻辑连接，这个阶段设置了两个终端的某些参数，包括分组大小、用于保存数据直到整个报文全部到达缓冲区的大小等等。</li></ul><p>SCTP协议：</p><ul><li>SCTP协议提供了两个协议组合的功能。类似于TCP，SCTP提供了面向连接的可靠服务，但是它不是面向字节流，它是像UDP一样面向报文的。除此之外，SCTP可以通过多媒体网络层连接提供多媒体流服务。</li><li>SCTP协议通常适用于那些不但需要可靠性，而且即使网络层连接发生错误也需保持连接不断开的应用。</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层也是端到端的，主要负责指挥分组选择合适的路由器并通过。这一层不能取消，因为路由器不需要应用层和传输层，分割任务允许我们在路由器上加载较少的协议。常见的协议包括：因特网协议(IP)，IP负责从源主机把一个分组路由到目的主机，IP是一个无连接的协议，不提供流量控制、差错控制和拥塞控制服务。网络层也包括单播(一对一) 和多播 (一对多)路由协议，虽然这些协议不参与路由，但是它为路由器创建转发路由表，为转发处理提供帮助。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层是基于点到点的传输。它负责选择从主机到目的地之间最好的一条线路进行数据传输。这条链路可以是一个具有链路层交换机的有线局域网、一个无线局域网、一个有线广域网或者一个无线广域网。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>物理层位于最底层，传输帧中单独的比特。</p><h3 id="封装与解封装"><a href="#封装与解封装" class="headerlink" title="封装与解封装"></a>封装与解封装</h3><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010104358387.png" alt="image-20211010104358387"></p><p>源主机的封装：</p><ul><li>应用层的消息不包含任何头部和尾部，消息直接传输到传输层；</li><li>传输层把这个消息作为有效载荷，在次基础上添加上传输层头部，比如负责进行流量控制、差错控制和拥塞控制所需要的信息。该分组在TCP中称为段，在UDP中称为用户数据报，然后传递分组到网络层；</li><li>网络层把分组作为有效载荷，并且在此基础上添加自己的头部，头部包含了源主机和目的主机的地址，以及用于头部检查、分片等其他信息。</li><li>数据链路层把网络分组作为有效载荷，并在此基础上添加上了自己的头部。该头部包含主机或者下一跳步的链路层地址，结果为一个称为帧的链路层分组。</li></ul><p>路由器的解封装与封装：</p><ul><li>路由器会解封装来自源主机的帧，获取齐总的数据报将他投递到网络层。</li><li>网络层检查数据报头部的源地址和目的地址，查阅它的转发表以寻找该数据报将被投递到的下一跳步，除非数据报太大以至于不能通过下一链路时需要对其进行分片，数据报的内容不应该被网络层改变，然后数据报被传递到下一链路的数据链路层；</li><li>下一链路的数据链路层将数据报封装成一个帧，将其传递到物理层进行传输。</li></ul><h2 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h2><blockquote><p> 客户端进程是怎么和服务器进程通信的？</p></blockquote><h3 id="应用程序接口"><a href="#应用程序接口" class="headerlink" title="应用程序接口"></a>应用程序接口</h3><p>计算机语言有一个数学操作指令集、一个字符串处理指令集、一个输入&#x2F;输出访问指令集。如果我们想要一个进程与另一个进程通信，那么我们就需要一个新的指令集告知 TCP&#x2F;IP 协议族的低四层打开连接，发送数据，从另一个终端接收数据以及关闭连接，这样的指令集通常称为<strong>应用程序接口</strong>。</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010111808985.png" alt="image-20211010111808985"></p><p>其中很常见的三个接口：套接字接口、传输层接口、STREAM。最常见的是套接字接口，套接字接口是提供应用层和操作系统间通信的指令集，是一个可以被某进程用来与另一个进程进行通信的指令集。</p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>就应用层而言，客户进程和服务器进程间的通信是两个套接字间的通信，如果我们创建两个套接字，一端创建一个，并正确定义源端和目的端地址，那么我们就可以使用指令去发送和接收数据了，其余就是操作系统以及嵌入的 TCP&#x2F;IP 协议的工作了。</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010112041132.png" alt="image-20211010112041132"></p><p>套接字的地址是由 32位的IP地址 + 16位的端口号组成。</p><h4 id="套接字地址"><a href="#套接字地址" class="headerlink" title="套接字地址"></a>套接字地址</h4><p>服务器站点：</p><ul><li>本地套接字地址，操作系统知道运行着服务器进程的计算机的IP地址。然而服务器进程的端口号需要被分配，如果这个服务器进程是因特网管理结构定义的标准进程，那么端口号就已经分配好了，比如超文本传输控制协议(80端口)；非标准进程会由设计者在规定范围内选择一个端口号。</li><li>远程套接字地址，对服务器来说，远程套接字地址是建立连接的客户套接字地址。会随着连接变动而发生改变；</li></ul><p>客户端站点：</p><ul><li>本地套接字地址，本地套接字地址由操作系统提供，操作系统知道本机IP地址，端口号是每次客户进程开始通信时分配给客户进程的一个临时16位整数。</li><li>远程套接字地址，当一个客户进程开启时，它会知道自己想要连接的服务器地址。</li></ul><h3 id="超文本传输协议（HTTP）"><a href="#超文本传输协议（HTTP）" class="headerlink" title="超文本传输协议（HTTP）"></a>超文本传输协议（HTTP）</h3><blockquote><p> 超文本传输协议是一种用来定义客户服务器程序如何编写和使用从万维网获取网页的协议。在HTTP1.1 版本之前是一种非持续链接，HTTP1.1 版本之后默认使用持续链接，持续连接避免了非持续链接带来的高额开销问题，每个站点只需要为连接设定一组缓冲区和变量，同时节省了连接建立和终止的往返时间。</p></blockquote><p><strong>HTTP 与 TCP&#x2F;IP 的区别？</strong></p><p>TCP&#x2F;IP 协议是传输层协议，主要用来解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据，WEB使用 HTTP协议作为应用层协议，以封装HTTP文本信息，然后使用 TCP&#x2F;IP 做传输层协议将它发到网络上。</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211019155139824.png" alt="image-20211019155139824"></p><p><strong>请求报文和响应报文的组成格式：</strong></p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010170910090.png" alt="image-20211010170910090"></p><p><strong>请求报文：</strong></p><ul><li>请求行：包括请求方法(GET、HEAD、PUT、POST、TRACE、CONNECT、DELETE、OPTIONS)；请求URL；协议版本；</li></ul><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010171232619.png" alt="image-20211010171232619"></p><ul><li>请求头：从客户端向服务器发送的额外信息，比如 <code>User-agent</code>、<code>Accept</code>、<code>Authorization</code>、<code>Cookie</code>；</li></ul><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010171244120.png" alt="image-20211010171244120"></p><ul><li>请求空行；</li><li>请求体：请求的具体内容。</li></ul><p>响应报文：</p><ul><li>状态行：包括协议版本、状态码、短语。100范围内的状态码只代表一个报告、200范围内代码表示这是一个成功的请求、300范围内代码表示把客户端重定向到另一个URL、400范围内代码表示在客户端发生错误、500范围内代码表示错误发生在服务器端。</li><li>响应头：服务器端的一些需要返回给客户端的信息。</li></ul><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010171532514.png" alt="image-20211010171532514"></p><p>HTTP 支持代理服务器，代理服务器是一台计算机，能够保存最近请求的响应的副本。代理服务器降低了原服务器的负载，减少了通信量并降低了延迟。</p><p>代理服务器通常使用在：1) 客户计算机作为小容量代理服务器，存储着与客户经常调用的请求的响应；2)   公司内部的代理服务器安装在计算机LAN中来减少进出LAN的负载； 3) 带有很多客户的ISP可以安装一台代理服务器来减少进出ISP网络的负载。</p><p>HTTP本质上并不安全，但是可以在安全套接层(SSL) 上运行，在这种情况下 HTTP称为 HTTPS，HTTPS提供保密性、客户和服务器鉴别，以及数据完整性。</p><h3 id="安全应用层协议-HTTPS"><a href="#安全应用层协议-HTTPS" class="headerlink" title="安全应用层协议 HTTPS"></a>安全应用层协议 HTTPS</h3><p>HTTPS 在 HTTP 基础上加入了 SSL协议，SSL协议依靠证书来验证服务器的身份，并为服务器和浏览器之间的通信加密。加密过程如下：</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211019155538005.png" alt="image-20211019155538005"></p><ol><li>客户端发起 HTTPS 请求；</li><li>HTTPS协议的服务端拥有一套数字证书，可以是自己制作或者CA证书。区别在于CA证书能够直接使用，而自己制作的证书需要客户端验证通过才可以继续访问。总的来说该证书实际上看作一对公钥和私钥，公钥给别人加密使用，私钥给自己解密使用；</li><li>服务端传送证书给客户端；</li><li>客户端解析证书，比如证书的颁发机构、过期时间等，如果发现异常会进行提示。如果通过检查，就生成一个随机值，并利用证书对该随机值进行加密；</li><li>客户端传送加密后的随机值，目的在于让服务端接收该随机值并在之后的通信过程中利用该随机值进行加密解密；</li><li>服务端利用证书对加密后的随机值进行解密，得到客户端传送过来的随机值(该值作为之后传输过程中的私钥使用)。然后利用随机值对发送内容进行对称加密，正好客户端和服务端都知道这个私钥(客户端传输的随机值)，所以只有两者能够对消息进行解密；</li><li>传输加密后的信息；</li><li>客户端利用生成的私钥对信息进行解密，获得解密后的内容。</li></ol><p>整个过程中即使信息泄露，外部也会因为不知道私钥而无法解密信息，所以是安全的。</p><p><strong>HTTP 和 HTTPS 的区别：</strong></p><ol><li>https 协议需要到 ca 申请证书或者自制证书；</li><li>http 信息是明文传输，https 信息则是具有安全性的 ssl 加密；</li><li>http 直接与 tcp 进行数据传输，而 https 还需要经过一层 SSL，用的端口也不一样，前者是80端口，后者是443端口；</li><li>http 的连接很简单，是无状态的；https 协议是由 SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比 HTTP协议安全；</li></ol><p><strong>HTTPS 协议的数据加密是在传输层进行，无论是 HTTPS 的header域还是 body域都会被加密处理。</strong></p><h3 id="文件传输协议（FTP）"><a href="#文件传输协议（FTP）" class="headerlink" title="文件传输协议（FTP）"></a>文件传输协议（FTP）</h3><p>文件传输协议FTP 是TCP&#x2F;IP  提供的标准机制，用于将文件从一个主机复制到另一个主机。FTP结构上由客户端和服务器端组成，客户端包括用户接口、控制进程、数据传输进程三个组件；服务器端包括控制进程、数据传输进程组成。</p><p>FTP中两种连接有不同的寿命，在整个FTP会话期间，控制连接始终处于连接状态。数据连接则在每次完成传输文件时开启然后关闭。数据连接通过20端口进行操作，控制连接通过21端口。</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010172358300.png" alt="image-20211010172358300"></p><h4 id="控制连接"><a href="#控制连接" class="headerlink" title="控制连接"></a>控制连接</h4><p>对于控制通信，FTP使用与TELNET相同的方法。它与TELNET一样使用NVT ASCII 字符集。在控制连接期间，命令从客户端发送到服务器并且响应从服务器发送到客户端。</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010172920386.png" alt="image-20211010172920386"></p><p>每个FTP命令至少产生一个响应，一个响应由两部分组成：文本 + 一个三位数字，数字部分定义了编码。</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010173026071.png" alt="image-20211010173026071"></p><h4 id="数据连接"><a href="#数据连接" class="headerlink" title="数据连接"></a>数据连接</h4><p>数据连接使用 20端口，数据连接的创建步骤如下：</p><ol><li>客户使用临时端口发起一个被动打开，必须由客户完成，因为是客户发出命令要求传输文件的；</li><li>客户使用 PORT 命令发送这个端口号到服务器；</li><li>服务器接收到端口号，使用熟知端口20发出主动打开并且接收临时端口号。</li></ol><p>数据连接建立后不能立刻通信，还需要定义传输文件的类型、数据结构、传输模式，因此通过建立控制连接来完成：</p><ol><li>规定传输数据的数据结构：FTP可以使用下列数据结构中的一种在数据连接上传送文件：文件结构、记录结构、页面结构。其中文件结构是默认使用，它是连续的字节流；记录结构把文件划分成了一个个记录，只能用于文本文件；页面结构把文件划分成页面，每一个页面有一个页面号和一个页面头部，页面可以随机地或者顺序地存储或访问。</li><li>规定传输数据地文件类型：FTP可以在数据连接上传输下列文件的一种：ASCII文件、EBCDIC文件、图像文件；</li><li>规定传输数据的传输方式：三种方式，流方式、块方式、压缩方式。块方式中在文件前加上了一个3字节的文件头，其中第一个字节称为块描述，后面两个字节定义块大小。</li></ol><p>完成控制连接后就可以开始进行数据传输了。</p><h3 id="简单电子邮件传输协议（SMTP）"><a href="#简单电子邮件传输协议（SMTP）" class="headerlink" title="简单电子邮件传输协议（SMTP）"></a>简单电子邮件传输协议（SMTP）</h3><h4 id="电子邮件传输模式架构"><a href="#电子邮件传输模式架构" class="headerlink" title="电子邮件传输模式架构"></a>电子邮件传输模式架构</h4><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010174056115.png" alt="image-20211010174056115"></p><p>邮件传输通过代理服务器完成，包括三种不同的代理，用户代理(UA)、报文传输代理(MTA)、报文访问代理(MAA)。</p><h4 id="报文传输代理-SMTP"><a href="#报文传输代理-SMTP" class="headerlink" title="报文传输代理 SMTP"></a>报文传输代理 SMTP</h4><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015091054800.png" alt="image-20211015091054800"></p><p>报文首先从客户经过MTA报文传输代理发送到客户端的邮件服务器，然后再从客户端邮件服务器经过MTA报文传输代理发送到服务端邮件服务器，服务端邮件服务器再通过MAA报文访问代理发送给具体的用户。</p><p>MTA客户机和服务器常用的协议称为**简单邮件传输协议(SMTP)**，SMTP只定义了如何来回发送命令和响应，因此在邮件服务器和接收器之间还需要另一个协议。</p><p>SMTP协议涉及到的邮件传输阶段分为三个：连接建立、邮件传输、连接终止。</p><p>SMTP协议是一个推协议，他将报文从客户推入服务器，但是第三阶段需要一个拉协议，客户机必须从服务器拉出报文，大量数据的方向是从服务器到客户，因此第三阶段使用报文访问代理协议。目前的MAA协议主要有邮局协议版本3（POP3）、因特网邮件访问协议版本4（IMAP4）。</p><h4 id="基于Web的邮件"><a href="#基于Web的邮件" class="headerlink" title="基于Web的邮件"></a>基于Web的邮件</h4><p>以上是传统邮件传输服务的架构组织，现在出现了另一种架构模式。报文从发送邮件服务器到接收邮件服务器的传输仍然是通过SMTP来完成的，但是从接收服务器到浏览器是通过HTTP来完成的。</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015092820624.png" alt="image-20211015092820624"></p><h3 id="远程登陆-TELNET、SSH"><a href="#远程登陆-TELNET、SSH" class="headerlink" title="远程登陆 TELNET、SSH"></a>远程登陆 TELNET、SSH</h3><h4 id="TELNET"><a href="#TELNET" class="headerlink" title="TELNET"></a>TELNET</h4><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015101718786.png" alt="image-20211015101718786"></p><p>远程登陆协议之一是<code>TELNET</code>。在输入命令进行远程登陆时，用户将击键发送给终端驱动程序，同时本地操作系统接收这些字符，但并不解释它们。这些字符被发送到TELNET客户机，它将这些字符转换为网络虚拟终端（Network Virtual Terminal，NVT）字符的通用字符集，然后将其传送给本地 TCP&#x2F;IP 协议栈。</p><p>采用网络虚拟终端NVT 形式的命令或文本通过因特网传送到远程的TCP&#x2F;IP 协议栈，在那里传递给操作系统，操作系统再移交给TELNET服务器，TELNET服务器将这些字符转换为远程计算机可以理解的字符。但是这些字符不能直接传递给操作系统，因为操作系统不能处理来自TELNET服务器的字符，它只能接收来自终端驱动程序的字符。所以还需要在远程端增加一个伪终端驱动程序的软件块。</p><h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015102535907.png" alt="image-20211015102535907"></p><p>TELNET虽然能够进行远程登陆和消息传递，但是并不安全。更加安全的协议是SSH（Secure Shell），它是一个可以用于远程登陆和文件传输的多用途安全应用协议，SSH是一个有三个组件的应用层协议。</p><p>三个组件包括：SSH-TRANS（SSH应用层协议）、SSH-AUTH（SSH认证协议）、SSH-CONN（SSH连接协议）。</p><p><strong>SSH-TRANS：</strong>是一个独立协议，当执行这个协议的程序被调用时，客户和服务器首先通过TCP建立一个不安全的连接，然后交换它们的几个参数在TCP顶部建立安全信道。</p><p><strong>SSH-AUTH：</strong>在客户与服务器之间的安全信道建立以及客户端认证服务器之后，SSH可以调用另外一个流程，它为服务器对客户进行认证。</p><p><strong>SSH-CONN：</strong>在安全信道建立和服务器相互认证之后，SSH可以调用一个执行第三个协议的软件，那就是SSH-CONN。SSH-CONN 协议提供的一个服务是复用。SSH-CONN 采用前两层协议创建安全信道并允许客户在其上创建多个逻辑信道，每个逻辑信道可以用于不同目的，比如文件传输、远程登陆等。</p><p><strong>端口转发：</strong>SSH提供一个特殊的服务端口转发，我们可以使用SSH中可用的安全信道来访问一个不提供安全服务的应用程序。比如TELNET和简单邮件传输协议(SMTP) 这类应用。SSH端口转发机制创建了一个隧道，属于其它协议的报文可以穿过这个隧道。</p><h3 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h3><p>举个栗子：网络上常见的文件传输，就用到了DNS域名解析功能。</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015104304714.png" alt="image-20211015104304714"></p><h4 id="域名系统结构"><a href="#域名系统结构" class="headerlink" title="域名系统结构"></a>域名系统结构</h4><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015104422412.png" alt="image-20211015104422412">y</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015105210722.png" alt="image-20211015105210722"></p><p>域名空间的结构是一棵多叉树，这棵树总共有128级，0级（根结点）至127级。</p><p><strong>标签：</strong>树上面的每一个结点都有一个标签，标签是一个最多63个字符的字符串，根节点符号是空串，DNS要求每一个结点的子结点有不同的标签，这样保证了域名的唯一性。</p><p><strong>域名：</strong>树上的每一个节点都有一个域名，域名是通过 . 分隔开的标签序列。</p><p><strong>域：</strong>域是域命名空间的子树，域的名称是子树顶端结点的名称。</p><p><strong>区域：</strong>树的部分区域，服务器内有一个数据库，称为区域文件，它保存着这个域里所有的结点信息。</p><p><strong>根服务器：</strong>根服务器通常不保存关于域的任何信息，只是将其委托给其它服务器，并保持与这些服务器的参照关系。</p><p><strong>主服务器和辅助服务器：</strong>主服务器是指存储了授权区域有关文件的服务器。它负责创建、维护、更新区域文件，并将区域文件存储在本地磁盘中。辅助服务器则是负责从另一个服务器传输一个区域的全部信息，并将文件存储在它的本地磁盘中，辅助服务器不负责更新区域文件，如果需要更新只能由主服务器完成，然后再发给辅服务器。</p><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><ul><li>递归解析：本地服务器通常不能一次获取到目标域名的IP地址，所以需要经过多个域名服务器的转发来识别。递归解析特点就在于每次转发获取到下一跳DNS服务器的IP地址后就由当前DNS服务器继续向下转发，而不是返还给初始本地DNS服务器来访问。</li></ul><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015110310942.png" alt="image-20211015110310942"></p><ul><li>迭代解析：每次获取到下一跳DNS 域名服务器的IP地址后，返还给初始本地DNS域名服务器进行访问。</li></ul><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015110401537.png" alt="image-20211015110401537"></p><h4 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h4><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015110449162.png" alt="image-20211015110449162"></p><p>DNS报文分为查询报文和响应报文，两种报文都有相同的格式。</p><ul><li>标识：用来匹配对查询的响应。</li><li>标记：定义了报文是响应报文还是查询报文。</li></ul><p>DNS可以只使用UDP或者TCP报文，在这两种情况下使用的是53端口，当响应报文的长度小于512字节就需要使用UDP，如果报文长度大于512字节就需要使用TCP。</p><h3 id="对等模式-（P2P）"><a href="#对等模式-（P2P）" class="headerlink" title="对等模式 （P2P）"></a>对等模式 （P2P）</h3><p>客户服务器模式，总体上分为两类：集中式和分散式。</p><ul><li><p>集中式网络：在集中式P2P网络中，目录系统列出了对等节点以及它们提供的内容。一个寻找特定文件的对等结点向中心服务器发送一个查询，服务器搜索其目录，将含有所需文件副本的多个结点的IP地址作为响应返回对等结点。对等结点与其中一个结点连接并下载文件，当有结点加入或者离开时，目录立即进行更新。</p><p>集中式网络缺点在于当流量巨大时会导致系统速度降低。</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015115102234.png" alt="image-20211015115102234"></p></li><li><p>分散式网络：分散式网络并不依赖于中心化目录系统。而是依照覆盖网的结构进行设计。包括两种网络：结构化网络、非结构化网络。</p><p>非结构化网络的效率比较低，因为结点随机连接，结点的搜索效率不高，因为对一个文件的查询必须通过网络进行泛洪，这将造成极大的通信量。</p><p>结构化网络采用一组预先确定的规则来连接结点，有效并高效地解决查询，最常用的技术是分布式散列表（Distributed Hash Table）。</p></li></ul><h4 id="分布式散列表-Distributed-Hash-Table，-DHT"><a href="#分布式散列表-Distributed-Hash-Table，-DHT" class="headerlink" title="分布式散列表 (Distributed Hash Table， DHT)"></a>分布式散列表 (Distributed Hash Table， DHT)</h4><blockquote><p>分布式散列表根据预先定义的规则将数据分发到一组结点上。对于基于DHT的网络，每一个对等节点负责一系列数据项。为了避免我们在非结构化P2P网络中讨论的洪泛开销，基于DHT的网络允许每个对等结点对整个网络做部分了解。</p><p>DHT的主要功能是将一个查询路由到负责存储这个对象引用的结点上，每个结点必须对整个环有部分了解，从而将查询路由到与负责结点最接近的一个结点上。</p><p>通俗来说就是将网络中的计算机结点哈希映射到圆形哈希表上的不同位置，同时将这些主机上的文件也经过哈希映射到哈希表上。文件对象保存在相应的计算节点上，但是文件对象的引用存储在另一个结点上(该结点的ID最接近关键字)。</p></blockquote><p>在基于DHT的网络中，每个数据项被映射到了大小为 2^m 的地址上，绝大多数DHT使用的 m&#x3D;160。</p><p><strong>散列对等结点标识符</strong>：创建DHT的第一步是将所有对等结点放入地址空间环中，通过散列函数：<code>结点ID = hash(对等结点IP地址)</code> 来计算。</p><p><strong>散列对象标识符</strong>：被共享的文件的名称的散列结果称为关键字，通过函数 <code>关键字 = hash(对象名)</code> 来计算，在DHT中一个对象通常和一组 (key，value) 相关，其中 key 是对象名的散列值，value是对象或者对象的引用。</p><p>绝大多数DHT系统使用间接方法，即拥有对象的对等结点保存对象，但是对象的引用被创建并存储在另一个结点上，这个结点的ID最接近关键字。</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211018131504178.png" alt="image-20211018131504178"></p><h4 id="DHT算法-——-chord"><a href="#DHT算法-——-chord" class="headerlink" title="DHT算法 —— chord"></a>DHT算法 —— chord</h4><ul><li>算法要素：</li></ul><ol><li><p>标识符空间：对等结点和数据项(比如一个需要共享的文件)同时按照顺时针分布在一个环上，我们将数据项的标识符称为k（即key，关键字），对等节点的标识符为 N(即node，结点)。最接近 N ≥ k 的对等结点称作关键字 k 的后向结点并且拥有数值 (k，v)，其中 k是关键字(数据项的散列值)，v是拥有对象的对等结点服务器的信息。 也就是说文件这类数据存储在拥有数据项的对等结点上，但是数据项的散列值key以及对等结点的信息value被作为一对(k，v) 存储在 k 的后向结点上。</p></li><li><p>指针表：为了找到目标关键字所在的对等结点，需要通过结点间的转发来不断查找，因此设计了指针表。 Chord 要求每一个结点维护 m 的后向结点以及一个前向结点的信息，每个结点创建一个称为指针表的路由表。Chord 环中每个结点的第一个指针给出了后向结点的ID。</p><p>通过指针表每个结点就能认识到哈希表中其它结点的信息。</p></li></ol><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211018132607924.png" alt="image-20211018132607924"></p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211018132804577.png" alt="image-20211018132804577"></p><ul><li>算法关键方法 —— 查找</li></ul><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211018132723392.png" alt="image-20211018132723392"></p><p><code>lookup(key)</code> 函数调用 <code>find_successor(id)</code> 函数来找到这个ID的后向结点，在查找后向结点时可以通过前向结点来迭代查找，因为前向结点的第一个指针（<code>finger[1]</code>）给出了后向结点的ID。</p><p>一个结点需要其它结点的帮助来找到关键字 key 的前向结点，这一步可以将 <code>find_closest_predecessor(id)</code>函数作为远程程序调用<code>RPC</code>来完成。</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211026140716013.png" alt="image-20211026140716013"></p><h4 id="DHT算法-——-Pastry"><a href="#DHT算法-——-Pastry" class="headerlink" title="DHT算法 —— Pastry"></a>DHT算法 —— Pastry</h4><p>待续。。。。。</p><h4 id="DHT算法-——-Kademlia"><a href="#DHT算法-——-Kademlia" class="headerlink" title="DHT算法 —— Kademlia"></a>DHT算法 —— Kademlia</h4><p>待续。。。。</p><h3 id="套接字Socket"><a href="#套接字Socket" class="headerlink" title="套接字Socket"></a>套接字Socket</h3><h5 id="套接字的数据结构"><a href="#套接字的数据结构" class="headerlink" title="套接字的数据结构"></a>套接字的数据结构</h5><p>套接字并没有存储待发送或者待接收数据的缓冲区，它既不能发送也不能接收数据，套接字只是起到一个引用或标签的作用。缓冲区和必要的变量在操作系统中创建。</p><ul><li>族：定义了协议簇。通常是 <code>PF_INET</code>、<code>PF_INET6（下一代因特网）</code>。</li><li>类型：套接字的四种类型。<code>SOCK_STREAM(用于TCP)</code>、<code>SOCK_DGRAM(用于UDP)</code>、<code>SOCK_SEQPACKET(用于SCTP)</code>、<code>SOCK_RAW(用于直接使用ISP服务的应用)</code>。</li><li>协议：定义了族中特定协议。对于 TCP&#x2F;IP 协议族字段设置为0。</li><li>本地套接字地址。套接字地址由 长度字段、族字段、端口号字段、IP地址字段构成。</li><li>远程套接字地址。</li></ul><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211026143525933.png" alt="image-20211026143525933"></p><h5 id="UDP通信过程"><a href="#UDP通信过程" class="headerlink" title="UDP通信过程"></a>UDP通信过程</h5><p>UDP通信中客户和服务器每一端只使用一个套接字，服务器创建的套接字永远运行，而且服务器只创建一个套接字。客户端的套接字在每次通信结束时被销毁关闭。</p><ul><li>服务器进程：服务器进程被动开启。首先通过<code>socket()</code> 函数创建套接字，在这个程序调用中填充了套接字的前三个字段，但是本地和远程套接字地址字段仍然未定义。之后服务器进程调用<code>bind()</code> 函数来填充本地套接字地址字段（信息来自操作系统）。然后调用 <code>recvfrom()</code>函数阻塞服务器进程直到一个客户数据报到达。当下一个数据报到达时，服务器进程接触阻塞并且从数据报中抽取出发送套接字地址，填充到套接字的远程套接字地址字段。这样完成了全部套接字字段的填充，通过<code>sento()</code>函数来完成数据的发送。</li><li>客户端进程：客户进程主动开启。首先通过<code>socket()</code>函数创建一个套接字并填充到前三个字段，它不需要通过<code>bind()</code>函数来填充本地套接字地址，这个操作由操作系统自动完成，它会选择一个临时端口号。之后进程调用<code>sendto()</code>函数，并提供远程套接字地址信息，这个套接字地址必须由客户进程的用户提供。套接字完成填充就进行数据发送，接着调用<code>recvfrom()</code>函数，阻塞了客户进程直到响应来自服务器进程。此外没有必要从这个函数中提取远程套接字地址，因为此处不需要调用<code>sendto()</code>函数。</li><li>总结：服务端和客户端的<code>recvfrom()</code>函数行为不同，在服务器进程中，<code>recvfrom()</code>函数首先被调用获取远程套接字地址然后调用<code>sendto()</code>发送数据。在客户端进程中，<code>sendto()</code>函数先调用发送数据，此时远程套接字地址由程序使用者提供。</li></ul><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211026143823590.png" alt="image-20211026143823590"></p><h5 id="TCP通信过程"><a href="#TCP通信过程" class="headerlink" title="TCP通信过程"></a>TCP通信过程</h5><p>TCP是面向连接的协议，所以需要先建立连接再发送或者接收数据。TCP服务端使用两个不同的套接字，一个用于建立连接，一个用于数据传输。设置两个套接字的目的是为了将建立阶段和数据传输阶段分隔开。客户端只使用一个套接字用于连接建立和数据交换。</p><ul><li><p>服务器进程：首先调用<code>socket()</code>和<code>bind()</code>函数创建监听套接字，它只在建立连接阶段使用。之后服务器调用<code>listen()</code>函数允许客户端开始接收客户，<strong>完成客户连接</strong>并将它们放入到等待被服务的列表。接着服务器进程开始循环并且逐一对客户进行服务，每次循环过程中调用<code>accept()</code>函数从已连接客户的等待列表中去除一个客户，对其进行服务。当<code>accept()</code>函数返回时，它会创建一个新的套接字用来进行数据传输，监听套接字此时就移入到后台，并且新的套接字称为活动套接字。服务器进程此时使用连接建立阶段获取的客户端套接字地址作为远程套接字地址。</p><p>TCP服务器使用 <code>send()</code>以及<code>recv()</code>函数在两者之间进行数据传递。这两个函数比UDP中的<code>sendto()</code>、<code>recvfrom()</code>更简单，它不需要提供远程套接字地址，因为连接已经在两者之间建立起来了。同时由于TCP多用于传输无边界报文，所以<code>send()</code>、<code>recv()</code>函数可能被调用用来多次处理大量数据传输。</p></li></ul><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211026163336899.png" alt="image-20211026163336899"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 自顶向下方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机—垃圾收集器与内存分配策略</title>
      <link href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
      <url>/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在Java的运行时数据区的各个部分，其中程序计数器、虚拟机栈、本地方法栈都为线程私有，随着线程生灭。因此垃圾收集器的主要作用区域是线程共享的堆和方法区。</p></blockquote><h2 id="确定哪些对象需要被回收？"><a href="#确定哪些对象需要被回收？" class="headerlink" title="确定哪些对象需要被回收？"></a>确定哪些对象需要被回收？</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p><strong>算法思路：</strong>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加一；当引用失效时，计数器的值就减一；任何时刻计数器为零的对象就是不会再被使用的。</p><p>引用计数法执行起来很简单，效率也比较高，但是有一个很难解决的问题就是循环引用。什么是循环引用？</p><p>对象 objA和对象objB都由字段 instance，赋值令 objA.instance &#x3D; objB.instance，除次之外，这两个对象再无其它引用，此时就会产生循环引用的问题。</p><span id="more"></span><p>但是测试过程中发现虽然代码中存在循环引用的问题，最终还是进行了垃圾回收，也就是说Java虚拟机并不是通过引用计数算法来判断对象是否是存活的。</p><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p><strong>算法思路：</strong>通过一系列被称为 “GC Roots”的根对象作为起始结点集，从这些结点开始，根据引用关系向下搜索，搜索过程所走过的路径称为 “引用链”，如果某个对象到GC Roots间没有任何引用链相连。或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。</p><p>其中固定可以作为<code>GC Roots</code>的对象包括以下几种：</p><ul><li>虚拟机栈中引用的对象，比如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>在方法区中类静态属性引用的对象，比如Java引用类型的静态变量；</li><li>在方法区中类的静态常量引用的对象，比如说字符串常量池里面的引用；</li><li>在本地方法栈中JNI（Native方法）引用的对象；</li><li>Java虚拟机内部的引用，比如说基本数据类型对应的Class对象，一些常驻的异常对象等，还有系统类加载器。</li><li>所有被同步锁（Synchronized）持有的对象。</li></ul><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>在JDK1.2 版本之后，Java对引用的概念进行了扩充，将引用分为强引用(Strongly-Reference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)四种，四纵强度依次减弱。</p><ul><li><strong>强引用：</strong>通常指<code>Object obj = new Object()</code>这种引用关系，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li><li><strong>软引用：</strong>指一些有用但非必须的对象，只被软引用关联的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li><li><strong>弱引用：</strong>指一些非必须的对象，强度比软引用更弱一些，被弱引用关联的对象<strong>只能</strong>生存到下一次垃圾收集发生为止。当垃圾收集开始工作时，无论当前对象内存是否足够都会回收掉只被弱引用关联的对象。在JDK1.2版本之后提供了Weak Reference 类来实现弱引用。</li><li><strong>虚引用：</strong>虚引用也被称为幽灵引用或者幻影引用，是最弱的一种引用关系。无法通过虚引用来获取一个对象实例，为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知，可以通过<code>PhantomReference</code>类来实现虚引用。</li></ul><h3 id="判断对象生存还是死亡"><a href="#判断对象生存还是死亡" class="headerlink" title="判断对象生存还是死亡"></a>判断对象生存还是死亡</h3><p>如果对象在可达性分析法中被标记为不可达状态，此时它不会直接被回收，而是需要经过第二次标记后才能确定，也就是说一个对象的回收至少需要经过两次标记过程。</p><p>对象如果通过可达性分析法后发现没有与GC Roots相连接的引用链，那么它会第一次被标记，然后进行一次筛选，筛选的条件是该对象是否有必要执行 <code>finalize()</code>方法。如果说对象没有覆盖<code>finalize()</code>或者对象的<code>finalize()</code>方法已经被虚拟机调用过，那么会被视为没必要执行，结果就是回收该对象。</p><p>如果对象有必要去执行<code>finalize()</code>方法，那么该对象会被放在一个<code>F-Queue</code>队列之中，并在稍后由一条虚拟机自动建立的、低优先级的<code>Finalizer</code>线程去执行它们的<code>finalize()</code>方法。对象如果想要逃脱被回收的命运，就必须重新与引用链上的任何一个对象建立关联，比如说把自己(this关键字) 赋值给某个类变量或者对象的成员变量</p>]]></content>
      
      
      <categories>
          
          <category> 深入理解Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机—Java内存区域</title>
      <link href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域。这些区域各有各自的用途，以及创建和销毁的时间。总的来说Java虚拟机可以划分为如下几个运行时数据区部分。</p></blockquote><p>首先总体上说Java虚拟机包括<strong>方法区</strong>、<strong>堆</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>、<strong>程序计数器</strong>五个主要的运行时数据区部分。</p><p><img src="/../passageImg/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20210711104433492.png" alt="image-20210711104433492"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>程序计数器(PC) 用来指示当前线程所执行的字节码行号指示器，字节码解释器工作时就是通过改变这个计数器的值来指明下一条需要执行的字节码指令。它是程序控制流的指示器、，分支、跳转、循环、异常处理、线程恢复等基础功能都依赖于这个计数器来完成。</p><h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><p>为了多个线程之间的执行操作互不影响，每个线程都需要有一个<strong>独立</strong>的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为 “线程私有” 的内存。</p><p>如果线程执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是一个本地(Native)方法，则计数器的值应该为空。</p><p>程序计数器是各个运行时数据区中唯一一个不会出现<code>OutOfMemoryError</code>情况的区域。</p><span id="more"></span><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><h3 id="介绍：-1"><a href="#介绍：-1" class="headerlink" title="介绍："></a>介绍：</h3><p>Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储<strong>局部变量表、操作数栈、动态连接、方法出口</strong>等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><h3 id="特性：-1"><a href="#特性：-1" class="headerlink" title="特性："></a>特性：</h3><p><strong>局部变量</strong>表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用(reference类型，不等同于对象本身，可能是指向对象起始地址的引用指针，或者是代表对象的句柄)、returnAddress类型。这些数据在局部变量表中的存储空间以局部变量槽(Slot)来表示，其中64位长度的long和double会占用两个变量槽，其余数据类型只占用一个。</p><p>该区域的<strong>异常情况</strong>包括：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常；如果虚拟机栈的容量可以扩展，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError</code>异常。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈和虚拟机栈的作用类似，不同的是虚拟机栈为虚拟机执行Java方法（字节码）服务；而本地方法则是为虚拟机使用本地（Native）方法服务。</p><p>同样在请求栈的深入大于虚拟机栈的深度时会抛出栈溢出异常；当栈的内存无法得到扩展 时会抛出内存溢出异常。</p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java中几乎所有的对象实例都在Java 堆分配的，Java堆是被所有线程共享的一块区域。Java堆是垃圾收集器管理的区域。</p><p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出<strong>多个线程私有的分配缓冲区（Thread Local Allocation Buffer）TLAB</strong>，用来提升对象分配时的效率。不过无论怎么划分，都不会改变Java堆中存储内容的共性，无论哪个区域，存储的都只能是对象的实例。</p><p>Java堆可以处于物理上不连续的内存空间中，但是在逻辑上它应该被视为连续的。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区也是线程共享的内存区域，它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等数据。</p><h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>在JDK8之前方法区被称为永久代，目的是为了把收集器的分代收集理论扩展至方法区，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分的内存，省去了专门为方法区编写内存管理代码的工作。</p><p>永久代存在的问题是导致了Java应用更容易遇到内存溢出的问题（永久代有 <code>-XX:MaxPermSize</code>的上限），即使不设置也有默认大小。</p><p>在JDK7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量都移出，到JDK8完全废弃了永久代的概念。</p><h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>方法区和堆一样都是线程共享的区域，因此也涉及到一定的垃圾回收。这个区域的内存回收的主要目标是针对<strong>常量池的回收和对类型的卸载</strong>。</p><h3 id="运行时常量池和常量池"><a href="#运行时常量池和常量池" class="headerlink" title="运行时常量池和常量池"></a>运行时常量池和常量池</h3><p>运行时常量池也是方法区的一部分。Class文件中除了有<strong>类的版本、字段、方法、接口</strong>等描述信息外，还有一项是<strong>常量池表</strong>。常量池表用于存放<strong>编译期生成的各种字面量和符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，Java语言并不要求常量一定只有编译期才能产生，并非预置入Class文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可以进入。比如说String类的 intern() 方法就能够在运行期间将字符串放入到常量池中。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h3 id="介绍：-2"><a href="#介绍：-2" class="headerlink" title="介绍："></a>介绍：</h3><p>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，但是这部分内存也被频繁使用。</p><p>比如说Java中新加入的 <code>NIO(New Input/Output)</code>类，引入了一种基于通道(Channel)与缓冲区(Buffer)的 I&#x2F;O方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因此避免了在Java堆和Native堆中来回复制数据。</p><h2 id="虚拟机中的对象"><a href="#虚拟机中的对象" class="headerlink" title="虚拟机中的对象"></a>虚拟机中的对象</h2><h3 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h3><p>（1）当Java虚拟机遇到一条字节码 new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否已经被<strong>加载、解析和初始化</strong>过。如果没有那就必须要先执行相应的类的加载过程。</p><p>（2）在类加载检查通过后，接下来虚拟机将为新生对象分配内存。这里需要根据内存是否规整选用不同的分配方法（<strong>指针碰撞</strong>和<strong>空闲列表</strong>）。<strong>指针碰撞：</strong>如果Java堆中的内存是绝对规整的，所有被使用过的内存都放在一边，空闲的被放在另一边，中间放着一个指针作为分界点指示器，所分配的内存就仅仅把指针向空闲的方向挪动一段与对象大小相等的距离。<strong>空闲列表：</strong>Java堆中的内存是不规整的，已经被使用的内存和空闲的内存相互交错在一起，那样就不能进行简单的指针碰撞了，虚拟机就必须维护一个列表，记录上面哪些内存块是可用的，在分配的时候从列表中找到一块足够大小的空间划分给对象实例，并更新列表上的记录。</p><p>而Java堆中内存是否规整又与其采用的垃圾收集器是否带有空间压缩整理的能力决定，因此当使用<code>Serial</code>、<code>ParNew</code>等带有压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，简单高效；而使用基于清除算法的<code>CMS</code>收集器时，理论上就只能采用较为复杂的空闲列表来实现。</p><p>在使用指针碰撞分配方式时会出现一些问题，因为对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现给对象A分配内存指针还没来得及修改，对象B又同时使用原来的指针来分配内存的情况。有两种方案解决这个问题：①对分配内存空间的动作进行同步处理—实际上虚拟机是采用<strong>CAS配上失败重试</strong>的方式保证更新操作的原子性；②另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。虚拟机是否使用TLAB，可以通过 <code>-XX:+/-UseTLAB</code>参数来配置。</p><p>（3）内存分配完成之后，虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作就可以提前至TLAB分配时顺便进行。</p><p>（4）接下来需要对对象进行必要的设置，比如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头(Object Header)之中。根据当前的虚拟机运行的不同状态，来决定是否采用偏向锁等。</p><p>（5）利用构造函数开始创建对象，即运行Class文件中的<code>init()</code>方法。直到现在一个真正可用的对象才算完全地构造出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><blockquote><p> 在HotSpot虚拟机中，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据、对齐填充。</p></blockquote><h4 id="1-对象头"><a href="#1-对象头" class="headerlink" title="1. 对象头"></a>1. 对象头</h4><p>对象头包含两个部分，第一类是用于存储对象自身的运行时数据的<code>Mark Word</code>，第二类是用于该对象所属的类型——<code>类型指针</code>。</p><p><strong>Mark Word</strong>：对象运行时自身的数据，比如说哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。该结构随着对象运行时自身的状态变化而变化。</p><table><thead><tr><th>存储内容</th><th>标志位</th><th>状态</th></tr></thead><tbody><tr><td>对象哈希码、对象分代年龄</td><td>01</td><td>未锁定</td></tr><tr><td>指向锁记录的指针</td><td>00</td><td>轻量级锁定</td></tr><tr><td>指向重量级锁的指针</td><td>10</td><td>重量级锁定</td></tr><tr><td>空，不需要记录信息</td><td>11</td><td>GC标记</td></tr><tr><td>偏向线程ID、偏向时间戳、对象分代年龄</td><td>01</td><td>可偏向</td></tr></tbody></table><p><strong>类型指针：</strong>即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例，但并不是所有的虚拟机都必须在对象数据上保留类型指针。</p><p>此外如果对象是一个Java数组，那么在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过类型元数据信息来确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</p><h4 id="2-实例数据"><a href="#2-实例数据" class="headerlink" title="2. 实例数据"></a>2. 实例数据</h4><p>实例数据是对象真正存储的有效信息，即我们在程序代码中所定义的各种类型的字段内容，无论是从父类继承下来的，还是自己程序代码中新定义的。</p><h4 id="3-对齐填充"><a href="#3-对齐填充" class="headerlink" title="3. 对齐填充"></a>3. 对齐填充</h4><p>对象的第三个部分是对齐填充，它没有什么含义，仅仅起到占位符的作用。由于HotSpot虚拟机的自动内存管理要求对象起始地址必须是8字节的整数倍。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>对象创建完后，我们通过栈上的<code>reference</code>数据来操作堆上的具体对象。但是它只是指定了一个对象的引用，没有定义这个引用应该用什么方式去定位、访问。总体上说主要有句柄和直接指针两种方式。</p><ul><li>句柄：Java堆中额外划分出一块内存来作为句柄池，<code>reference</code>中存储的就是对象的句柄地址，而句柄中包含了对象的实例数据和类型数据各自具体的地址信息。</li></ul><p><img src="/../passageImg/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20210711212910574.png" alt="image-20210711212910574"></p><ul><li>直接指针：如果使用直接指针访问的话，<code>reference</code>中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li></ul><p><img src="/../passageImg/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20210711213301273.png" alt="image-20210711213301273"></p><h2 id="OutOfMemoryError异常和StackOverflowError异常"><a href="#OutOfMemoryError异常和StackOverflowError异常" class="headerlink" title="OutOfMemoryError异常和StackOverflowError异常"></a>OutOfMemoryError异常和StackOverflowError异常</h2><p>待补充。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 深入理解Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP三握四挥知识拓展</title>
      <link href="/2021/05/10/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E6%8B%93%E5%B1%95/"/>
      <url>/2021/05/10/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E6%8B%93%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP与UDP、三握四挥的拓展"><a href="#TCP与UDP、三握四挥的拓展" class="headerlink" title="TCP与UDP、三握四挥的拓展"></a>TCP与UDP、三握四挥的拓展</h1><h2 id="TCP-基本认识"><a href="#TCP-基本认识" class="headerlink" title="TCP 基本认识"></a>TCP 基本认识</h2><img src="/passageImg/TCP三握四挥.assets/1616140750-aAtekK-file_1616140748581" alt="img" style="zoom: 80%;" /><h3 id="1-TCP-头格式"><a href="#1-TCP-头格式" class="headerlink" title="1. TCP 头格式"></a>1. TCP 头格式</h3><blockquote><p>参考：<a href="https://blog.csdn.net/zhouzhenhe2008/article/details/71075969">https://blog.csdn.net/zhouzhenhe2008/article/details/71075969</a></p><p><a href="https://www.cnblogs.com/azraelly/archive/2012/12/25/2832393.html">https://www.cnblogs.com/azraelly/archive/2012/12/25/2832393.html</a></p></blockquote><img src="/passageImg/TCP三握四挥.assets/1616140750-tkQhoX-file_1616140748676" alt="TCP 头格式" style="zoom: 67%;" /><ul><li><p>序列号：在初始建立连接时计算机随机分配一个值作为初始值，之后每发送一次数据就加上此次发送数据的字节数大小。<strong>用来解决包乱序问题</strong>。</p></li><li><p>确认号：表示下一次希望接收的数据的序号。发送方通过确认号来确定此序号之前的所有数据都被接收了，<strong>用来确认传输过程不丢包</strong>。</p></li><li><p>控制位：（URG、ACK、PSH、SYN、RST、FIN）</p><p>URG：为1表示有紧急数据需要发送，结合紧急指针一起使用；</p><p>ACK：初始建立连接时为0，之后整个数据传输过程都为1，表示确认号有效；</p><p>PSH：为1表示本次传送的数据不为空，真正的有数据需要传输；</p><p>SYN：为1表示请求建立连接；</p><p>RST：为1表示tcp连接时出现了问题，需要重新建立连接；</p><p>FIN：为1表示通信过程结束，请求释放连接。</p></li><li><p>窗口大小：指的是接收窗口的大小，用来进行流量控制，解决拥塞问题。</p></li><li><p>校验和：对整个TCP报文段进行检验，包括头和数据部分，并由目标端进行验证。（这里和IP数据报不一样，IP数据报只检验首部）；</p></li><li><p>紧急指针：有紧急数据需要传送，是一个偏移量，和序号字段的值相加表示紧急数据最后一个字节的需要。</p></li><li><p>选项：长度不确定，最大为40字节（和IP数据报的可选部分类似）。</p></li></ul><span id="more"></span><h3 id="2-为什么需要TCP协议？工作在哪一层？"><a href="#2-为什么需要TCP协议？工作在哪一层？" class="headerlink" title="2. 为什么需要TCP协议？工作在哪一层？"></a>2. 为什么需要TCP协议？工作在哪一层？</h3><p>因为网络层是一种不可靠的传输（传输的数据没有序号进行标注），不能够保证网络包按序、完整的交付；那么就需要上层（传输层）来保证传输的可靠性。</p><p>TCP是一个工作在传输层的<strong>基于连接</strong>的<strong>可靠</strong>数据传输服务，它能够保证传输的数据包的完整有序。</p><h3 id="3-什么是TCP？"><a href="#3-什么是TCP？" class="headerlink" title="3. 什么是TCP？"></a>3. 什么是TCP？</h3><blockquote><p>TCP 是工作在传输层的一种面向连接、可靠的、基于字节流的通信协议。</p></blockquote><ul><li>面向连接：只能是一对一的连接，不能像UDP 那样，可以一个主机向多个主机发送数据。</li><li>可靠的：无论传输链路如何变化，都能保证数据完整的、有序的到达接收端；</li><li>基于字节流：消息是没有边界的，无论需要传输的消息有多大都可以传输，不像UDP只能传输上层的报文(不能修改或者合并)；而且是有序的，即使后面的字节先到达也不能扔给应用层去处理，必须等到所有数据有序抵达后才能交给上层。</li></ul><h3 id="4-什么是TCP连接？"><a href="#4-什么是TCP连接？" class="headerlink" title="4. 什么是TCP连接？"></a>4. 什么是TCP连接？</h3><p>连接的定义：连接是用于保证可靠性和流量控制所维护的某些状态信息，这些信息的组合，包括 socket、序列号和窗口大小称为连接。</p><p>所以建立一个 TCP连接需要客户端和服务器端达成三个信息的共识：</p><p>（1）socket：由ip地址和端口号组成；</p><p>（2）序列号：保证传输有序；</p><p>（3）窗口大小：用来做流量控制；</p><h3 id="5-如何唯一确定一个TCP连接？"><a href="#5-如何唯一确定一个TCP连接？" class="headerlink" title="5. 如何唯一确定一个TCP连接？"></a>5. 如何唯一确定一个TCP连接？</h3><p>通过 TCP 四元组来唯一确定一个连接，四元组包括：</p><ul><li>源地址</li><li>目的地址</li><li>源端口</li><li>目的端口</li></ul><p>源地址和目的地址在 IP数据报的首部中指明，作用是通过IP协议发送报文给对方主机；</p><p>源端口和目的端口在 TCP报文的首部中指明，作用是告诉TCP协议应该把报文发送给哪个进程。</p><p><img src="/passageImg/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5.assets/1616140750-XDKUcL-file_1616140748725" alt="TCP 四元组"></p><h3 id="6-有一个IP的服务器监听了一个端口，它的-TCP的最大连接数是多少？"><a href="#6-有一个IP的服务器监听了一个端口，它的-TCP的最大连接数是多少？" class="headerlink" title="6. 有一个IP的服务器监听了一个端口，它的 TCP的最大连接数是多少？"></a>6. 有一个IP的服务器监听了一个端口，它的 TCP的最大连接数是多少？</h3><p>服务器通常在某个固定的端口等待监听客户端请求。</p><p>客户端IP 和端口是可变的，理论计算公式如下：</p><p>   <code>最大TCP连接数=客户端的IP数 × 客户端的端口数</code></p><p>对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方。</p><p>当然服务端最大并发TCP连接数远不能达到理论上限。</p><ul><li>首先主要是<strong>文件描述符</strong>限制，Socket都是文件，所以首先要通过 ulimit 配置文件描述符的数目；</li><li>另一个是<strong>内存限制</strong>，每个TCP都要占用一定的内存，操作系统内存是有限的。</li></ul><h3 id="7-UDP和TCP的区别，分别的运用场景？"><a href="#7-UDP和TCP的区别，分别的运用场景？" class="headerlink" title="7. UDP和TCP的区别，分别的运用场景？"></a>7. UDP和TCP的区别，分别的运用场景？</h3><p>介绍一下UDP：</p><ul><li><p>UDP不提供复杂的控制机制，利用IP 提供无连接的通信服务；</p></li><li><p>UDP协议非常简单，头部只有8个字节。</p></li></ul><img src="/passageImg/TCP三握四挥.assets/1616140750-GcrCSE-file_1616140748889" alt="UDP 头部格式" style="zoom:80%;" /><p>（1）源端口号、目的端口号：告诉UDP协议应该将报文发送给哪个进程；</p><p>（2）包长度：该字段保存了UDP首部的长度跟数据的长度之和；</p><p>（3）校验和：校验和是为了提供可靠的UDP首部和数据而设计。</p><h5 id="UDP和TCP的区别："><a href="#UDP和TCP的区别：" class="headerlink" title="UDP和TCP的区别："></a>UDP和TCP的区别：</h5><ol><li>连接</li></ol><ul><li>TCP是面向连接的传输层协议，传输数据前要先建立连接；</li><li>UDP是不需要连接，即刻传输数据；</li></ul><ol start="2"><li>服务对象</li></ol><ul><li>UDP是一对一或者一对多或者多对多进行传输；</li><li>TCP只能是一对一传输；</li></ul><ol start="3"><li>可靠性</li></ol><ul><li>TCP是可靠交付数据的，数据可以无差错、不丢失、不失序、不重复、按需到达；</li><li>UDP是尽最大努力交付，不保证可靠交付数据。</li></ul><ol start="4"><li>拥塞控制、流量控制</li></ol><ul><li>TCP 通过拥塞控制和流量控制来保证数据传输的安全性；</li><li>UDP没有，即使网络非常阻塞，也不会影响UDP传输速率；</li></ul><ol start="5"><li>首部开销</li></ol><ul><li>TCP首部固定20个字节，另外选项字段不固定；</li><li>UDP首部总共8个字节，固定不变开销小；</li></ul><ol start="6"><li>传输方式</li></ol><ul><li>TCP是基于字节流的传输，数据传输单位是报文段，在网络层封装分组进行传输。</li><li>UDP传输单位是用户数据报，在网络层封装为数据包进行传送。</li></ul><ol start="7"><li>分片不同</li></ol><ul><li>TCP的数据大小如果大于MSS（最大报文段长度），就会在<strong>传输层</strong>进行分片，目标主机收到后会重新组装完数据，接着再传给传输层。如果中途丢失了分片，只需要重传这个分片即可。</li><li>UDP的数据大小如果大于MTU，就会在<strong>网络层</strong>进行分片，目标主机收到后在IP层组装数据，再传输给传输层。如果中途丢失了分片，就需要重传所有数据包，效率低。</li></ul><h5 id="TCP和UDP的应用场景："><a href="#TCP和UDP的应用场景：" class="headerlink" title="TCP和UDP的应用场景："></a>TCP和UDP的应用场景：</h5><p>TCP是面向连接的，常用于保证可靠性交付的数据传递，包括：</p><ul><li>FTP文件传输；</li><li>HTTP&#x2F;HTTPS；</li></ul><p>UDP面向无连接，随时发送数据：</p><ul><li>包总量较少的传输，比如SNMP、DNS；</li><li>视频、音频传输；</li><li>广播通信。</li></ul><p><code>SNMP 详解：</code><a href="http://c.biancheng.net/view/6467.html">http://c.biancheng.net/view/6467.html</a></p><h3 id="8-为什么UDP首部没有首部长度字段，而TCP有"><a href="#8-为什么UDP首部没有首部长度字段，而TCP有" class="headerlink" title="8.为什么UDP首部没有首部长度字段，而TCP有"></a>8.为什么UDP首部没有首部长度字段，而TCP有</h3><p>因为 TCP 首部有可变长的[选项]字段；而UDP头部长度是固定不会变化的。</p><h3 id="9-为什么-UDP首部有包长度字段，而TCP首部没有呢"><a href="#9-为什么-UDP首部有包长度字段，而TCP首部没有呢" class="headerlink" title="9.为什么 UDP首部有包长度字段，而TCP首部没有呢"></a>9.为什么 UDP首部有包长度字段，而TCP首部没有呢</h3><p>先了解下TCP是如何计算负载数据的长度的：</p><p><code>TCP的数据长度 = IP总长度 - IP首部长度 - TCP首部长度</code></p><p>其中变量都是已知的可以直接求出TCP的数据长度；</p><p>同理UDP也可以通过这种方式计算，但是UDP的首部组成为源端口（16位）、目的端口（16位）、包长度（16位）、校验和（16位），如果去掉了包长度字段那么剩下的48位（6字节）不能满足网络硬件设备的设计需要。</p><p>网络硬件设备为了处理的方便，首部长度需要设计为4字节的整数倍，去掉包长度字段就不能达到这个要求。</p><h2 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h2><h3 id="★-1-TCP三次握手的过程和状态变迁"><a href="#★-1-TCP三次握手的过程和状态变迁" class="headerlink" title="★ 1. TCP三次握手的过程和状态变迁"></a>★ 1. TCP三次握手的过程和状态变迁</h3><p>TCP是面向连接的通信协议，所以在使用TCP前必须先建立连接，而连接的建立是通过三次握手来进行的。</p><img src="/passageImg/TCP三握四挥.assets/1616140750-FadmSh-file_1616140748635" alt="TCP 三次握手" style="zoom:80%;" /><p>（1）初始状态时，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</p><img src="/passageImg/TCP三握四挥.assets/1616140750-jCbEyW-file_1616140748904" alt="第一个报文—— SYN 报文" style="zoom:80%;" /><p>（2）客户端随机初始化一个序号<code>client_isn</code>作为TCP首部的 [序号] 字段，同时把 SYN 设置为1表示正在请求建立连接。然后将该 SYN 报文发送给服务端，表示请求建立连接，<strong>该报文中不含有应用层数据</strong>，之后客户端处于 <code>SYS_SENT</code> 状态。</p><img src="/passageImg/TCP三握四挥.assets/1616140750-AYtmBt-file_1616140748642" alt="第二个报文 —— SYN + ACK 报文" style="zoom:80%;" /><p>（3）服务器在接收到客户端的 <code>SYN</code>报文请求后，首先服务端也开始随机初始化自己的序号<code>server_isn</code>，将此序号填写到TCP首部的序列号字段中；然后把 <code>client_isn+1</code>作为应答号也填写到TCP首部的确认应答号中；最后把 <code>ACK</code>和<code>SYN</code>都设置为1。最后将报文发送给客户端，<strong>该报文也不含有应用层数据</strong>，之后服务器处于 <code>SYS_RCVD</code>状态。</p><img src="/passageImg/TCP三握四挥.assets/1616140750-yFcdIM-file_1616140748704" alt="第三个报文 —— ACK 报文" style="zoom:80%;" /><p>（4）客户端在接收到服务器的报文后，还要向服务端回应最后一个应答报文。首先该应答报文的<code>TCP</code>首部的<code>ACK</code>字段会设置为1，然后确认应答号字段填入<code>server_isn+1</code>，最后把报文发送给服务端，<strong>这次报文可以携带应用层数据</strong>自己进入<code>ESTABLISED</code>状态。</p><p>（5）服务器接收到客户端的响应报文后也进入<code>ESTABLISED</code>状态。</p><p><strong>关键点：</strong>上面三次握手中，前两次握手都不会携带应用层的数据，只有第三次可以携带应用层数据。</p><h3 id="2-如何在Linux-系统中查看-TCP-状态？"><a href="#2-如何在Linux-系统中查看-TCP-状态？" class="headerlink" title="2. 如何在Linux 系统中查看 TCP 状态？"></a>2. 如何在Linux 系统中查看 TCP 状态？</h3><p>可以通过  <code>netstat -napt</code>的命令查看</p><p><img src="/passageImg/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5.assets/image-20210412180046477.png" alt="image-20210412180046477"></p><p>从左到右依次是：TCP协议、源地址+端口、目标地址+端口、连接状态、Web服务的进程PID和进程名称</p><h3 id="★-3-为什么是三次握手？不是两次？四次？"><a href="#★-3-为什么是三次握手？不是两次？四次？" class="headerlink" title="★ 3. 为什么是三次握手？不是两次？四次？"></a>★ 3. 为什么是三次握手？不是两次？四次？</h3><blockquote><p>回答 “因为只有三次握手才能保证双方都具备接受和发送能力”  你就GG了。</p></blockquote><p>原因有三个方面：</p><ul><li>三次握手可以防止历史连接的初始化（<strong>主要原因</strong>）</li><li>三次握手才可以同步双方的初始化序列号</li><li>三次握手才可以避免浪费资源</li></ul><h5 id="原因一：避免历史连接"><a href="#原因一：避免历史连接" class="headerlink" title="原因一：避免历史连接"></a>原因一：避免历史连接</h5><p>简单来说，三次握手的首要目的就是为了防止旧的重复连接的初始化造成的混乱。</p><img src="/passageImg/TCP三握四挥.assets/1616140750-JaRoLY-file_1616140748632" alt="三次握手避免历史连接" style="zoom:80%;" /><p>假设客户端发送一个网络连接到服务器请求建立连接，但是由于<strong>网络拥堵</strong>的情况，可能长时间未接收到服务端的响应，因此客户端会重复多次发送SYN 报文请求。</p><ul><li>如果此时一个 [旧 SYN 报文]比[新 SYN 报文]早一点到达了服务端；（假设旧报文的序号为90，新报文的序号为100）；</li><li>那么此时服务端就会返回一个<code>SYN+ACK</code>报文交给客户端；（此时确认号为91）</li><li>客户端接收到响应报文后，发现预期的确认号和当前接受的确认号不匹配，由此可以判断出这是一个历史连接，那么客户端应该返回服务端一个<code>RST</code>报文来终止此连接，请求重新建立连接。</li></ul><p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，根据需要发送的报文判断当前连接是否是历史连接：</p><ul><li>如果是历史连接，则第三次握手发送的是 <code>RST</code>报文，以此终止历史连接；</li><li>如果不是历史连接，则第三次发送的报文是<code>ACK</code>报文，通信双方就会成功建立连接。</li></ul><h5 id="原因二：同步双方初始序列号"><a href="#原因二：同步双方初始序列号" class="headerlink" title="原因二：同步双方初始序列号"></a>原因二：同步双方初始序列号</h5><p>TCP通信的双方，都必须维护一个 [序列号]，序列号是可靠传输的一个关键因素，它的作用为：</p><ul><li>接收方可以去除重复的数据；</li><li>接收方可以根据数据的序列号按序接收；</li><li>可以标识发送出去的数据包中，哪些是已经被对方收到的。</li></ul><p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带 [初始序列号] 的 <code>SYN</code>报文的时候，需要服务端返回一个<code>ACK</code>应答报文，表示服务端成功接收到了客户端的 <code>SYN</code>报文；同时服务端需要发送一个携带 [初始序列号] 的<code>SYN</code>报文给客户端的时候，依然也要得到客户端的响应，<strong>这样一来一回的过程才能够保证初始序列号能够被可靠的同步</strong>。</p><p><img src="/passageImg/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5.assets/1616140750-qZUzPR-file_1616140748735" alt="四次握手与三次握手"></p><p>四次握手其实也能够保证双方序列号的同步，但是由于<strong>第二步和第三步可以合并为一步</strong>，所以就成了三次握手。</p><p>而两次握手只保证一方的初始序列号能够被对方接收，没办法保证双方的序列号都能够被确认接收。</p><h5 id="原因三：避免资源的浪费"><a href="#原因三：避免资源的浪费" class="headerlink" title="原因三：避免资源的浪费"></a>原因三：避免资源的浪费</h5><p>如果只有 [两次握手]，当客户端的<code>SYN</code>请求在网络中阻塞。</p><p>对于客户端而言：客户端指定时间内没有接收到 <code>ACK</code>报文，就会重新发送<code>SYN</code>报文；</p><p>对于服务端而言，由于没有第三次握手，所以它不能判断客户端是否成功接收到了自己发送的<code>ACK</code>报文，所以每当有一个<code>SYN</code>报文到达，它都会主动去建立一个连接。</p><p>结果就是初始客户端发送的多次 <code>SYN</code>请求，服务端都必须一一响应。这样会造成服务器在接收请求后<strong>建立多个冗余的无效连接，造成不必要的资源浪费</strong>。</p><img src="/passageImg/TCP三握四挥.assets/1616140750-ZbUysW-file_1616140748620" alt="两次握手会造成资源浪费" style="zoom:80%;" /><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>不使用两次握手或四次握手的原因：</p><ul><li>两次握手：无法防止历史连接的创建，会造成双方资源的浪费，无法确保双方序列号的同步；</li><li>四次握手：四次握手虽然不会出现问题，但是多建立了一次没有必要的连接，浪费了资源。</li></ul><h3 id="4-为什么客户端和服务端的初始序列号-ISN-是不相同的？"><a href="#4-为什么客户端和服务端的初始序列号-ISN-是不相同的？" class="headerlink" title="4. 为什么客户端和服务端的初始序列号 ISN 是不相同的？"></a>4. 为什么客户端和服务端的初始序列号 ISN 是不相同的？</h3><ul><li><p>因为如果一个已经失效的连接被重用了，但是该旧连接的历史报文还残留在网络中。如果序列号相同，就无法分辨出当前报文是新报文还是历史报文，如果历史报文被新的连接接受了，则会产生数据混乱。</p><p>所以，每次建立连接前重新初始化当前的序列号主要就是为了通信双方能够根据序号将不属于本连接的报文段丢弃，防止网络数据混乱；</p></li><li><p>另一方面为了防止黑客伪造相同序列号的 TCP报文被对方接收。</p></li></ul><h3 id="5-初始序列号ISN是如何随机产生的？"><a href="#5-初始序列号ISN是如何随机产生的？" class="headerlink" title="5. 初始序列号ISN是如何随机产生的？"></a>5. 初始序列号ISN是如何随机产生的？</h3><p>起始的 <code>ISN</code>是基于时钟的，每4毫秒 +1，转一圈需要 4.55个小时；</p><p>后来提出了一个较好的初始化序列号<code>ISN</code>随机生成算法。</p><p><code>ISN = M+F(localhost,localPort,Remotehost,RemotePort)</code></p><ul><li>M是上述的计时器，每 4毫秒 +1；</li><li>F是一个 Hash  算法，根据源 IP地址、源端口号、目的 IP地址、目的端口号生成一个随机数值。要保证Hash算法不能被外界轻易算出，可以使用  MD5加密。</li></ul><h3 id="6-既然-IP层会分片，为什么TCP还需要MSS？"><a href="#6-既然-IP层会分片，为什么TCP还需要MSS？" class="headerlink" title="6. 既然 IP层会分片，为什么TCP还需要MSS？"></a>6. 既然 IP层会分片，为什么TCP还需要MSS？</h3><p>首先介绍下 <code>MTU</code>、<code>MSS</code>的概念以及它们之间的关系：</p><img src="/passageImg/TCP三握四挥.assets/1616140750-frxIPU-file_1616140748600" alt="MTU 与 MSS" style="zoom: 67%;" /><ul><li><code>MTU</code>：最大传输单元，一个网络数据包的最大长度，以太网中一般是 46~1500个字节；</li><li><code>MSS</code>：最大报文段长度，除去 IP头部、TCP头部之后剩余的 TCP数据部分的最大长度。</li></ul><p>如果将 TCP的整个报文（头部+数据）交给 IP层进行分片，会出现什么异常呢？</p><p>由于传输层不会分片，因此在IP层会等到数据长度达到 <code>MTU</code>时进行分片处理，将报文分成若干片，每一片都小于 <code>MTU</code>。把一份 IP数据报进行分片后，由目标主机的 IP层来进行重新组装，然后再交给上一层 TCP传输层。</p><p>这看起来没有问题，那如果传送的分片中有一个丢失了呢？</p><p><strong>IP层不是可靠的传输，因此一旦数据包分片丢失，整个IP报文的所有分片都必须重新传输；而传输层的TCP协议是面向连接的，当报文段分片发送失败时，能够进行超时重传。</strong></p><p><strong>只在IP层分片：</strong></p><p>​       当接收方发现 TCP报文（数据+头部）的某一片段丢失后，不会立刻响应<code>ACK</code>给对方，发送方的TCP在超时后，就会重发整个TCP报文。因此可以得知由 IP层进行分片传输是十分没有效率的。</p><p><strong>在传输层分片：</strong></p><p>​       如果双方协商好了 <code>MSS</code>值，且当 TCP层发现数据超过 <code>MSS</code>时，就会先进行分片，那么由它形成的IP数据包的长度就不会大于 <code>MTU</code>。这样即使发生了数据丢失，重新传输的也只是一个分片，大大增加了重传的效率。</p><h3 id="7-什么是SYN攻击，如何避免SYN攻击？"><a href="#7-什么是SYN攻击，如何避免SYN攻击？" class="headerlink" title="7. 什么是SYN攻击，如何避免SYN攻击？"></a>7. 什么是SYN攻击，如何避免SYN攻击？</h3><h5 id="什么是SYN攻击："><a href="#什么是SYN攻击：" class="headerlink" title="什么是SYN攻击："></a>什么是SYN攻击：</h5><p>TCP的连接的建立需要三次握手，假设攻击者伪造不同的 <code>SYN</code>报文，服务端每接收到一个<code>SYN</code>报文，就会进入到 <code>SYN_RCVD</code>状态。但是服务端发送出去的 <code>ACK+SYN</code>报文又没有响应，久而久之客户端发来的 <code>SYN</code>报文就会占满接收队列（队列中存储的都是等待建立的连接）。</p><h5 id="避免SYN攻击方式（一）："><a href="#避免SYN攻击方式（一）：" class="headerlink" title="避免SYN攻击方式（一）："></a>避免SYN攻击方式（一）：</h5><p>其中一种解决方式是通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。</p><ul><li><p>当<strong>网卡接收数据包的速度大于内核处理的速度</strong>时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：<code>net.core.netdev_max_backlog</code></p></li><li><p>控制服务器的 <code>SYN_RCVD</code>的状态数：<code>net.ipv4.tcp_max_syn_backlog</code></p></li><li><p>超出处理能力时，发送<code>RST</code>报文丢弃连接：<code>net.ipv4.tcp_abort_on_overflow</code></p></li></ul><h5 id="避免SYN攻击方式（二）："><a href="#避免SYN攻击方式（二）：" class="headerlink" title="避免SYN攻击方式（二）："></a>避免SYN攻击方式（二）：</h5><p>先看下 Linux内核的 <code>SYN</code>（未完成连接建立）队列与 <code>Accept</code>（已完成连接的队列）的工作过程：</p><img src="/passageImg/TCP三握四挥.assets/1616140750-bGESDU-file_1616140748798" alt="正常流程" style="zoom:67%;" /><p><strong>正常流程：</strong></p><ul><li>客户端发送 <code>SYN</code> 报文给服务端，服务端接收后会将其加入到 [SYN队列]中；</li><li>服务端接着发送 <code>SYN+ACK</code>给客户端，等待客户端回应 <code>ACK</code>报文；</li><li>服务端接收到客户端的 <code>ACK</code>报文后，从 [SYN队列] 中移除对应的SYN报文放入到 [Accept 队列]</li><li>应用通过调用 <code>accept()</code>socket 接口，从 [Accept队列] 取出连接。</li></ul><img src="/passageImg/TCP三握四挥.assets/1616140750-xuxePE-file_1616140748826" alt="应用程序过慢" style="zoom:67%;" /><blockquote><p> 应用程序过慢：如果应用程序过慢，会导致 [Accept队列] 被占满。</p></blockquote><img src="/passageImg/TCP三握四挥.assets/1616140750-tjCYqW-file_1616140748553" alt="受到 SYN 攻击" style="zoom:67%;" /><blockquote><p>受到攻击：如果不断受到 SYN 攻击，就会导致 [SYN队列] 被占满；</p><p>tcp_syncookies的方式可以应对SYN攻击：  <code>net.ipv4.tcp_syncookies = 1</code></p></blockquote><img src="/passageImg/TCP三握四挥.assets/1616140750-VkMrRC-file_1616140748674" alt="tcp_syncookies 应对 SYN 攻击" style="zoom:67%;" /><p>当 [SYN队列]  满的时候，新到来的SYN报文不再进入队列中，而是根据SYN报文计算出一个<code>cookie</code>值，当作 [SYN+ACK 中] 报文中的序列号返回给客户端；</p><p>当客户端返回一个 <code>ACK</code>包时，根据包头信息计算 cookie，与返回的确认号（初始序列号+1）进行比对，如果相同，则是一个正常连接，然后分配资源建立连接。</p><h2 id="TCP-连接断开"><a href="#TCP-连接断开" class="headerlink" title="TCP 连接断开"></a>TCP 连接断开</h2><h3 id="★-1-TCP四次握手的过程和状态变迁"><a href="#★-1-TCP四次握手的过程和状态变迁" class="headerlink" title="★ 1. TCP四次握手的过程和状态变迁"></a>★ 1. TCP四次握手的过程和状态变迁</h3><p><img src="/passageImg/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5.assets/1616140750-SdLXai-file_1616140748891" alt="客户端主动关闭连接 —— TCP 四次挥手"></p><ul><li><p>第一次挥手：客户端主动请求关闭连接，会发送一个 FIN标志位为1的报文给服务端；之后客户端就会进入到<code>FIN_WAIT_1</code>状态；</p></li><li><p>第二次挥手：服务端接收到报文后，先向客户端响应一个 ACK应答报文，接着进入到 <code>CLOSED_WAIT</code>状态；</p><p>客户端在接收到此 ACK应答报文后，会进入到 <code>FIN_WAIT_2</code>状态；</p><p>但是此时可能服务器还有数据未完全发送，接着服务端就会不断地发送数据给客户端，客户端中途就不会给予回应。</p></li><li><p>第三次挥手：等到服务端将所有数据发送完毕，服务端会发送一个关闭请求报文<code>FIN</code> 给客户端，之后服务器就会进入到<code>LAST_ACK</code>状态；</p></li><li><p>第四次挥手：客户端接收到服务端 FIN 报文，回应一个 ACK报文，然后进入 <code>TIME_WAIT</code>状态。</p><p>但是客户端的应答报文服务端是否真的收到了呢？如果此次应答发送失败，那么客户端肯定不能结束。</p><p>同时对于服务端来说，它发送给客户端的结束请求在规定时间内(重传计时器)没有收到回复也会重新发送请求。</p><p>那么A就设置了一个等待计时器(等待时间 2MSL，比对方的超时计时器还要长)，如果在计时器结束之前没有收到第三次握手的重复数据包，说明B成功接收了此次回复，那么整个过程就结束了。</p></li></ul><h3 id="★-2-为什么需要四次挥手？"><a href="#★-2-为什么需要四次挥手？" class="headerlink" title="★ 2. 为什么需要四次挥手？"></a>★ 2. 为什么需要四次挥手？</h3><ul><li><p>关闭连接时，客户端向服务端发送  FIN 时，仅仅表示客户端不再发送数据了但是还能够接收数据。</p></li><li><p>服务端接收到客户端的  FIN 报文时，先回应一个 ACK应答报文，但是此时服务端可能还有数据未传送完毕，因此需要等待服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</p><p>因此服务端的 ACK报文和 FIN报文会分开发送，就比三次握手多了一次。</p></li></ul><h3 id="3-为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#3-为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="3. 为什么 TIME_WAIT 等待的时间是 2MSL？"></a>3. 为什么 TIME_WAIT 等待的时间是 2MSL？</h3><p><strong>MSL：</strong>Maximum Segment Lifetime，报文的最大生存时间。它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP报文是基于 IP协议的，而IP首部中有一个<code>TTL</code>字段，是IP数据报可以经过的最大路由数，每经过一个处理它的路由器该值就减1，当此值减少为0时数据报就会被丢弃。</p><p><strong>MSL和TTL的区别：</strong>MSL的单位是时间，而TTL是经过路由的跳数。所以 MSL应该要<strong>大于等于 TTL消耗为0的时间</strong>。</p><p><strong>为什么等于2倍的MSL？</strong></p><p>因为发送方在发送数据包给接收方后，需要等待接收方返回一个响应，这样一来一回就刚好是2MSL。</p><p>从客户端最后一次发送给服务端ACK应答报文开始计时，该报文最长会经过MSL到达到达服务端，如果超过这个时间服务端没有接收到，服务端就会重新发送FIN报文给客户端，这个FIN报文也会最长经过MSL到达客户端。总共加起来就是2MSL，因此在2MSL时间内能够确保服务端在未接收到应答的情况下重新发送一个FIN报文并且到达客户端。</p><p><strong>MSL的默认值：</strong> Linux系统默认 <code>MSL=30s</code>，<code>TIME_WAIT</code>&#x3D;60s，可以通过修改<code>TCP_TIMEWAIT_LEN</code>来修改 <code>TIME_WAIT</code>的时间长度，并且需要重新编译 Linux 内核。</p><h3 id="4-为什么需要-TIME-WAIT-状态？"><a href="#4-为什么需要-TIME-WAIT-状态？" class="headerlink" title="4. 为什么需要 TIME_WAIT 状态？"></a>4. 为什么需要 TIME_WAIT 状态？</h3><p>有两个原因： ① 为了防止旧数据包被收到； ② 为了保证服务端能够正常关闭。</p><p><strong>①防止旧数据包被收到：</strong></p><p><img src="/passageImg/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5.assets/1616140750-DgoGku-file_1616140748887" alt="接收到历史数据的异常"></p><p>假设没有 TIME_WAIT 字段或者时间很短，此时在关闭连接前服务端发送了一个报文，但是由于网络阻塞的问题，客户端还没来得及接收整个连接就关闭了。</p><p>当具有相同端口的TCP连接被重用后，延迟的报文到达了客户端，客户端是有可能接收到这个过期的报文的，这就可能造成数据错乱的问题。</p><p>但是如果关闭前有 2MSL的等待时间，就能够保证在这个时间内客户端和服务端的过期数据包都能够被丢弃，之后重启TCP连接时的数据包一定都是新产生的。</p><p><strong>②保证连接的正常关闭：</strong></p><p>假设<code>TIME_WAIT</code>字段过短或者没有，那么服务端在发送最后一次ACK应答报文后不管客户端是否成功接收都会直接进入到 CLOSED状态，假设服务端没能够成功接收这个应答报文，它会一直处在 LAST_ACK 状态。</p><p>下次客户端再发送连接请求时，服务端会发送 <code>RST</code>报文来终止此连接。</p><h3 id="5-TIME-WAIT-过多会有什么危害？"><a href="#5-TIME-WAIT-过多会有什么危害？" class="headerlink" title="5. TIME_WAIT 过多会有什么危害？"></a>5. TIME_WAIT 过多会有什么危害？</h3><p>总共有两个危害：①对于内存资源的占用(服务端)；②对端口资源的占用(客户端)；</p><p>首先我们知道多次TCP连接会占用客户端的多个端口，同时会占用服务端的一个监听端口。</p><p><strong>对于客户端而言：</strong></p><p>​         端口资源有限，总共就65536个(0~65535)，被占满就会导致无法创建新的连接。</p><p><strong>对于服务端而言：</strong></p><p>​         服务端虽然就开启一个监听端口，但是会把连接的处理交给内部线程去处理，所以监听端口是可以继续监听的。但是如果TIME_WAIT过多，会导致线程池也处理不了这么多一直不断的连接。结果就会导致系统资源被占满，处理不过来新的连接。</p><h3 id="6-如何优化-TIME-WAIT-有时间看-？"><a href="#6-如何优化-TIME-WAIT-有时间看-？" class="headerlink" title="6. 如何优化 TIME_WAIT(有时间看)？"></a>6. 如何优化 TIME_WAIT(有时间看)？</h3><p>这里给出优化 <code>TIME-WAIT</code> 的几个方式，都是有利有弊：</p><p>打开 <code>net.ipv4.tcp_tw_reuse</code> 和 <code>net.ipv4.tcp_timestamps</code> 选项；<br><code>net.ipv4.tcp_max_tw_buckets</code><br>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。<br>方式一：<code>net.ipv4.tcp_tw_reuse</code> 和 <code>tcp_timestamps</code></p><p>如下的 Linux 内核参数开启后，则可以复用处于 TIME_WAIT 的 socket 为新的连接所用。</p><p>有一点需要注意的是，<code>tcp_tw_reuse</code> 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</p><p>net.ipv4.tcp_tw_reuse &#x3D; 1<br>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p><p>net.ipv4.tcp_timestamps&#x3D;1（默认即为 1）<br>这个时间戳的字段是在 TCP 头部的「选项」里，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。</p><p>由于引入了时间戳，我们在前面提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。</p><p>方式二：net.ipv4.tcp_max_tw_buckets</p><p>这个值默认为 18000，当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置。</p><p>这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。</p><p>方式三：程序中使用 SO_LINGER</p><p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct linger so_linger;</span><br><span class="line">so_linger.l_onoff = 1;</span><br><span class="line">so_linger.l_linger = 0;</span><br><span class="line">setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,sizeof(so_linger));</span><br></pre></td></tr></table></figure><p>如果l_onoff为非 0， 且l_linger值为 0，那么调用close后，会立该发送一个RST标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了TIME_WAIT状态，直接关闭。</p><p>但这为跨越TIME_WAIT状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p><h3 id="7-如果已经建立了连接，但是客户端突然出现了故障怎么办？"><a href="#7-如果已经建立了连接，但是客户端突然出现了故障怎么办？" class="headerlink" title="7. 如果已经建立了连接，但是客户端突然出现了故障怎么办？"></a>7. 如果已经建立了连接，但是客户端突然出现了故障怎么办？</h3><ul><li><strong>如何解决？</strong></li></ul><p>TCP有一个<strong>保活机制</strong>，这个机制的原理如下：</p><p>​        定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP保活机制会开始作用。每隔一个时间间隔就发送一次探测报文，该探测报文所包含的数据量非常少，如果连续几个探测报文都没有得到响应，就可以认为TCP连接已经失效，系统内核会将这个错误通知给上层的应用程序。</p><ul><li><strong>如何配置？</strong></li></ul><p>在 Linux 内核中有对应的参数可以进行配置，参数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time = <span class="number">7200</span>   <span class="comment">//保活时间，默认2小时，也就是2小时没有任何连接相关的活动，就会启动保活机制</span></span><br><span class="line">net.ipv4.tcp_keepalive_intvl = <span class="number">75</span>     <span class="comment">//每次检测间隔为 75秒</span></span><br><span class="line">net.ipv4.tcp_keepalive_probes = <span class="number">9</span>    <span class="comment">//总共检测次数为 9次</span></span><br></pre></td></tr></table></figure><p>也就是说在 Linux系统中，最少需要经过 2小时11分15秒才可以发现一个死亡连接 7200+75*9。</p><ul><li><strong>开启TCP保活后存在的几种情景：</strong></li></ul><p>（1）端程序是正常工作的，那么发送探测报文后能够正常响应，此时保活时间会被重置，等待下一个TCP保活时间的到来；</p><p>（2）端程序崩溃后重启，当探测报文发送给对方，对方能够响应但是由于没有连接的有效信息，会返回一个 RST报文，很快就能发现TCP连接被重置；</p><p>（3）端程序崩溃，或端程序由于其它原因导致报文不可达。当接连几个探测报文到达对端后没有响应，TCP会报告该TCP连接已经死亡。</p><h2 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h2><h3 id="1-什么是Socket？"><a href="#1-什么是Socket？" class="headerlink" title="1. 什么是Socket？"></a>1. 什么是Socket？</h3><p><img src="/passageImg/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5.assets/20171013211115388" alt="socket在哪里"></p><p>Socket是位于传输层和应用层之间的一个软件抽象层，是对下层TCP&#x2F;IP协议的封装，可以理解为对上层应用提供的一个接口，但是它并不是一种协议。</p><p>更简单的理解为： TCP&#x2F;IP只是一个协议栈，但是就像操作系统的运行机制一样必须实现，同时还要对外提供操作接口（Socket），Socket是发动机提供网络通信的能力，HTTP看成轿车提供了封装或者显示数据的具体形式。</p><h3 id="2-Socket的原理"><a href="#2-Socket的原理" class="headerlink" title="2. Socket的原理"></a>2. Socket的原理</h3><p><img src="/passageImg/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5.assets/20190718154556909.png" alt="img"></p><h5 id="一次socket建立、数据传送、关闭的过程："><a href="#一次socket建立、数据传送、关闭的过程：" class="headerlink" title="一次socket建立、数据传送、关闭的过程："></a>一次socket建立、数据传送、关闭的过程：</h5><p>首先，TCP服务器端会初始化一个Socket，然后绑定端口bind()，对端口进行监听listen(xxx)，监听过程是阻塞的，等待客户端连接。</p><p>此时如果有个客户端初始化了一个Socket，然后连接服务器connect()，连接成功后客户端和服务端就成功建立连接。</p><p>客户端发送数据，服务器接收请求并处理最后返回数据给客户端。</p><p>关闭连接，一次交互结束。</p><h5 id="详细方法操作："><a href="#详细方法操作：" class="headerlink" title="详细方法操作："></a>详细方法操作：</h5><blockquote><p><a href="https://blog.csdn.net/pashanhu6402/article/details/96428887">https://blog.csdn.net/pashanhu6402/article/details/96428887</a></p></blockquote><h3 id="3-针对TCP如何-Socket编程？"><a href="#3-针对TCP如何-Socket编程？" class="headerlink" title="3. 针对TCP如何 Socket编程？"></a>3. 针对TCP如何 Socket编程？</h3><img src="/passageImg/TCP三握四挥.assets/1616140750-TFnPas-file_1616140748851" alt="基于 TCP 协议的客户端和服务器工作" style="zoom:67%;" /><ul><li>服务端和客户端初始化<code>socket</code>，得到文件描述符。</li><li>服务端调用<code>bind()</code>，绑定指定的ip地址和端口号。服务端需要绑定指定的地址和端口号，而客户端不需要指定，由系统自动分配一个端口号和自身的ip地址进行组合。这就是为什么服务端在listen()之前需要调用bind()，而客户端不需要，它会在connect时自动创建一个。</li><li>服务端调用<code>listen()</code>，进行监听。</li><li>服务端调用<code>accept()</code>，等待客户端连接。</li><li>客户端调用<code>connect()</code>，向服务器地址和端口发送连接请求。</li><li>服务端<code>accept()</code>返回用于数据传输的<code>socket()</code>文件描述符。</li><li>客户端通过<code>write()</code>写入数据；服务端调用<code>read()</code>读取数据。</li><li>客户端断开连接时，会调用<code>close()</code>，那么服务端<code>read()</code>就会读取到<code>EOF</code>，等待处理完数据后，服务端调用<code>close()</code>，表示关闭连接。</li></ul><p>需要注意的是：服务端调用<code>accept()</code>时，连接成功会返回一个已经完成连接的socket，后续用来客户端传输数据。</p><p>所以监听socket 和 数据传输socket 其实是两个。</p><h3 id="4-listen-时候参数-backlog的意义？"><a href="#4-listen-时候参数-backlog的意义？" class="headerlink" title="4. listen 时候参数 backlog的意义？"></a>4. listen 时候参数 backlog的意义？</h3><p>Linux内核中会维护两个队列：</p><ul><li>未完成连接的队列：（SYN队列），接收一个 SYN建立连接请求，处于 SYN_RCVD状态；</li><li>已完成连接的队列：（Accept队列），以完成3次握手过程，处于 ESTABLISHED状态；</li></ul><p><img src="/passageImg/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5.assets/1616140750-lBwkum-file_1616140748744" alt=" SYN 队列 与 Accpet 队列 "></p><p><code>int listen(int socketfd,int backlog)</code></p><ul><li>参数一 <code>socketfd</code>为文件描述符；</li><li>参数二 <code>backlog</code>为accept队列；</li></ul><h3 id="5-Accept和Connect发生在三次握手的哪一步？"><a href="#5-Accept和Connect发生在三次握手的哪一步？" class="headerlink" title="5. Accept和Connect发生在三次握手的哪一步？"></a>5. Accept和Connect发生在三次握手的哪一步？</h3><img src="/passageImg/TCP三握四挥.assets/1616140750-bZordD-file_1616140748765" alt="客户端连接服务端" style="zoom:67%;" /><ul><li>客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 client_isn，客户端进入 SYN_SENT 状态；</li><li>服务器端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 client_isn+1，表示对 SYN 包 client_isn 的确认，同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号为 server_isn，服务器端进入 SYN_RCVD 状态；</li><li>客户端协议栈收到 ACK 之后，使得应用程序从 connect 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务器端的 SYN 包进行应答，应答数据为 server_isn+1；</li><li>应答包到达服务器端后，服务器端协议栈使得 accept 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 ESTABLISHED 状态。</li></ul><p>因此 客户端的Connect函数是在第二次握手成功返回的，服务端的 accept函数是在三次握手成功之后。</p><h3 id="6-Close发生在四次挥手的哪一步？"><a href="#6-Close发生在四次挥手的哪一步？" class="headerlink" title="6. Close发生在四次挥手的哪一步？"></a>6. Close发生在四次挥手的哪一步？</h3><img src="/passageImg/TCP三握四挥.assets/1616140750-QawZxc-file_1616140748786" alt="客户端调用 close 过程" style="zoom:67%;" /><ul><li>客户端调用 close，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态；</li><li>服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，应用程序可以通过 read 调用来感知这个 FIN 包。这个 EOF 会被放在已排队等候的其他已接收的数据之后，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；</li><li>接着，当处理完数据后，自然就会读到 EOF，于是也调用 close 关闭它的套接字，这会使得客户端会发出一个 FIN 包，之后处于 LAST_ACK 状态；</li><li>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；<br>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；<br>客户端经过 2MSL 时间之后，也进入 CLOSE 状态；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello_word测试</title>
      <link href="/2021/04/29/hello-world/"/>
      <url>/2021/04/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Office(一)、基础使用</title>
      <link href="/2021/04/15/%E6%91%B8%E9%B1%BC-office2019%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
      <url>/2021/04/15/%E6%91%B8%E9%B1%BC-office2019%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="一、对文档进行保存加密处理"><a href="#一、对文档进行保存加密处理" class="headerlink" title="一、对文档进行保存加密处理"></a>一、对文档进行保存加密处理</h2><img src="摸鱼-office2019学习(一).assets/image-20210415170322699.png" alt="image-20210415170322699" style="zoom:67%;" /><p>在保存界面选择保存方式，然后输入文件打开时的密码。</p><img src="摸鱼-office2019学习(一).assets/image-20210415170501111.png" alt="image-20210415170501111" style="zoom:67%;" /><p>在保存时可以通过<strong>工具</strong> 选项选择保存选项，里面可以设置修改文件的密码。</p><img src="摸鱼-office2019学习(一).assets/image-20210415170555408.png" alt="image-20210415170555408" style="zoom:67%;" /><p>这样在打开文件的时候就会提示我输入文件阅读密码，输入后会再次提示输入文件修改密码，否则只会作为只读文件类型打开。</p><img src="摸鱼-office2019学习(一).assets/image-20210415170659506.png" alt="image-20210415170659506" style="zoom:67%;" /><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 摸鱼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap源码解读</title>
      <link href="/2021/04/06/Java%E6%BA%90%E7%A0%81_concurrentHashMap%E6%BA%90%E7%A0%81/"/>
      <url>/2021/04/06/Java%E6%BA%90%E7%A0%81_concurrentHashMap%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>由于 HashMap 在多线程情况下存在线程安全的问题，因此在多线程情况下不会去选择使用这种结构，相应的我们会有几种方案去解决：</p><ul><li>采用线程安全的 HashTable</li><li>使用 Collections.synchorizedMap(Map) 来创建线程安全的Map集合；</li><li>使用 ConcurrentHashMap</li></ul><p>但是由于效率和并发度的原因，往往会舍弃前两种选择第三种方式。</p><span id="more"></span><h2 id="1-7-中的ConcurrentHashMap"><a href="#1-7-中的ConcurrentHashMap" class="headerlink" title="1.7 中的ConcurrentHashMap"></a>1.7 中的ConcurrentHashMap</h2><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16f140880441eab3" alt="img"></p><p>JDK7 中 ConcurrentHashMap 由 <code>Segment数组</code>+<code>HashEntry结点组成</code>，和 HashMap一样，都是<strong>数组+链表</strong>的结构。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的数组大小16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容因子0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//ConcurrentHashMap中的 Segment 数组</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认并发标准16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Segment是ReentrantLock子类，因此拥有锁的操作</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;  <span class="comment">// HashEntry数组</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="type">int</span> count;                        <span class="comment">// 结点个数</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="type">int</span> threshold;                    <span class="comment">// 扩容阈值</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">float</span> loadFactor;                     <span class="comment">// 负载因子</span></span><br><span class="line"></span><br><span class="line">  Segment(<span class="type">float</span> lf, <span class="type">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            <span class="built_in">this</span>.loadFactor = lf;</span><br><span class="line">            <span class="built_in">this</span>.threshold = threshold;</span><br><span class="line">            <span class="built_in">this</span>.table = tab;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//HashEntry结点，和 HashMap中的 Entry结点一样</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span>&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;   <span class="comment">//不同的是用 volatile进行修饰，保证内存的可见性</span></span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//segment中HashEntry[]数组最小长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_SEGMENT_TABLE_CAPACITY</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于定位在segments数组中的位置，下面介绍</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> segmentMask;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> segmentShift;</span><br></pre></td></tr></table></figure><p>可以发现，ConcurrentHashMap 内部是由 Segment 数组组成，而 Segment数组又包含着一个 HashEntry 数组，其中 HashEntry 和 Entry结点类似，都是链表中的结点类型。不同的是 HashEntry 结点中的 value和 next 用 <code>volatile</code> 进行了修饰，这主要是为了保证在并发情况下内存的一致性。</p><p><strong>问：  volatile 的特性是啥？</strong></p><blockquote><ol><li>保证内存可见性；即如果有多个线程对同一个共享变量进行修改，当前变量的最新值对其它线程来说是立即可见的。</li><li>防止指令重排，比如 <code>int a = 6;</code>这条命令就不是一个原子指令，它实际由3个步骤组成，①定义变量a；②给a赋值为6；在多线程情况下可能刚好执行完步骤①后，另一个线程对a的值进行了修改，这就会出现问题；</li></ol></blockquote><h3 id="2-put-插入数据操作"><a href="#2-put-插入数据操作" class="headerlink" title="2. put 插入数据操作"></a>2. put 插入数据操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="comment">// 这里解释了为什么 ConcurrentHashMap 不允许值为空</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//根据key计算hash值，key也不能为null，否则hash(key)报空指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// 根据hash值计算在segments数组中的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若为空，先创建初始化Segment再put值，不为空，直接put值。</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        <span class="comment">//尝试去获取对应 Segment 的锁，获取失败会执行 scanAndLockForPut进行自旋获取</span></span><br><span class="line">        HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">            scanAndLockForPut(key, hash, value);</span><br><span class="line">        V oldValue;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算出在 table 中应该插入的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">            <span class="comment">//找到HashEntry[]中的指定位置的第一个节点</span></span><br><span class="line">            HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">          </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                <span class="comment">//如果不为空，遍历这条链</span></span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    K k;</span><br><span class="line">                    <span class="comment">//链中存在对应结点，用新值替换旧值</span></span><br><span class="line">                    <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                        (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                        oldValue = e.value;</span><br><span class="line">                        <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                            e.value = value;</span><br><span class="line">                            ++modCount;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    e = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 否则链表中没有对应结点，则创建新的结点进行插入</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                        node.setNext(first);</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">//该位置为空，则新建一个节点(注意这里采用链表头插入方式)</span></span><br><span class="line">                        node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                    <span class="comment">//键值对数量+1</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//如果键值对数量超过阈值</span></span><br><span class="line">                    <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                        <span class="comment">//扩容</span></span><br><span class="line">                        rehash(node);</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">//未超过阈值，直接放在指定位置</span></span><br><span class="line">                        setEntryAt(tab, index, node);</span><br><span class="line">                    ++modCount;</span><br><span class="line">                    count = c;</span><br><span class="line">                    <span class="comment">//插入成功返回null</span></span><br><span class="line">                    oldValue = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改成功，返回原值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的 put操作和 HashMap中的 put 操作是类似的，只是在put前添加了上锁和解锁两个步骤，目的是为了保证同一时刻只有一个线程拥有修改的权限。</p><p><strong>详细分析：</strong></p><ul><li>先根据 key 去计算hash值来确定应该插入在 Segment 数组的哪个位置；</li><li>尝试获取当前 Segment 对应的锁，获取成功继续插入，获取失败执行 <code>scanAndLockForPut()</code>进行自旋操作；</li><li>如果成功获取锁，那么再次通过 hash和数组长度由<code>插入位置 = hash &amp; (length-1)</code>确定在 HashEntry数组中应该插入的位置。定位到该该位置对应的链表头结点，遍历链表查找 key 值和当前key相同的结点，如果找到进行覆盖；如果没有找到，则首先判断是否需要扩容，扩容完毕后生成新结点进行插入。（注意扩容操作中使用的也是头插法）；</li><li>如果自旋获取锁达到了一定的上限仍未获得，就会改为阻塞式获取锁。</li></ul><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/1604851702c89293" alt="img"></p><p><strong>问：ConcurrentHashMap 并发度高的原因？</strong></p><p>因为 ConcurrentHashMap 使用了<strong>分段锁</strong>技术，ConcurrentHashMap  中包含的有一个 Segment数组，而Segment类是继承自 ReentrantLock 类，因此在操作每一个 Segment 时能够进行上锁和解锁控制，那么在多线程情况下，对于同一个 Segment 某一个时刻只能有一个线程进行操作，不同的 Segment 可以由不同的线程同时操作互不影响。ConcurrentHashMap 所能支持的最大并发度等于Segment 数组的大小，也就是说如果容量是16，最大并发度就是16。</p><p><strong>问：ConcurrentHashMap 的get操作是怎样的？</strong></p><p>get操作和 put类似，先根据 key计算 hash值确定到具体应该插入到 Segment数组的哪个位置；然后再根据 hash值和 HashEntry数组的大小确定到具体的插入位置。</p><p>由于 HashEntry 结点中的 value和next 都是 volatile 修饰的，因此能够保证内存的可见性，每次获取的都是最新的值。get 操作的整个步骤不需要加锁。</p><p><strong>问：ConcurrentHashMap 在 1.7中仍然存在的问题？</strong></p><p>由于实现数据结构仍然是 数组+链表，如果hash冲突比较严重那么会导致链表长度过长，在遍历链表进行对应结点查找时效率就比较低。</p><p>所以在 JDK8中采用了 数组+链表+红黑树 的数据结构，当链表长度大于等于8时存储结构会转化为红黑树，这样就增大了查询的效率。</p><h2 id="1-8中的ConcurrentHashMap"><a href="#1-8中的ConcurrentHashMap" class="headerlink" title="1.8中的ConcurrentHashMap"></a>1.8中的ConcurrentHashMap</h2><h3 id="1-数据结构-1"><a href="#1-数据结构-1" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p>JDK8 中移除了 Segement数组，引入了 红黑树的概念</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node 结点依旧相同</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 红黑树 TreeNode 结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="type">boolean</span> red;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">                 TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">          <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">          <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 最大容量 2^30</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">  <span class="comment">// 默认容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">  <span class="comment">// 默认并发度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">  <span class="comment">// 负载因子</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">  <span class="comment">// 树化阈值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">  <span class="comment">// 由红黑树转化为链表的结点个数阈值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// 树化的最小结点数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h3 id="2-put-插入数据操作-1"><a href="#2-put-插入数据操作-1" class="headerlink" title="2. put 插入数据操作"></a>2. put 插入数据操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 不允许插入键或值为空的值</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 计算hash值，通过 hash ^ (hash&gt;&gt;&gt;16)，和HashMap一样</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 用来统计链表长度，判断是否变换为红黑树</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">      Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 数组为空，进行初始化</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        tab = initTable();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 数组中不存在对应结点，生成新结点尝试使用CAS进行插入</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// CAS插入，插入失败会一直进行自旋插入</span></span><br><span class="line">        <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                     <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">          <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 判断是否需要进行扩容</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">        tab = helpTransfer(tab, f);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 否则出现 hash冲突，根据当前的数据结构执行不同的插入方法</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里是对数组单个位置进行上锁，JDK7中是对Segment进行上锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">          <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 结点是链表的情况</span></span><br><span class="line">            <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              binCount = <span class="number">1</span>;</span><br><span class="line">              <span class="comment">// 循环遍历链表</span></span><br><span class="line">              <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="comment">// 如果找到链表中对应位置的结点，进行覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key ||</span><br><span class="line">                     (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                  oldVal = e.val;</span><br><span class="line">                  <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                    e.val = value;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则在链表尾部插入新结点</span></span><br><span class="line">                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                  pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                            value, <span class="literal">null</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 结构是红黑树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">              Node&lt;K,V&gt; p;</span><br><span class="line">              binCount = <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                    value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldVal = p.val;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                  p.val = value;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否达到了树化阈值</span></span><br><span class="line">        <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">            treeifyBin(tab, i);</span><br><span class="line">          <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> oldVal;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化数组，使用 sizeCtl来控制并发安全</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// sizeCtl小于0时当前线程让出执行权</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 否则CAS操作将 sizeCtl修改为-1，然后进行数组初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap在进行 put 操作时过程如下：</p><ul><li>插入的 key或者value都不允许为空，然后根据 key计算hash值： <code>h^(h&gt;&gt;&gt;16) &amp; HASH_BITS</code>；</li><li>判断是否需要进行初始化，如果要初始化通过 <code>sizeCtl</code>来控制并发，<code>sizeCtl</code>默认为0，当 <code>sizeCtl</code>小于0时当前线程让出执行权<code>Thread.yield()</code>；否则通过CAS操作来将 <code>sizeCtl</code>修改为-1，然后进行数组初始化，初始化完毕后改为0；</li><li>根据 hash值和数组长度计算出应该插入的位置：<code>hash &amp; (length-1)</code>，如果为空表示当前位置可以插入数据，利用CAS进行写入，失败则自旋保证成功；</li><li>否则说明当前存在 hash冲突，在解决冲突前需要判断数组是否需要扩容；</li><li>扩容完毕后利用 synchorized锁 写入数据，这里锁住的是数组中那个位置对应的头结点；</li><li>根据 <code>binCount</code>判断是否需要转换为红黑树的结构。</li></ul><h3 id="3-get-查找操作"><a href="#3-get-查找操作" class="headerlink" title="3. get 查找操作"></a>3. get 查找操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// 根据key计算hash值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果能够在table数组中定位到并且不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hash值相等且key相等直接返回（链表头）</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 否则hash值小于0为红黑树的结构，按照红黑树搜索</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 否则剩下的就是链表结构，按照链表结构查找</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先会根据传入的 key 计算hash值： <code>h ^ (h&gt;&gt;&gt;16)&amp; HASH_BITS</code>；</li><li>根据hash值和数组长度计算实际的存储位置，如果该位置有值而且key相等直接返回该处的值；</li><li>否则判断hash值是否小于0，小于0即为红黑树结构，那么在红黑树中查找；</li><li>否则为链表结构，遍历链表进行查找。</li></ul><h2 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="（1）Collections-SynchronizedMap-是怎么实现线程安全的？"><a href="#（1）Collections-SynchronizedMap-是怎么实现线程安全的？" class="headerlink" title="（1）Collections.SynchronizedMap 是怎么实现线程安全的？"></a>（1）Collections.SynchronizedMap 是怎么实现线程安全的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SynchronizedMap 类，注意是 Collections 类下的一个静态内部类</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SynchronizedMap</span>&lt;K,V&gt;</span><br><span class="line">     <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1978198479659022715L</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 内部维护了一个 Map集合</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     <span class="comment">// Backing Map</span></span><br><span class="line">   </span><br><span class="line">     <span class="comment">// 内部维护了一个mutex互斥锁</span></span><br><span class="line">     <span class="keyword">final</span> Object      mutex;        <span class="comment">// Object on which to synchronize</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 构造方法一，只传入Map</span></span><br><span class="line">     SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">         <span class="built_in">this</span>.m = Objects.requireNonNull(m);</span><br><span class="line">         mutex = <span class="built_in">this</span>;   <span class="comment">//这里锁住当前对象而不是类</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 构造方法二，传入Map和互斥锁变量</span></span><br><span class="line">     SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123;</span><br><span class="line">         <span class="built_in">this</span>.m = m;</span><br><span class="line">         <span class="built_in">this</span>.mutex = mutex;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>首先 SynchronizedMap 是位于 Collections 类下面的一个静态内部类，这个类中包含着 一个Map对象、一个互斥锁参数<code>mutex</code>。</p><p>构造方法有两种，如果只传入Map对象，那么默认的互斥锁参数就是 this，也就是调用 SynchronizedMap的对象，就是Map。</p><p>创建完 SynchronizedMap 之后，剩余操作全部都在 synchronized 修饰的代码块中进行，因此对于同一个Map对象而言保证了多线程环境下的安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.size();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.isEmpty();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.containsKey(key);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.containsValue(value);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.get(key);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.remove(key);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;m.putAll(map);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;m.clear();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）HashTable-为什么效率低？"><a href="#（2）HashTable-为什么效率低？" class="headerlink" title="（2）HashTable 为什么效率低？"></a>（2）HashTable 为什么效率低？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashTable 的 get方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashTable 的containsKey方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashTable 对它内部的所有方法都加上了锁，即使是一些读取操作（仅仅读取操作在多线程情况下是不会存在线程安全问题的），因此效率会很低。</p><h3 id="（3）说一下-HashTable和HashMap的区别？"><a href="#（3）说一下-HashTable和HashMap的区别？" class="headerlink" title="（3）说一下 HashTable和HashMap的区别？"></a>（3）说一下 HashTable和HashMap的区别？</h3><ol><li><strong>键的范围不同：</strong>HashMap 允许键为空值，HashTable 和 ConcurrentHashMap 不允许键为空值。</li><li><strong>实现方式不同：</strong>HashMap 继承自 AbstractMap类，而 HashTable继承自 Dictionary类；</li><li><strong>容量机制不同：</strong>HashMap初始容量为16，HashTable初始容量为11；两者的负载因子都为0.75。HashMap扩容时是将容量扩大为原来的2倍；而HashTable是将容量扩大为原来的2倍+1.</li></ol><img src="/passageImg/Java源码解读.assets/image-20210420161225536.png" alt="image-20210420161225536" style="zoom:67%;" /><ol start="4"><li><p><strong>迭代器不同：</strong>HashMap中的迭代器Iterator是 <code>fali-fast</code>类型的；HashTable 中有两个迭代器（<code>Iterator</code>和 <code>Enumeration</code>）其中<code>Iterator</code>是<code>fail-fast</code>类型的，而<code>Enumeration</code>是<code>fail-safe</code>类型的。所以当在迭代遍历过程中如果有其它的线程修改了集合的结果（比如增加、修改、删除），会抛出 <code>ConcurrentModificationException</code> 异常。类似的机制还体现在 ArrayList中，它和 HashMap 都是通过 <code>modCount</code>这个变量的前后对比来保证多线程情况下遍历时数据的统一和安全。</p><blockquote><p>参考：<a href="https://blog.csdn.net/baidu_41267789/article/details/113103905">https://blog.csdn.net/baidu_41267789/article/details/113103905</a></p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如这个是 ArrayList 的迭代器的遍历方法</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">     checkForComodification();   <span class="comment">// 检查多线程下是否对集合进行了修改</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">     <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">     Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">     <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">     cursor = i + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如何检查</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (modCount != expectedModCount)   <span class="comment">//查看modCount和预期值是否一致</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="（4）fail-fast机制是什么？"><a href="#（4）fail-fast机制是什么？" class="headerlink" title="（4）fail-fast机制是什么？"></a>（4）fail-fast机制是什么？</h3><blockquote><p> 快速失败是 Java 集合中的一种机制，在用迭代器修改一个集合对象时，如果遍历过程中对集合的内容进行了修改（增删改），那么就会抛出 <code>ConcurrentModificationException</code>异常。</p></blockquote><p><strong>原理：</strong></p><p>​        在使用迭代器进行集合访问时会维护一个<code>modCount</code>变量，当集合发生修改时就会修改<code>modCount</code>。</p><p>​       当迭代器使用 <code>hasNext、next</code>来访问下一个元素时，会首先检查 <code>modCount</code>和预期值是否一样，不一样说明遍历时对集合进行了修改，那么会抛出 <code>ConcurrentModificationException</code>异常。</p><p><strong>注意：</strong></p><p>​        这个异常只能用于并发修改的 bug，但是不能依赖于这个异常进行并发操作编程。</p><p><strong>补充：</strong></p><p>​         在 java.util 包下的集合类都是快速失败的，不能在多线程情况下迭代时进行修改；</p><pre><code>     还有另外一个机制`fail-safe`（fail-safe），java.concurrent 包下的容器都是 `fail-safe`类型的，可以并发修改。</code></pre><h3 id="（5）HashTable-为什么不允许空键或值？"><a href="#（5）HashTable-为什么不允许空键或值？" class="headerlink" title="（5）HashTable 为什么不允许空键或值？"></a>（5）HashTable 为什么不允许空键或值？</h3><blockquote><p>参考：<a href="https://juejin.cn/post/6844904023363960839">https://juejin.cn/post/6844904023363960839</a>  </p><p>​            <a href="https://blog.csdn.net/qq_40645822/article/details/102538774">https://blog.csdn.net/qq_40645822/article/details/102538774</a></p></blockquote><p><strong>HashMap 源码分析：</strong></p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK8 的HashMap的哈希函数操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">//如果键为空，则哈希值为0，会将值存储到哈希表的第一位中</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap 中如果键为空，则直接返回0；否则通过 <code>key.hashcode() ^ (key.hashcode()&gt;&gt;&gt;16)</code>进行计算</p><p><strong>HashTable 源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//这里值如果为空直接报空指针错误</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;    </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();   </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">                entry.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addEntry(hash, key, value, index);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>hashTable 中先判断值是否为空，为空直接返回空指针异常；</p><p>如果键为空，那么在计算 <code>key.hashcode()</code>时同样会报空指针异常。</p><p>这样设计是因为  Hashtable 可以用在多线程情况下。而多线程时如果允许 value为空，那么对于一个特定的key，它可能存在于表中但是值为空，也可能不存在于表中此时返回的值也为空，这样就容易造成模糊判断。</p><p><strong>如果先进行 contains() 判断再获取行不行呢？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (map.contains(key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">KeyNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也不可以，因为假设线程t1调用contains方法并找到密钥，它假定密钥存在并准备好返回值，无论它是否为null。在调用map.get之前，另一个线程t2从地图中删除该键。现在t1恢复并返回null。但是根据代码，t1的正确答案是KeyNotFoundException，因为该键已被删除。但它仍然返回null，因此预期的行为被打破。</p><p>而 HashMap由于是在单线程环境下，在通过 <code>map.contains(key)</code>获取到密钥后不会存在其它线程去删除这个键，那么就能够保证结果的准确性。</p><h3 id="（6）CAS性能很高，但是为什么-synchronized-在JDK8-之后反而用的更多了？"><a href="#（6）CAS性能很高，但是为什么-synchronized-在JDK8-之后反而用的更多了？" class="headerlink" title="（6）CAS性能很高，但是为什么 synchronized 在JDK8 之后反而用的更多了？"></a>（6）CAS性能很高，但是为什么 synchronized 在JDK8 之后反而用的更多了？</h3><p>因为 synchronized在之前一直都是重量级锁，在JDK8 之后 synchronized 采用了锁升级的方式。</p><p>先使用偏向锁优化同一线程获取锁；如果这个过程中出现锁竞争而且竞争失败就会升级为轻量级锁，轻量级锁</p><p>只能用于解决并发度小的情况，当并发度大锁竞争比较严重时如果轻量级锁获取失败会先进行自旋操作，自旋</p><p>到一定的次数就必须升级为重量级锁了。</p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/image-20210421204000145.png" alt="image-20210421204000145"></p><p>参考文章：</p><p><a href="https://juejin.cn/post/6844903520957644808">https://juejin.cn/post/6844903520957644808</a></p><p><a href="https://juejin.cn/post/6844904023003250701">https://juejin.cn/post/6844904023003250701</a></p><p><a href="https://blog.csdn.net/u010723709/article/details/48007881">https://blog.csdn.net/u010723709/article/details/48007881</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码解读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantLock源码解读</title>
      <link href="/2021/04/03/Java%E6%BA%90%E7%A0%81_ReentrantLock_AQS/"/>
      <url>/2021/04/03/Java%E6%BA%90%E7%A0%81_ReentrantLock_AQS/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Java中的锁"><a href="#一、Java中的锁" class="headerlink" title="一、Java中的锁"></a>一、Java中的锁</h2><h3 id="1-Java当中有哪些锁？"><a href="#1-Java当中有哪些锁？" class="headerlink" title="1. Java当中有哪些锁？"></a>1. Java当中有哪些锁？</h3><p>公平锁、非公平锁、读写锁、共享锁、互斥锁、自旋锁、偏向锁、轻量级锁、重量级锁</p><span id="more"></span><h3 id="2-ReentrantLock锁与-Sync锁的区别"><a href="#2-ReentrantLock锁与-Sync锁的区别" class="headerlink" title="2. ReentrantLock锁与 Sync锁的区别"></a>2. ReentrantLock锁与 Sync锁的区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">   <span class="comment">//定义一个静态对象</span></span><br><span class="line">   <span class="keyword">static</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//定义juc下的 ReentrantLock锁对象</span></span><br><span class="line">   <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">reentrantlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lockTest</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//使用 ReentrantLock</span></span><br><span class="line">     reentrantLock.lock();</span><br><span class="line">       <span class="comment">//xxxxxxx操作。</span></span><br><span class="line">     reentrantlock.unlock();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//使用 Synchorized</span></span><br><span class="line">     synchorized(a)&#123;</span><br><span class="line">       <span class="comment">//xxxxxxx操作。</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 加锁的实现原理是通过改变内部的一个变量值为1，然后通过 CAS原理来控制线程访问对象的；</p><p>那么 Sync 底层是通过改变什么变量来实现控制线程访问的呢？</p><h3 id="3-Sync-通过改变什么来实现对象上锁的？"><a href="#3-Sync-通过改变什么来实现对象上锁的？" class="headerlink" title="3. Sync 通过改变什么来实现对象上锁的？"></a>3. Sync 通过改变什么来实现对象上锁的？</h3><blockquote><p>Sync 上锁就是改变对象的对象头</p></blockquote><p><strong>问：Java 对象是分配在堆上的，那么对象在堆上究竟会分配多大的内存呢？受到什么影响？</strong></p><p><strong>答： Java对象在内存中的布局主要包括以下三个部分：</strong></p><ul><li>Java对象的实例数据，简单来说就是对象的内部自定义成员变量，每个对象是不同的—–不固定；</li><li>Java对象头—-固定（64位虚拟机下为12个字节）；</li><li>数据对齐。      因为JVM是64位的虚拟机，它内部所存储的对象必须是8字节的整数倍，如果一个类的对象内部只有一个 boolean 类型的成员变量(1 byte)，那么JVM还需要为它分配7个字节的填充数据。</li></ul><p><strong>问：什么是对象头？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个类，生成一个对象a</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//调用 jol包下的方法进行对象布局分析</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> ClassLayout.parseInstance(a).toPrintable();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后导入 jol依赖包进行分析：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/image-20210402210714590.png" alt="image-20210402210714590"></p><p>如果将A类的 1字节flag 成员变量改为 4字节的 int 成员变量，结果如下：</p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/image-20210402210837282.png" alt="image-20210402210837282"></p><p><strong>问：对象头的组成是什么？</strong></p><p>先弄清楚一些基本概念：</p><pre><code>        * JVM：是一种规范和标准，不是具体的产品；        * hotspot、j9、taobaovm 等等都是基于 JVM规范开发出来的虚拟机产品；        * openjdk：基于C++ 编写的项目，hotspot是通过 openjdk生产的另外添加了一些商业部分，可以立即为openjdk是 hotspot的源码。</code></pre><blockquote><p>每个gc 管理的堆对象头的公共结构，包括堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。</p></blockquote><p>我们知道 对象存储在 eden区，当eden区满了之后会触发 minor gc，eden和 from 存活的对象使用 copy 复制到 to中，存活的对象年龄加1然后和 from进行交换，当对象年龄达到15(在from 和 to之间来回交换15次)，就会将对象复制到老年代中，老年代如果内存不够才会触发 full gc。</p><p><strong>这里为什么是 15次？</strong> 因为GC状态会保存在对象头，对象的年龄记录在对象头中的4位中(4 bit)，最大能够表示(0~15)。</p><p>Java对象头组成为： <code>Mark Word</code>    +   <code>Class Metadata Address</code>(或者说<code>Klass pointer</code>)</p><p>64位系统下面， <code>Mark Word</code>占64bit（8字节）；<code>Class Metadata Address</code> 占 32bit&#x2F;64bit（4字节，这里是经过指针压缩的，未压缩时可以为 64bit）；</p><p>对象头的值会随着对象状态的不同而变化，对象状态包括以下：</p><ul><li>无状态（对象刚刚 new 出来的时候）；</li><li>偏向锁；</li><li>轻量锁；</li><li>重量锁；</li><li>gc 标记；</li></ul><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/image-20210404163347147.png" alt="image-20210404163347147"></p><p><code>biased_lock</code>：是否是偏向锁，为0表示不是，1表示是。</p><p><code>lock</code>：表示锁的状态，用2位表示，总共可表示4种状态。</p><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><h2 id="一、ReentrantLock-内部组成"><a href="#一、ReentrantLock-内部组成" class="headerlink" title="一、ReentrantLock 内部组成"></a>一、ReentrantLock 内部组成</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;   <span class="comment">//一个Sync类的对象,Sync继承自AbstractQueueSynchronizer抽象类</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//静态内部抽象类 Sync</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs &#123;<span class="doctag">@link</span> Lock#lock&#125;. The main reason for subclassing</span></span><br><span class="line"><span class="comment">         * is to allow fast path for nonfair version.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>; <span class="comment">//ReentrantLock.lock()方法实际上是Sync子类的方法(分公平锁和非公平锁)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//继承于 Sync的非公平锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 非公平锁的lock()方法，直接进行CAS操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//继承于 Sync的公平锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 公平锁的 lock()方法，首先进行acquire()判断</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//注意！这个方法是AQS抽象类的</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">                selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();  <span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();   <span class="comment">//得到volatile修饰的state变量的值，默认是0</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;         <span class="comment">//如果是0，说明当前锁没有被占用</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意！这个方法也是AQS类的，用来检查当前线程是否是队列中的第一个线程</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">            <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">            <span class="comment">// thread is first in queue.</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            Node s;</span><br><span class="line">            <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">                ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment">     * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment">     * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment">     * CANCELLED.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;   <span class="comment">//队列首部</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment">     * method enq to add new wait node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;   <span class="comment">//队列尾部</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The current owner of exclusive mode synchronization.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;  <span class="comment">//持有当前锁的线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The synchronization state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;             <span class="comment">//锁状态，加锁成功+1，解锁变为0</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//队列中的结点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;     <span class="comment">//前一个Node</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;     <span class="comment">//后一个Node</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread; <span class="comment">//Thread线程对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、ReentrantLock-内部实现锁、加锁的原理"><a href="#二、ReentrantLock-内部实现锁、加锁的原理" class="headerlink" title="二、ReentrantLock 内部实现锁、加锁的原理"></a>二、ReentrantLock 内部实现锁、加锁的原理</h2><p><strong>自旋</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;     <span class="comment">//作为一个标识，来标识是否有线程在同步块，是否有线程上锁成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上锁方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!compareAndSet(<span class="number">0</span>,<span class="number">1</span>))&#123;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">  status = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CAS操作</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> except,<span class="type">int</span> newValue)</span>&#123;</span><br><span class="line">  <span class="comment">//cas操作，修改status成功则返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：耗费CPU资源，没有竞争到锁的线程会一直占用cpu资源进行cas操作，假如一个线程获得锁后要花费Ns处理业务逻辑，那么另外一个线程就会白白耗费Ns的cpu资源。</p><p>思路：让得不到锁的线程让出cpu资源。</p><p><strong>yield+自旋</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!compareAndSet(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">     yield();  <span class="comment">//通过yield() 来让出cpu资源</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">  status = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点：要解决自旋锁的问题必须让竞争锁失败的线程让出 cpu 资源，yield( ) 方法能够让出 cpu 资源。</p><p>缺点：但是自旋+yield 并没有完全解决问题，当系统只有两个线程竞争锁时是有效的；但是注意 yield( )  方法只是让出当前cpu，有可能操作系统下次还是选择该线程，那线程数量过大时 yield( ) 的效果就很差了。</p><p><strong>park+自旋  ——  AQS模拟实现</strong></p><blockquote><p>AQS主要借助的技术： park() + unpark() + state + 队列 + CAS</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Queue parkQueue;   <span class="comment">//用一个队列来存储线程集合</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!compareAndSet(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">    park();        <span class="comment">//对没有竞争到锁的线程释放cpu资源</span></span><br><span class="line">  &#125;</span><br><span class="line">  ....             <span class="comment">//得到锁的线程进行操作</span></span><br><span class="line">  unlock();        <span class="comment">//操作完后释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//解锁时将ReentrantLock内部变量status由1变回0</span></span><br><span class="line">  status = <span class="number">0</span>;</span><br><span class="line">  lock_notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">park</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//将当前线程加入到等待队列</span></span><br><span class="line">  parkQueue.add(currentThread);</span><br><span class="line">  <span class="comment">//释放当前线程的cpu，阻塞</span></span><br><span class="line">  releaseCpu();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread t)</span>&#123;</span><br><span class="line">  LockSupport.unpark(t);  <span class="comment">//unpark() 底层也是unsafe类的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">releaseCpu</span><span class="params">()</span>&#123;</span><br><span class="line">  LockSupport.park();    <span class="comment">//park()  方法底层使用unsafe类对操作系统进行操纵</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lock_notify</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//得到要唤醒的线程头部线程</span></span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> parkQueue.header();</span><br><span class="line">  <span class="comment">//唤醒等待线程</span></span><br><span class="line">  unpark(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS（AbstractQueuedSynchorizer） 类的核心部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment"> * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment"> * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment"> * CANCELLED.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;   <span class="comment">//队列首部</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment"> * method enq to add new wait node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;  <span class="comment">//队列尾部</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;           <span class="comment">//锁状态，加锁成功则为1，重入+1，释放-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The current owner of exclusive mode synchronization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;  <span class="comment">//持有当前锁的线程</span></span><br></pre></td></tr></table></figure><blockquote><p>在使用 ReentrantLock 进行上锁时会判断当前锁是公平锁还是非公平锁。</p></blockquote><p><strong>公平锁加锁代码</strong>：</p><p>​         公平锁不会立刻进行CAS原子操作，而首先会判断当前线程能否加锁；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">       acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">     selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">   <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">   <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">         compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">       setExclusiveOwnerThread(current);     <span class="comment">//给当前线程上锁</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">     <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">     setState(nextc);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//判断是否轮到当前线程上锁</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">       <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">       <span class="comment">// thread is first in queue.</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">       Node s;</span><br><span class="line">       <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">           ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/image-20210405205150568.png" alt="image-20210405205150568"></p><h3 id="加锁过程描述"><a href="#加锁过程描述" class="headerlink" title="加锁过程描述"></a>加锁过程描述</h3><blockquote><p>​    <code>ReentrantLock.lock()</code>方法实际上调用的是 <code>sync.lock()</code>方法而 <code>Sync</code>类有两个子类<code>FairSync</code>和<code>UnfailSync</code>。</p></blockquote><p><strong>如果是公平锁</strong>：  那么会调用<code>acquire(1)</code>方法，该方法通过调用<code>tryAcquire(1)</code>方法去尝试加锁。</p><p><code>tryAcquire(1)</code>方法的实现细节：</p><p>​            ① 第一步就是首先获取到 AQS 类的锁状态<code>state</code>（volatile修饰）来判断锁是不是自由状态。如果该锁是自由的，那么接着判断当前线程是否需要排队<code>hasQueuedPredecessors()方法</code>，分为存在竞争和无竞争两种情况，无竞争的情况下线程交替执行队列为空(没有使用到队列)则不需要排队；存在竞争的情况下，会判断当前线程是 AQS 线程队列中的第二个线程；如果<code>hasQueuedPredecessors()</code>方法返回了false，经过取反则表明不需要进行排队，那么就执行 <code>compareAndSetState()</code>方法执行原子操作(CAS)来修改<code>state</code>的值来进行上锁；如果修改成功，就将当前线程设置为 AQS 类中持有当前锁的线程，最后整个方法返回true，进行上锁后的操作。</p><p>​            ② 第二步如果不是自由状态则会判断是不是重入，如果不是重入则直接返回false失败，否则将计数器(state)加1；</p><p>​            重点细节：  <code>hasQueuedPredecessors()</code>方法最后取反了，只有返回false才会去加锁；</p><p> <strong>如果是非公平锁</strong>：  那么不会调用 <code>acquire(1)</code>方法进行判断，而是直接进行 CAS操作，如果CAS操作失败（即当前锁已经被线程占用）才会去调用 <code>acquire(1)</code>方法。</p><h3 id="AQS存在竞争情况下的加锁过程："><a href="#AQS存在竞争情况下的加锁过程：" class="headerlink" title="AQS存在竞争情况下的加锁过程："></a>AQS存在竞争情况下的加锁过程：</h3><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/image-20210406110645521.png" alt="image-20210406110645521"></p><p><strong>acquireQueued(addWaiter(Node.exclusive),arg))方法解析</strong></p><blockquote><p>如果代码运行到这里说明进程（假设为tc）需要进行排队，需要排队包括两种情况：</p><p>1、进程（tf）持有锁，并且没有释放，因此 tc 来加锁时需要进行排队，但是这个时候队列没有初始化。</p><p>2、tn（任意一个线程持有了锁），由于加锁 tn!&#x3D;tf(重入锁失败)，这时队列是一定初始化了的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">  <span class="comment">/**如果 tryAcquire(arg)方法返回true，说明当前锁未被占用，接着去判断是否需要排队；</span></span><br><span class="line"><span class="comment">   * 如果返回false，说明锁被占用，执行 addWaiter(xxxxx)方法去生成Node结点维护队列</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>addWaiter() 入队方法</strong></p><p>入队操作：根据当前线程实例化一个Node对象，如果队列为空(队列中结点为空，不是队列为空，队列在存在竞争时就生成了)，再次实例化一个thread为null的Node对象并将这个thread为null 的Node对象作为队列的头和尾部。接着将当前线程生成的Node结点插入到队列中(尾部插入)，并且维护调整整个队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成结点</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);  <span class="comment">//生成基于当前thread的Node对象</span></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">      node.prev = pred;</span><br><span class="line">      <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">        pred.next = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结点入队</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//注意死循环，会执行多次</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">      <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize    //尾部为空，即队列中节点个数为0</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))   <span class="comment">//生成一个值为null的Node结点作为队列的头和尾</span></span><br><span class="line">          tail = head;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;         <span class="comment">//将新生成的结点插入队列中并进行维护</span></span><br><span class="line">        node.prev = t;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">          t.next = node;</span><br><span class="line">          <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>acquireQueued() 方法解析</strong></p><p>自旋操作(仅仅是队列中的第二个结点才会执行)：入队完成后不会立刻去释放cpu资源，而是先进行自旋操作判断能不能拿到锁(因为可能之前持有锁的线程在入队操作时释放了锁)，如果能够拿到锁就设置当前线程为持有锁的那个线程进行相关操作。</p><p>如果不能拿到锁，那么后续的结点会修改前一个Node 对象的 waitStatus(标识当前线程的状态，为-1表示睡眠)的值为 -1。</p><p>为什么要后面的去修改前一个Node对象的值呢？  因为每个结点都有一个状态(waitStatus：默认是0表示无状态；-1表示在park[已近释放了cpu资源的状态])，你必须确定自己park了才能修改值为-1，如果提前修改但是之后没有park就会出问题；相应的如果先park之后就不能进行任何操作就无法修改值了。因此最好的办法就是交给下一个节点来修改。</p><p>由于这个自旋操作是一个死循环，那么会进行第二次自旋，第二次自旋仍然不能拿到锁，但此时的 waitStatus在第一次自旋时就已经被修改了值，那么就会调用 <code>LockSupport.park(this)</code>方法释放cpu资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">//注意死循环，会执行多次</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();   <span class="comment">//获取当前结点的前一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;  <span class="comment">//tryAcquire(arg)进行自旋操作，前一个为头结点(null)</span></span><br><span class="line">          setHead(node); <span class="comment">//自旋成功，拿到锁的资源后将当前结点设置为头结点    </span></span><br><span class="line">          p.next = <span class="literal">null</span>; <span class="comment">//将之前头结点断开，便于进行GC回收</span></span><br><span class="line">          failed = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">return</span> interrupted;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;   <span class="comment">//自旋失败就需要判断是否应该释放cpu资源</span></span><br><span class="line">            parkAndCheckInterrupt())</span><br><span class="line">          interrupted = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断自旋失败是否需要释放cpu资源</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;   <span class="comment">//获取到前一个结点的状态(注意是前一个！！！，默认是0)</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)      <span class="comment">//Node.SIGNAL = -1</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">               * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">               * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">               * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">               * indicate retry.</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">      &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">      pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">               * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">               * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">               * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">      compareAndSetWaitStatus(pred, ws, Node.SIGNAL);   <span class="comment">//CAS原子操作设置状态为-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放cpu资源</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AQS中的重入锁：</strong></p><p>​         <code>AQS</code>中也涉及到了重入锁的概念，当<code>state</code> 的值为1，即锁被线程占用时，会判断当前线程和持有锁的线程是否是同一线程，如果是则将<code>state</code>加上1，然后重新设置 <code>state</code>的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">  <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">  setState(nextc);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AQS中的队列：</strong></p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/image-20210406095852227.png" alt="image-20210406095852227"></p><h3 id="AQS加锁总结"><a href="#AQS加锁总结" class="headerlink" title="AQS加锁总结"></a>AQS加锁总结</h3><p>如果是第一个线程 tf，那么加锁过程和队列无关，线程直接持有锁，并且也不会初始化队列；如果接下来的操作都是线程交替执行，那么永远和AQS队列无关，都是直接线程持有锁。</p><p>只有在发生竞争时才会使用到线程队列。这个时候首先会初始化AQS队列，初始化时首先会生成一个thread为空的Node结点作为首和尾（除了第一次会虚拟一个，其他时候都是持有锁的那个线程锁封装的node）。队列当中除了持有锁的第一个线程结点外，都在 park。当锁被释放后，接下来获取锁的就是第二个结点，同样会修改它的thread为 null，然后设置为 head。为什么要设置为null？因为现在已经拿到了锁，那么就不需要再排队了，node 对于 thread的引用就没有意义了，所以队列的 head里面的 thread永远为 null。</p><h1 id="ReentrantLock和Sync对比"><a href="#ReentrantLock和Sync对比" class="headerlink" title="ReentrantLock和Sync对比"></a>ReentrantLock和Sync对比</h1><blockquote><p><a href="https://juejin.cn/post/6844903695298068487">https://juejin.cn/post/6844903695298068487</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码解读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList、LinkedList、Vector源码解读</title>
      <link href="/2021/04/02/Java%E6%BA%90%E7%A0%81_ArrayList%E3%80%81LinkedList%E3%80%81Vector/"/>
      <url>/2021/04/02/Java%E6%BA%90%E7%A0%81_ArrayList%E3%80%81LinkedList%E3%80%81Vector/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList、LinkedList、Vector-三者差异比较"><a href="#ArrayList、LinkedList、Vector-三者差异比较" class="headerlink" title="ArrayList、LinkedList、Vector 三者差异比较"></a>ArrayList、LinkedList、Vector 三者差异比较</h1><h2 id="一、ArrayList、LinkedList、Vector的区别"><a href="#一、ArrayList、LinkedList、Vector的区别" class="headerlink" title="一、ArrayList、LinkedList、Vector的区别"></a>一、ArrayList、LinkedList、Vector的区别</h2><h3 id="（1）底层结构"><a href="#（1）底层结构" class="headerlink" title="（1）底层结构"></a>（1）底层结构</h3><p>ArrayList 的底层是基于动态数组来实现的，LinkedList 的底层是基于拥有头尾指针的双向链表来实现的。</p><span id="more"></span><h3 id="（2）继承关系"><a href="#（2）继承关系" class="headerlink" title="（2）继承关系"></a>（2）继承关系</h3><p>ArrayList 继承于 AbstractList 抽象类，实现了 Serializable、Cloneable、RandomAccess接口，这里 RandomAccess接口只是为了允许随机访问而不是提高随机访问的效率；</p><p>LinkedList 继承于 AbstractList 抽象类，实现了 Seriablizable、Cloneable 接口，不支持随机访问。因为它的随机访问效率很低，它的 get() 方法是通过折半法然后指针顺序移动来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedList get() 方法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkElementIndex(index);  <span class="comment">//检查是否越界，和队列长度size比较</span></span><br><span class="line">        <span class="keyword">return</span> node(index).item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;   <span class="comment">//这里进行了折半比较</span></span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="（3）随机访问"><a href="#（3）随机访问" class="headerlink" title="（3）随机访问"></a>（3）随机访问</h3><p>对于随机访问 get() 和 set()操作，ArrayList 优于 LinkedList，因为 LinkedList 需要移动指针；</p><p>对于插入和删除，LinkedList 优于 ArrayList，因为 ArrayList 涉及到数组元素的移动和复制。</p><p>ArrayList 和 LinkedList 都不是线程安全的，它们需要进行加锁。可以使用 Collections.SynchronizedList 来构建线程安全的队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList 的 add() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,    <span class="comment">//这里将数组往后复制</span></span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList 的 remove()方法</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,   <span class="comment">//这里将数组往前复制</span></span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="（4）Vector-与-ArrayList的异同"><a href="#（4）Vector-与-ArrayList的异同" class="headerlink" title="（4）Vector 与 ArrayList的异同"></a>（4）Vector 与 ArrayList的异同</h3><p><strong>相同点：</strong></p><pre><code>1. 底层都是基于可动态变化的数组来实现的；   2. 都是实现了 Serilizable、Cloneable、RandomAccess接口，支持随机访问。</code></pre><p><strong>不同点：</strong></p><ol><li>线程安全方面： Vector是线程安全的，而 ArrayList 是线程不安全的。因此 Vector 比 ArrayList 的花费更高，访问比 ArrayList 慢。</li><li>扩容方面： Vector扩容操作是将容量扩大为原来的2倍，而ArrayList 是将容量扩大为 1.5倍。因此ArrayList 更加节约空间。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList 的 grow()方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">//这里是扩大为原来的 1.5倍</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Vector 的 grow() 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?  <span class="comment">//这里是扩大为原来的 2倍</span></span><br><span class="line">                                         capacityIncrement : oldCapacity);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="二、ArrayList-的扩容机制"><a href="#二、ArrayList-的扩容机制" class="headerlink" title="二、ArrayList 的扩容机制"></a>二、ArrayList 的扩容机制</h2><p>① <strong>确定最小扩容容量：</strong>首先取当前集合元素个数+1 作为最小扩容容量。然后判断集合元素是否为空，如果是空的话，比较最小扩容容量和默认容量(10) ，然后取最大值作为最小扩容容量；如果集合不为空则不变；</p><p>②  <strong>比较是否需要扩容：</strong>将 modCount++(用来保证迭代器遍历数组时不会有其它线程对数组进行修改)。将数组大小和最小扩容容量进行比较，如果当前数组小了就执行 grow( ) 方法进行扩容操作。</p><p>③  <strong>扩容操作：</strong>比较最小扩容容量和当前数组长度1.5倍，取较大值作为最小扩容容量；但是这个容量不是无限大的，还要接着比较最小扩容容量和ArrayList默认的最大容量(Integer.MAX_VALUE - 8)，如果大于最大容量则取 Integer.MAX_VALUE，否则取默认的最大容量(<strong>这里不会进来</strong>)。最后就是数组的复制 Arrays.copyOf(xxx)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList的 add() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// 这里进行扩容操作</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先计算最小扩容容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;  <span class="comment">//如果集合中的数为空   </span></span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);    <span class="comment">//比较默认容量(10)和传入的参数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)  <span class="comment">//容量不够</span></span><br><span class="line">            grow(minCapacity);  <span class="comment">//真正的扩容操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">//数组长度1.5倍</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)    <span class="comment">//如果超出了默认最大容量</span></span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);   <span class="comment">//hugeCapacity()方法判断</span></span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="三、Collections-sort-和-Arrays-sort-的实现原理"><a href="#三、Collections-sort-和-Arrays-sort-的实现原理" class="headerlink" title="三、Collections.sort 和 Arrays.sort 的实现原理"></a>三、Collections.sort 和 Arrays.sort 的实现原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collections.sort 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">        list.sort(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = <span class="built_in">this</span>.toArray();</span><br><span class="line">        Arrays.sort(a, (Comparator) c);    <span class="comment">//这里说明 Collections的排序实际上调用Arrays的排序</span></span><br><span class="line">        ListIterator&lt;E&gt; i = <span class="built_in">this</span>.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">            i.next();</span><br><span class="line">            i.set((E) e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Arrays.sort 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;   <span class="comment">//判断是否使用了比较器</span></span><br><span class="line">            sort(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//使用了就判断LegacyMergeSort(JDK1.6中使用) 是否开启</span></span><br><span class="line">            <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">                legacyMergeSort(a, c);</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">//使用了比较器用 TimSort(是一种归并排序)</span></span><br><span class="line">                TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有使用比较器,用优化了的 ComparableTimSort</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ComparableTimSort.sort(a, <span class="number">0</span>, a.length, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码解读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized源码解读</title>
      <link href="/2021/04/01/Java%E6%BA%90%E7%A0%81_Synchorized%E5%89%96%E6%9E%90/"/>
      <url>/2021/04/01/Java%E6%BA%90%E7%A0%81_Synchorized%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Synchorized"><a href="#Synchorized" class="headerlink" title="Synchorized"></a>Synchorized</h1><h2 id="一、Synchorized-的基本使用"><a href="#一、Synchorized-的基本使用" class="headerlink" title="一、Synchorized 的基本使用"></a>一、Synchorized 的基本使用</h2><p><strong>Synchorized的作用：</strong></p><ol><li>原子性：对同步代码块的访问是互斥执行的。</li><li>可见性：保证共享变量的修改能够及时可见，其实就是Java内存模型中的 “对同一个变量 unlock之前会将工作内存中变量的值同步到主内存中；对同一个变量的 lock 之前，则会清空工作内存中此变量的值，然后将主内存中的变量值同步到工作内存中”。</li><li>有序性：一个 unlock() 操作一定先行发生于**[happen-before]**后面对同一个锁的 lock() 操作。</li></ol><span id="more"></span><p><strong>Synchorized的用法：</strong></p><ol><li>当 Synchorized 作用在实例方法时，监视器锁**[Monitor]**是对象实例；</li><li>当 Synchorized 作用在静态方法时，监控器锁就是对象的 class实例；因为 class数据存在于方法区中，所以相当于该类的一个全局锁；</li><li>当 Synchorized 作用在某一个对象实例时，监控器锁就是括起来的对象实例。</li></ol><h2 id="二、Synchorized-锁的是代码还是对象"><a href="#二、Synchorized-锁的是代码还是对象" class="headerlink" title="二、Synchorized 锁的是代码还是对象"></a>二、Synchorized 锁的是代码还是对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line">        sync.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在方法上加Synchorized修饰符修饰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sync</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test开始.....&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;test结束.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/passageImg/Java源码解读.assets/image-20210406164925058.png" alt="image-20210406164925058" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改Sync类，在方法内部加上 Synchorized进行修饰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sync</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;test开始.....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;test结束.....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/passageImg/Java源码解读.assets/image-20210406165306515.png" alt="image-20210406165306515" style="zoom:67%;" /><p><strong>分析：</strong>为什么改成了内部 Synchorized之后依然不起作用呢？</p><p><strong>关键：Synchorized锁住的是括号中的对象，而不是代码。对于非 static的 Synchorized方法，锁住的就是对象本身也就是 this</strong></p><p>代码中每个线程中都new了一个Sync类的对象，也就是产生了三个Sync对象，由于不是同一个对象，所以可以多线程同时运行synchronized方法或代码段。</p><p><strong>优化：</strong>我们在用synchronized关键字的时候，能缩小代码段的范围就尽量缩小，能在代码段上加同步就不要再整个方法上加同步。这叫减小锁的粒度，使代码更大程度的并发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改 synchorized(xxx) ，改为锁住 Sync的class对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sync</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Sync.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;test开始.....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;test结束.....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/passageImg/Java源码解读.assets/image-20210406170400289.png" alt="image-20210406170400289" style="zoom:67%;" /><img src="/Synchorized%E5%89%96%E6%9E%90.assets/image-20210406171031492.png" alt="image-20210406171031492"></p><p><strong>分析：</strong>java中的同一个类的class对象有几个，取决于加载该class的类装载器，理论上同一个类被不同的类装载器装载所产生class对象不同。但是一般都会采用统一类加载器加载，因此一个工程不会出现同一个类多个 class 对象的情况。那么类的 class对象对于整个类来说就是唯一的，用类的 class 对象作为锁住的对象，相当于全局锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采用 static synchorized修饰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sync</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;test开始.....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;test结束.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/image-20210406171031492.png" alt="image-20210406171031492"></p><p><strong>分析：</strong>同理 static修饰的方法对于一个类来说只有一份，那么加上 synchorized修饰后每次就只能有一个对象能够访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思考对于 title、age、object分别而言，是否锁成功了。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sync</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;sdfsdf&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;test开始.....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;test结束.....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>我们知道，jvm的方法区存放的是被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。也就是说同一个类它的常量(字符串、数字、字符等等)永远都只有一份并且保存在方法区中，这些常量首先是存储在常量池中，等到类加载后才放入方法区的运行时常量池中。</p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16315cc79aaac173" alt="Synchronized的使用场景"></p><h2 id="三、Synchorized的实现原理"><a href="#三、Synchorized的实现原理" class="headerlink" title="三、Synchorized的实现原理"></a>三、Synchorized的实现原理</h2><h3 id="2-1-对象锁-monitor-机制"><a href="#2-1-对象锁-monitor-机制" class="headerlink" title="2.1 对象锁(monitor)机制"></a>2.1 对象锁(monitor)机制</h3><p><strong>同步代码块：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchorizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchorizedDemo.class)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设对于这段代码，代码中有一个全局的同步代码块，然后一个同步静态方法，这两者锁住的都是类的对象。</p><p>编译后切换到字节码文件的目录下，执行<code>javap -v SynchorizedDemo.class</code>查看字节码文件。</p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16315cce259af0d2" alt="SynchronizedDemo.class"></p><p>黄色部分就是在添加了 Synchorized关键字后特有的。在线程进入同步代码块去执行时，首先需要执行 <code>monitorenter</code>指令来，执行完退出时再执行<code>monitorexit</code>指令。</p><p>使用 Synchorized 进行同步，关键就在于对监控器 monitor 的获取，当线程获取到对象的 monitor 后才能继续往下执行，否则只有等待。对于 monitor 的获取是互斥的，某个时刻只能有一个线程获取到监控器，其它没有获取到监控器的线程会被阻塞（BLOCKED），然后进入同步队列中等待锁的释放。</p><p>上面在 Synchorized代码块中的内容执行完毕后会继续执行 静态方法 method()，但是这个方法的锁对象依旧是这个类对象，所以不需要重复去执行 <code>monitorenter</code>指令，这是由于<strong>锁的重入性</strong>，在同一锁程中线程不需要重复获取同一把锁，Synchorized 先天具有重入性。</p><p>每个对象有一个计数器，当线程获取到该对象锁后，计数器加一，当释放锁时，计数器减一。</p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16315cd5fa7cf91c" alt="对象，对象监视器，同步队列和线程状态的关系"></p><blockquote><p>Synchorized的底层语义就是通过一个 monitor 对象来完成的，其实 wait&#x2F;notify 方法也是依赖于 monitor对象，这就是为什么只有在同步代码块或者方法中才能调用 wait&#x2F;notify 方法，否则会抛出异常。</p></blockquote><p><strong>同步方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/164dacca57bf1a06" alt="反编译结果"></p><p>同步方法并没有通过指令 monitorenter、monitorexit来完成，不过相对于同步方法，它的常量池中多了 <code>ACC_SYNCHORIZED </code>标识符，<strong>JVM就是根据该标识符来实现同步方法的</strong>。</p><p>方法调用时会检查是否设置了 ACC_SYNCHORIZED 标识，如果设置了那么必须在获取到对象的 monitor监视器锁后才能执行，方法执行完后再释放 monitor 对象。</p><p><strong>总结：</strong></p><p>​     同步代码块和同步方法的实现本质上没有区别，只是方法的同步是一种隐式的实现，无需通过字节码来实现。两个指令<code>monitorenter</code>、<code>monitorexit</code>的执行是通过 JVM 调用底层操作系统的 mutex 原语来实现的，被阻塞的线程会被挂起等待重新调度，会导致 “用户态”和“内核态”之间的切换，对性能影响较大。</p><h3 id="2-2-锁获取和锁释放的内存语义"><a href="#2-2-锁获取和锁释放的内存语义" class="headerlink" title="2.2 锁获取和锁释放的内存语义"></a>2.2 锁获取和锁释放的内存语义</h3><img src="/passageImg/Java源码解读.assets/16315cef21fd3ad8" alt="线程A写共享变量" style="zoom:80%;" /><img src="/passageImg/Java源码解读.assets/16315cf41661491e" alt="线程B读共享变量" style="zoom:80%;" /><p>线程A 首先会从主内存中读取出共享变量 a 的值为0，然后拷贝到自己的本地内存中，进行加一操作后再将新值刷新到主内存，整个过程为 A加锁  —-&gt;  执行临界区代码 —–&gt;  A释放锁。</p><p>线程B 获取锁的时候会从主内存中读取共享变量 a 的值，更新到自己的内存，然后释放锁的时候同样会刷新主内存的值。</p><h2 id="四、Synchorized同步概念"><a href="#四、Synchorized同步概念" class="headerlink" title="四、Synchorized同步概念"></a>四、Synchorized同步概念</h2><p>Synchorized 的短板体现在它的<strong>互斥性</strong>，每次只能通过一个线程效率肯定低下。如果这种方式不能改变，那么就必须在其它方面进行优化，比如缩短获取锁的时间。</p><p>关键为两个知识点： CAS操作、对象头</p><h3 id="3-1-CAS操作"><a href="#3-1-CAS操作" class="headerlink" title="3.1 CAS操作"></a>3.1 CAS操作</h3><h4 id="（1）什么是CAS？"><a href="#（1）什么是CAS？" class="headerlink" title="（1）什么是CAS？"></a>（1）什么是CAS？</h4><p>使用锁时，线程是一种<strong>悲观锁</strong>，它会假设每一次执行临界区代码都会产生冲突，因此当前线程获取到锁的时候会阻塞其它线程获取锁资源；而 CAS操作（Compare And Swap）是一种<strong>乐观锁</strong>策略，它假设其它线程访问共享资源时不会出现冲突，就不会阻塞其它线程操作。</p><p>但是如果出现了冲突怎么办？此时会使用 CAS操作来比较交换鉴别线程是否出现了冲突，出现冲突就重试当前操作直到没有冲突为止。</p><h4 id="（2）CAS操作原理"><a href="#（2）CAS操作原理" class="headerlink" title="（2）CAS操作原理"></a>（2）CAS操作原理</h4><p><a href="https://blog.csdn.net/qq_43684985/article/details/114625261">https://blog.csdn.net/qq_43684985/article/details/114625261</a></p><h3 id="3-2-Java对象头"><a href="#3-2-Java对象头" class="headerlink" title="3.2 Java对象头"></a>3.2 Java对象头</h3><h4 id="对象内存布局："><a href="#对象内存布局：" class="headerlink" title="对象内存布局："></a><strong>对象内存布局：</strong></h4><p>JVM中，对象在内存的布局分为三块区域：对象头、实例数据、对齐填充。</p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/164e3637df80c2a2" alt="img"></p><ol><li>实例数据：存放类的属性数据信息，包括父类的属性信息；</li><li>对齐填充：由于虚拟机要求对象的起始地址必须是8字节的整数倍。填充数据不是必须存在，只起填充作用。</li><li>对象头：Java对象头一般占用2个机器码（32位虚拟机中，1个机器码4个字节；64位虚拟机中，1个机器码8个字节）；但如果是数组类型，会占用3个机器码，因为JVM可以通过Java对象的元数据信息来确定Java对象的大小，但是无法通过元数据来确定数组的大小，所以需要一块来记录数组长度。</li></ol><h4 id="对象头："><a href="#对象头：" class="headerlink" title="对象头："></a><strong>对象头：</strong></h4><blockquote><p>Synchorized锁改变的就是对象头里面的信息。 </p><p>Hotspot 虚拟机的对象头主要包括两部分： Mark Word(标记字段)、Class Pointer(类型指针)</p><p>Class Pointer就是指向它的类的元数据的指针，JVM通过这个字段来确定一个对象的类型。</p><p>Mark Word 用于存储对象自身运行时的数据，它是偏向锁和轻量级锁的实现关键。</p></blockquote><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/164dacca57744160" alt="Java对象头结构组成"></p><h4 id="Mark-Word："><a href="#Mark-Word：" class="headerlink" title="Mark Word："></a><strong>Mark Word：</strong></h4><blockquote><p>Mark Word 存储对象运行时的数据，比如 哈希码(HashCode)、GC分代年龄、锁的状态标志、线程持有的锁、偏向线程ID、偏向时间戳</p></blockquote><p>32位  无锁时 Mark Word的结构：</p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16315cff10307a29" alt="Mark Word存储结构"></p><p>无锁状态时 <code>Mark Word</code>中存储了包含：对象HashCode(25位)、对象分代年龄(4位对应JVM垃圾回收时15次)、锁标志位(2位，总共4种锁状态)、是否是偏向锁(1位)</p><p>锁一共是 4种状态，级别从低到高依次是：无状态锁、偏向锁、轻量级锁、重量级锁，这几个状态会随着竞争而逐渐升级，锁可以升级但是不能降级。这种锁升级而不能降级的策略是为了提高获取锁和释放锁的效率。</p><p>64位 无锁 Mark Word的结构：</p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/image-20210404163347147.png" alt="image-20210404163347147"></p><p>组成：对象HashCode(31位)、对象分代年龄(4位)、锁状态(2位)、是否是偏向锁(1位)、填充字段(26位)</p><p>注意 Mark Word的结构不是固定不变的，它会随着程序的运行变化。</p><p> 32位虚拟机下Mark Word：</p><img src="/passageImg/Java源码解读.assets/164dacca5774da87" alt="Mark Word可能存储4种数据" style="zoom: 80%;" /><p>64位虚拟机下 MarkWord：</p><img src="/passageImg/Java源码解读.assets/164dacca578a56a7" alt="64位Mark Word存储结构" style="zoom:80%;" /><blockquote><p>对象头的最后两位是锁状态，01 是初始状态表示无锁，它的对象头里面存储的是对象的哈希码；</p><p>随着锁的级别不同，Mark Word 中存储的数据会发生变化。</p><p>如果是偏向锁：存储的就是当前线程的ID；</p><p>如果是轻量级锁：存储的就是指向线程栈中的锁记录的指针；判断一个线程是否拥有锁就是将线程的锁记录地址和对象头中的指针进行比较。</p></blockquote><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/164daccb05c4f335" alt="HotSpot虚拟机对象头Mark Word"></p><h4 id="对象头中的-Mark-Word-与线程中的-Lock-Record："><a href="#对象头中的-Mark-Word-与线程中的-Lock-Record：" class="headerlink" title="对象头中的 Mark Word 与线程中的 Lock Record："></a><strong>对象头中的 Mark Word 与线程中的 Lock Record：</strong></h4><p>在线程进入同步代码块的时候，如果此同步对象没有被锁定，即它的锁标志位是01，则虚拟机首先在当前线程的栈中创建我们称之为“锁记录（Lock Record）”的空间，用于存储锁对象的Mark Word的拷贝<strong>，官方把这个拷贝称为Displaced Mark Word。</strong>整个Mark Word及其拷贝至关重要。</p><p><code>Monitor</code>对象存在于每个Java对象的对象头 Mark Word中，存储的是指针的指向。Synchorized 就是通过这种方式获取锁的，也是为什么Java对象中任意对象可以作为锁的原因。</p><p>Monitor监视器有两种工作方式：互斥与协作。  互斥体现在多线程环境下为了保证共享变量的数据一致，需要线程互斥访问；协作体现在，一个线程向缓冲区中写数据，另一个线程向缓冲区中读数据，如果发现缓冲区为空就会唤醒线程，这里读和写就是协作关系。</p><h2 id="五、Synchorized优化—-锁优化"><a href="#五、Synchorized优化—-锁优化" class="headerlink" title="五、Synchorized优化—-锁优化"></a>五、Synchorized优化—-锁优化</h2><blockquote><p>锁存在的状态包括四种：无锁、偏向锁、轻量级锁、重量级锁</p><p>锁可以从低到高升级，但是不能降级</p><p>JDK5中并没有对 Synchorized 关键字做出优化；直到 JDK6 才做了较大的调整，包括使用 JDK5引进的自旋锁，还添加了自适应的CAS操作、锁消除、锁粗化、偏向锁、轻量级锁这些优化策略。</p><p>JDK6 中默认是开启偏向锁和轻量级锁的，可以通过 -XX:-UseBiasedLocking 来禁用偏向锁。</p></blockquote><h3 id="5-1-自旋锁"><a href="#5-1-自旋锁" class="headerlink" title="5.1 自旋锁"></a>5.1 自旋锁</h3><p>线程的阻塞和唤醒需要CPU从用户态切换为内核态，频繁的切换对于CPU来说是一件负担很重的事情，会给系统带来很大的压力。同时如果对象锁只会持续很短的一段时间，那么阻塞和挂起是十分不值得的。</p><p>那么不让线程阻塞或挂起，直接让它不断检测锁是否释放不久可以了。因此引入了自旋锁，自旋锁就是当某个线程尝试获取锁时，如果锁已经被其它线程所占用，就一直循环检测锁是否被释放而不是被阻塞或者挂起。</p><p><strong>注意：</strong>自旋锁虽然能够避免操作系统层面的状态转换，但不能替代阻塞，因为自旋也会占用CPU资源。如果持有锁的线程很快就释放了锁，自旋的效果就比较好；反之效果还不如让线程挂起。</p><p>​             在JDK6 中，自旋默认次数为10次。</p><h3 id="5-2-自适应自旋锁"><a href="#5-2-自适应自旋锁" class="headerlink" title="5.2 自适应自旋锁"></a>5.2 自适应自旋锁</h3><p>为了解决自旋锁的问题，引入自适应自旋锁，此时自旋的次数不再确定而是可以根据情况转换。策略如下：</p><ul><li>线程如果自旋成功了，那么下次自旋的次数就更多。因为上次成功了，那么虚拟机就会认为下次还可能成功，就会适当增加一些自旋次数；</li><li>如果自旋失败了，就减少次数，甚至去除掉自旋的过程。</li></ul><h3 id="5-3-锁消除"><a href="#5-3-锁消除" class="headerlink" title="5.3 锁消除"></a>5.3 锁消除</h3><p>为了保证数据的完整性，在进行操作时需要对这部分进行同步控制。但是有些情况下，JVM检测到可能不存在共享数据的竞争，此时JVM会对锁进行消除。</p><h3 id="5-4-锁粗化"><a href="#5-4-锁粗化" class="headerlink" title="5.4 锁粗化"></a>5.4 锁粗化</h3><p>在使用同步锁的时候，让同步锁的范围尽可能地小是正确的，这样可以保证需要同步的操作数量尽可能地少，如果存在锁竞争，那么等待锁的线程就能够尽快拿到锁。</p><p>但是如果频繁的加锁解锁，可能会导致不必要的性能损耗，所以引入锁粗化的概念。锁粗化就是将多个加锁解锁操作融合在一起，扩展成为一个更大的锁，这样避免了性能损耗。</p><h3 id="5-5-偏向锁"><a href="#5-5-偏向锁" class="headerlink" title="5.5 偏向锁"></a>5.5 偏向锁</h3><blockquote><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。（线程交替执行）</p><p><strong>偏向锁是在单线程执行代码块时使用的机制</strong>，如果在多线程并发的环境下线程A尚未执行完代码而线程B请求竞争，则一定会转化为轻量级锁或者重量级锁。</p></blockquote><h4 id="（1）引入偏向锁的目的"><a href="#（1）引入偏向锁的目的" class="headerlink" title="（1）引入偏向锁的目的"></a>（1）引入偏向锁的目的</h4><p><strong>为了在没有多线程竞争的情况下减少不必要的轻量级锁执行</strong>。因为轻量级锁的加锁和解锁操作是需要多次依赖于 CAS原子指令的，而偏向锁只有在替换 线程ID 时才会使用一次CAS原子操作。</p><p>由于一旦发生竞争偏向锁就必须升级为轻量级锁，所以偏向锁的撤销操作的性能消耗也远小于CAS原子操作的性能消耗。</p><p><strong>轻量级锁是为在线程交替执行同步块时提高性能，而偏向锁是在只有一个线程执行同步块时进一步提高性能。</strong></p><h4 id="（2）偏向锁的获取"><a href="#（2）偏向锁的获取" class="headerlink" title="（2）偏向锁的获取"></a>（2）偏向锁的获取</h4><p>当一个线程访问同步代码块并获取锁时，会在<strong>对象头</strong>和<strong>栈帧中的锁记录</strong>里存储锁偏向的<strong>线程ID</strong>。以后该线程在进入同步代码块时不需要进行CAS操作，只需要检测是否为偏向锁、锁标识以及线程ID即可。</p><ol><li>检测Mark Word 是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li><li>若为可偏向状态，测试线程ID是否为当前线程ID，如果是执行同步代码块；</li><li>如果测试线程ID不是当前线程ID，则通过CAS竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID；</li><li>竞争失败，证明当前存在多线程竞争的情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块。</li></ol><h4 id="（3）偏向锁的释放"><a href="#（3）偏向锁的释放" class="headerlink" title="（3）偏向锁的释放"></a>（3）偏向锁的释放</h4><p>偏向锁使用了一种<strong>等到竞争出现才释放锁</strong>的机制。只有其它线程出现竞争锁的情况，持有锁的线程才会释放锁。</p><img src="/passageImg/Java源码解读.assets/16315d0b13b37da4" alt="偏向锁撤销流程" style="zoom:80%;" /><p>偏向锁的撤销需要等到全局安全点（当前没有字节码运行）。首先会暂停拥有偏向锁的线程，判断该线程是否存活。</p><p>如果线程死亡，则将对象头中的锁标识设置为无锁，以允许其余线程竞争；</p><p>如果线程存活，则挂起当前线程，并将指向当前线程的锁记录地址的指针放入对象头 Mark Word，升级为轻量级锁(00)，然后恢复持有锁的当前线程，进入轻量级锁的竞争模式。</p><p><strong>注意：</strong>这里只是将当前线程挂起再恢复的过程并没有发生锁的转移，仍然在当前线程手中，只是穿插了“将当前线程ID变更为指向当前线程的锁记录地址的指针”这个事。</p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16315cb9175365f5" alt="偏向锁获取和撤销流程"></p><h4 id="（3）偏向锁的关闭"><a href="#（3）偏向锁的关闭" class="headerlink" title="（3）偏向锁的关闭"></a>（3）偏向锁的关闭</h4><p>默认启用，启动时会有延迟才激活。可以使用 JVM参数进行调整。</p><p><code>-XX:BiasedLockingStartupDelay=0</code>：关闭启动延迟</p><p><code>-XX:UseBiasedLocking=false</code>：关闭偏向锁，程序默认进入轻量级锁。</p><h3 id="5-4-轻量级锁"><a href="#5-4-轻量级锁" class="headerlink" title="5.4 轻量级锁"></a>5.4 轻量级锁</h3><h4 id="（1）引入轻量级锁的目的"><a href="#（1）引入轻量级锁的目的" class="headerlink" title="（1）引入轻量级锁的目的"></a>（1）引入轻量级锁的目的</h4><p>引入轻量级锁的目的主要是为了在<strong>减少无实际竞争情况下，使用重量级锁的性能消耗</strong>，减少传统的重量级锁使用操作系统互斥变量产生的性能消耗。 </p><p>当释放偏向锁或者多个线程竞争偏向锁时就会升级为轻量级锁。</p><p>如果锁的竞争比较激烈，必然会导致锁膨胀升级为重量级锁。</p><h4 id="（2）轻量级锁的获取"><a href="#（2）轻量级锁的获取" class="headerlink" title="（2）轻量级锁的获取"></a>（2）轻量级锁的获取</h4><ol><li>在线程进入同步代码块之前，如果同步对象锁状态为无锁（偏向锁标识为0，锁状态标识为01），那么虚拟机首先会在当前线程的栈帧中建立一个名为<strong>锁记录(Lock Record)的内存空间</strong>，用来存储对象的 Mark Word拷贝。官方称之为 <code>Displaced Mark Word</code>。</li></ol><img src="/passageImg/Java源码解读.assets/164daccb3b8673a5" alt="轻量级锁CAS操作之前线程堆栈与对象的状态" style="zoom: 67%;" /><ol start="2"><li><p>拷贝 Mark Word 到锁记录中；</p></li><li><p>拷贝成功后，虚拟机将使用CAS操作将 Mark Word字段中的  Lock Word更新为指向当前线程Lock Record(锁记录)的指针；并且将锁记录里面的 owner指针指向对象Mark Word字段。</p></li><li><p>如果这个更新操作执行成功了，那么当前线程就拥有了对象锁，并将 Mark Word的锁状态字段更新为 “00”表示轻量级锁。</p><img src="/passageImg/Java源码解读.assets/164daccb3fc92904" alt="轻量级锁CAS操作之后线程堆栈与对象的状态" style="zoom: 50%;" /></li><li><p>如果这个操作失败了，虚拟机首先会检查对象 Mark Word中的 Lock Word是否指向当前线程的栈。如果是则说明当前线程已经获取了该锁，那就直接进入到同步代码块中去执行；</p><p>如果不是，则说明多个线程竞争锁，<strong>进入自旋操作</strong>防止线程被挂起。若自旋结束时仍然未获得锁，轻量级锁就会膨胀为重量级锁，锁标志的状态直接变为 “10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，当前线程和后面等待锁的线程进入阻塞状态。</p></li></ol><h4 id="（3）轻量级锁的释放"><a href="#（3）轻量级锁的释放" class="headerlink" title="（3）轻量级锁的释放"></a>（3）轻量级锁的释放</h4><p>轻量级锁的释放也是通过 CAS 操作来完成的。</p><ol><li>通过CAS操作用线程栈帧中锁记录里面的 <code>Displaced Mark Word</code>替换对象头中的 <code>Mark Word</code>字段；</li><li>如果替换成功，整个同步操作完成，恢复到无锁状态；</li><li>如果替换失败，说明有其它线程竞争该锁，锁已经升级为重量级锁，那么就要在释放锁的同时唤醒被挂起的线程。</li></ol><img src="/passageImg/Java源码解读.assets/164daccb44e0f4af" alt="轻量级锁的获取和释放过程" style="zoom: 80%;" /><h4 id="（4）为什么在升级为轻量级锁的时候要将对象头Mark-Word字段拷贝到线程栈中？"><a href="#（4）为什么在升级为轻量级锁的时候要将对象头Mark-Word字段拷贝到线程栈中？" class="headerlink" title="（4）为什么在升级为轻量级锁的时候要将对象头Mark Word字段拷贝到线程栈中？"></a>（4）为什么在升级为轻量级锁的时候要将对象头Mark Word字段拷贝到线程栈中？</h4><p>原因一：<strong>线程在申请轻量级锁的时候</strong>需要用这个作为CAS的比较条件，JVM会检查Mark Word中的 Lock Word指针是否指向当前线程锁记录的地址，如果是则说明当前线程已经获取了锁直接进入同步代码块；否则说明存在竞争进入自旋，自旋失败会导致锁膨胀为重量级锁。</p><p>原因二：<strong>升级到重量级锁的时候</strong>，通过这个字段比较持有锁的过程中该锁是否被其它线程申请过，如果被申请过，那么释放锁的时候需要唤醒其它线程。</p><h3 id="5-5-重量级锁"><a href="#5-5-重量级锁" class="headerlink" title="5.5 重量级锁"></a>5.5 重量级锁</h3><p>Synchorized 关键字是通过对象内部的监视器monitor 对象来实现上锁和解锁的。但是监视器本身是依赖于底层操作系统的<code>Mutex Lock</code>来实现的。操作系统实现线程切换会涉及到用户态与内核态之间的切换，这个成本比较高，这就是为什么  Synchorized 效率低的原因。因此这种依赖于操作系统的 Mutex Lock 所实现的锁称为重量级锁。</p><h3 id="5-6-偏向锁、轻量级锁、重量级锁之间的转换"><a href="#5-6-偏向锁、轻量级锁、重量级锁之间的转换" class="headerlink" title="5.6 偏向锁、轻量级锁、重量级锁之间的转换"></a>5.6 偏向锁、轻量级锁、重量级锁之间的转换</h3><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/164e96df78088dc7" alt="Synchronized偏向锁、轻量级锁及重量级锁转换流程"></p><h3 id="5-7-锁的优劣"><a href="#5-7-锁的优劣" class="headerlink" title="5.7 锁的优劣"></a>5.7 锁的优劣</h3><blockquote><p>各种锁不是相互替代的，锁升级过程包括 无锁 —&gt;  偏向锁 —-&gt; 轻量级锁 —-&gt; 重量级锁；</p><p>锁只能升级不能降级。</p></blockquote><ol><li>如果是单线程使用，偏向锁代价最小。它没有涉及到CAS操作，仅仅比较下对象头就可以了；</li><li>如果出现了其他线程竞争，偏向锁升级为轻量级锁；</li><li>如果其它线程通过一定次数的CAS操作未成功(自旋失败)，升级为重量级锁。</li></ol><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/164daccb8b4a0ebd" alt="锁的优劣"></p><p>参考文章：</p><p><a href="https://blog.csdn.net/xiao__gui/article/details/8188833">https://blog.csdn.net/xiao__gui/article/details/8188833</a></p><p><a href="https://juejin.cn/post/6844903600334831629">https://juejin.cn/post/6844903600334831629</a></p><p><a href="https://juejin.cn/post/6844903640197513230">https://juejin.cn/post/6844903640197513230</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码解读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper——入门</title>
      <link href="/2021/03/20/Zookeeper_%E5%85%A5%E9%97%A8/"/>
      <url>/2021/03/20/Zookeeper_%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、分布式介绍"><a href="#一、分布式介绍" class="headerlink" title="一、分布式介绍"></a>一、分布式介绍</h2><h3 id="1-1-分布式环境特点："><a href="#1-1-分布式环境特点：" class="headerlink" title="1.1 分布式环境特点："></a>1.1 分布式环境特点：</h3><p>1）分布性：异地多活；</p><p>2）并发性：程序运行过程中，并发性操作很常见；同一个分布式系统中的多个结点同时访问一个共享资源，比如数据库或者分布式存储。分布式并发是基于多进程的。</p><p>3）无序性：进程之间的消息通信会出现顺序不一致的问题。</p><span id="more"></span><h3 id="1-2-分布式环境下面临的问题："><a href="#1-2-分布式环境下面临的问题：" class="headerlink" title="1.2 分布式环境下面临的问题："></a>1.2 分布式环境下面临的问题：</h3><p>1）网络通信：网络通信异常导致分布式各结点间的消息收发过程出现问题。另外即使分布式系统各个结点之间的网络通信能够正常进行，其时延也会大于单机操作。(单机内存访问时延为纳秒数量级；分布式访问时延0.1~1ms)；</p><p>2）网络分区(脑裂)：网络发生异常，导致分布式系统中部分结点之间的网络遗憾吃不断增大，最终导致分布式架构中的所有结点只有部分能够正常运行；</p><p>3）三态：分布式下有三种状态(成功、失败、超时)；超时通常包括以下两种情况 1.由于网络原因，该请求并没有被成功地发送到接收方，而是在发送过程中就发生了消息丢失现象；2. 该请求成功地被接收方接收后，进行了处理，但是在将响应反馈给发送方的过程中，发生了消息丢失现象。当出现这样的超时现象时，网络通信的发起方是无法确定当前请求是否被成功处理的；</p><p>4）节点故障：常见问题，分布式中节点出现宕机现象。</p><h3 id="1-3-分布式的一致性："><a href="#1-3-分布式的一致性：" class="headerlink" title="1.3 分布式的一致性："></a>1.3 分布式的一致性：</h3><ol><li>强一致性</li></ol><p>这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大。</p><ol start="2"><li>弱一致性</li></ol><p>这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不久承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态。</p><ol start="3"><li>最终一致性</li></ol><p>最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型。</p><h3 id="1-4-分布式事务"><a href="#1-4-分布式事务" class="headerlink" title="1.4 分布式事务"></a>1.4 分布式事务</h3><p>一个分布式事务可以看做是多个分布式的操作序列组成的。分布式事务也可以被定义为一种嵌套型的事物，同时也就具有了 ACID事物特性。但由于在分布式事务中，各个子事务的执行是分布式的，因此要实现一种能够保证ACID特性的分布式事务处理系统就显得格外复杂。在此期间出现了诸如CAP和BASE这样的分布式系统理论。</p><h3 id="1-5-CAP理论"><a href="#1-5-CAP理论" class="headerlink" title="1.5 CAP理论"></a>1.5 CAP理论</h3><blockquote><p>一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中两项。</p></blockquote><ol><li>一致性：在分布式环境下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态；</li><li>可用性：可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在<strong>有限的时间内返回结果</strong>。这里的重点是”有限时间内”和”返回结果”。</li><li>分区容错性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</li></ol><p><img src="/passageImg/Zookeeper.assets/image-20210319165537355.png"></p><h3 id="1-6-BASE理论"><a href="#1-6-BASE理论" class="headerlink" title="1.6 BASE理论"></a>1.6 BASE理论</h3><blockquote><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结。</p></blockquote><ol><li>基本可用：分布式系统在出现不可预知故障的时候，允许损失部分可用性。但这不等价于系统不可用。</li><li>软状态：允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性。即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</li><li>最终一致性：最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。</li></ol><p>总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。</p><h2 id="二、zookeeper介绍"><a href="#二、zookeeper介绍" class="headerlink" title="二、zookeeper介绍"></a>二、zookeeper介绍</h2><ol><li>概念<img src="/passageImg/Zookeeper.assets/image-20210319170626026.png" alt="image-20210319170626026" style="zoom: 80%;" /></li></ol><blockquote><p>zookeeper 是分布式数据一致性的解决方案</p></blockquote><ol start="2"><li>zookeeper 用来做什么？</li></ol><ul><li>数据的发布&#x2F;订阅（配置中心：disconf，watcher机制）；</li><li>负载均衡（dubbo利用zookeeper机制实现负载均衡）；</li><li>命名服务；</li><li>master选举（kafka，hadoop，hbase）；</li><li>分布式队列；分布式锁；</li></ul><ol start="3"><li>zookeeper 的特性</li></ol><ul><li>顺序一致性：从同一个客户端发送的事务请求，最终都会严格按照顺序被应用到 zookeeper中；</li><li>原子性：所有事务请求的处理结果在整个集群中的所有机器的应用情况是一致的。要么所有机器都成功应用某个事务，要么都不用；</li><li>可靠性：一旦服务器成功应用了某一个事务数据，并且对客户端做出了响应，那么这个数据在整个集群中一定是同步并且保存下来。</li><li>实时性：一单一个事务被成功应用，客户端能够立即从服务器读取到事务变更后的最新数据状态。</li></ul><h2 id="三、zookeeper-安装"><a href="#三、zookeeper-安装" class="headerlink" title="三、zookeeper 安装"></a>三、zookeeper 安装</h2><p>官网下载安装</p><img src="/passageImg/Zookeeper.assets/image-20210319173132506.png" alt="image-20210319173132506"  /><h3 id="3-1-服务启动及关闭"><a href="#3-1-服务启动及关闭" class="headerlink" title="3.1 服务启动及关闭"></a>3.1 服务启动及关闭</h3><p>（1）先到 <code>conf</code> 目录下面拷贝一份 配置文件 zoo.cfg</p><p>​     <code>cp zoo_sample.cfg  zoo.cfg</code></p><p>（2）启动 zookeeper：   <code>sh zkServer.sh  start</code></p><p>​          关闭 zookeeper：  <code>sh zkServer.sh stop</code></p><p>​          重启 zookeeper： <code>sh zkServer.sh restart</code></p><p>​          查看运行状态： <code>sh zkServer.sh status</code></p><p>（3）启动客户端： <code>sh zkCli.sh -server localhost:2182</code></p><p>​           注意开端口  2182</p><h3 id="3-2-配置文件-zoo-cfg"><a href="#3-2-配置文件-zoo-cfg" class="headerlink" title="3.2 配置文件 zoo.cfg"></a>3.2 配置文件 zoo.cfg</h3><p><img src="/passageImg/Zookeeper.assets/image-20210319175145675.png"></p><p><code>tickTime</code>： zookeeper 最小时间单位长度；</p><p><code>initLimit</code>：10*tickTime  follower节点启动之后与leader节点同步数据的时间；</p><p><code>syncLimit</code>：follower与 leader节点进行心跳检测最大延迟时间；</p><p><code>dataDir</code>：存储快照文件的目录；</p><p><code>dataLogDir</code>：事务日志的存储位置；默认在<code>dataDir</code>下；</p><p><code>clientPort</code>：客户端和服务器建立连接的端口号（默认2182）；</p><h3 id="3-3-zookeeper-数据模型"><a href="#3-3-zookeeper-数据模型" class="headerlink" title="3.3 zookeeper 数据模型"></a>3.3 zookeeper 数据模型</h3><blockquote><p>数据模型 zookeeper的数据模型和文件系统类似，每一个节点称为：znode 是zookeeper中的最小数据单元，每个znode上都可以保存数据和挂载子节点，从而构成一个层次化的属性结构。</p></blockquote><p><img src="/passageImg/Zookeeper.assets/1670afe94f724fab"></p><p>zookeeper 中节点可以分为以下几类：</p><ul><li>持久化节点：节点建立后会一直存在 zookeeper 服务器上，直到主动删除；</li><li>持久化有序节点：每个节点会为它的一级子节点维护一个顺序；</li><li>临时节点：临时节点的生命周期与客户端会话保持一致，会话失效，节点删除；</li><li>临时有序节点：同上；</li><li>注意只有持久化节点才有子节点</li></ul><p>会话状态分类：</p><ul><li>NOT CONNECTED  未连接</li><li>CONNECTING  连接中</li><li>CONNECTED  已连接</li><li>CLOSED 关闭</li></ul><p>watcher：</p><p>zookeeper 提供了分布式的数据订阅，它允许客户端向服务器注册一个 watcher 监听，当服务器的节点触发指定事件时会触发 watcher，服务端回向客户端发送一个通知(watcher)。但是该通知是一次性的，一旦触发一次后就会失效。</p><p>acl：</p><p>zookeeper提供了控制节点访问权限的功能，用于有效保证zookeeper中数据的安全性，避免误操作而导致系统出现重大事故。</p><h3 id="3-4-zookeeper-命令"><a href="#3-4-zookeeper-命令" class="headerlink" title="3.4 zookeeper 命令"></a>3.4 zookeeper 命令</h3><ol><li>查看 zookeeper的命令</li></ol><p><img src="/passageImg/Zookeeper.assets/image-20210319194015904.png"></p><p>1） <code>create [-s] [-e] path data [acl]</code>：创建节点</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-s ： 代表是否有序</span><br><span class="line">-e ： 代表是否是临时节点，默认是持久化节点</span><br><span class="line">paht ： 代表路径</span><br><span class="line">data ： 代表数据</span><br><span class="line">acl  ： 代表访问权限</span><br></pre></td></tr></table></figure><p><img src="/passageImg/Zookeeper.assets/image-20210319194906012.png"></p><p>2）<code>get path [watch]</code>：获取指定节点的值</p><p><img src="/passageImg/Zookeeper.assets/image-20210319194939394.png"></p><p>3）<code>set path data [version]</code>：修改节点 path对应的值</p><p>4）<code>delete path [version]</code>：删除指定节点</p><p>这里的 version代表使用的是乐观锁，数据库中乐观锁的实现方法(版本号+CAS算法)</p><p>5）<code>stat path</code>：查看对应节点的状态信息</p><p><img src="/passageImg/Zookeeper.assets/image-20210319201115947.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cZxid：0x5          节点被创建时的事务id</span><br><span class="line">ctime：xxxxxx       节点的创建时间</span><br><span class="line">mZxid：0x7          节点被修改时的事务id</span><br><span class="line">mtime：xxxxxx       节点被修改时的时间</span><br><span class="line">pZxid：0x8          子节点最后一次修改时的事务id</span><br><span class="line">cversion：2         子节点的版本号</span><br><span class="line">dataVersion：1      数据版本号</span><br><span class="line">aclVersion:0        节点修改权限</span><br><span class="line">ephemeralOwner：0x0 创建临时节点时生成的一个 sessionid</span><br><span class="line">dataLength：3       数据长度</span><br><span class="line">numChildren：0      子节点数目</span><br></pre></td></tr></table></figure><h2 id="四、Java操作-Zookeeper"><a href="#四、Java操作-Zookeeper" class="headerlink" title="四、Java操作 Zookeeper"></a>四、Java操作 Zookeeper</h2><h3 id="4-1-测试连接"><a href="#4-1-测试连接" class="headerlink" title="4.1 测试连接"></a>4.1 测试连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testConnect</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="string">&quot;39.100.119.221:2181&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//通过使用 CountDownLatch 计时器来判断Zookeeper的连接是否连通</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ZooKeeper</span> <span class="variable">zooKeeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(address, <span class="number">5000</span>, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent watchedEvent)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(watchedEvent.getState()  == Event.KeeperState.SyncConnected)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//只有连通时countDownLatch的值才会减1，当countDownLatch中等待的线程数为0时才会执行await()后面的方法</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                    System.out.println(watchedEvent.getState());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(zooKeeper.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充： <code>CountDownLatch</code>：这个类使一个线程等待其它线程各自执行完毕后再执行，用作计数器。</p><h3 id="4-2-创建节点"><a href="#4-2-创建节点" class="headerlink" title="4.2  创建节点"></a>4.2  创建节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testCreateNode</span> <span class="keyword">implements</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="string">&quot;39.100.119.221:2181&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ZooKeeper</span> <span class="variable">zooKeeper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1. 建立连接</span></span><br><span class="line">        zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(address,<span class="number">5000</span>,<span class="keyword">new</span> <span class="title class_">testCreateNode</span>());</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(zooKeeper.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 创建节点</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;/FXP&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="string">&quot;1234&quot;</span>.getBytes();</span><br><span class="line">        List&lt;ACL&gt; aclList = ZooDefs.Ids.OPEN_ACL_UNSAFE;</span><br><span class="line">        <span class="type">CreateMode</span> <span class="variable">createMode</span> <span class="operator">=</span> CreateMode.EPHEMERAL;   <span class="comment">//创建临时节点</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> zooKeeper.create(filePath,data,aclList,createMode);</span><br><span class="line">        <span class="type">byte</span>[] res = zooKeeper.getData(filePath,<span class="literal">true</span>,stat);   <span class="comment">//添加一个 watcher</span></span><br><span class="line">        System.out.println(<span class="string">&quot;创建成功&quot;</span>+result);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取的结果信息为：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(res));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 修改数据</span></span><br><span class="line">        zooKeeper.setData(filePath,<span class="string">&quot;6789&quot;</span>.getBytes(),-<span class="number">1</span>);  <span class="comment">//-1 表示不管它的版本号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 删除节点</span></span><br><span class="line">        zooKeeper.delete(filePath,-<span class="number">1</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 创建节点和子节点（只有持久化节点才有子节点）</span></span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/luff&quot;</span>,<span class="string">&quot;666&quot;</span>.getBytes(),aclList,CreateMode.PERSISTENT);</span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/luff/child&quot;</span>,<span class="string">&quot;777&quot;</span>.getBytes(),aclList,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent watchedEvent)</span> &#123;</span><br><span class="line">        <span class="comment">//通过计数器去控制当前连接</span></span><br><span class="line">        <span class="keyword">if</span>(watchedEvent.getState() == Event.KeeperState.SyncConnected)&#123;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.println(watchedEvent.getState());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(watchedEvent.getType() == Event.EventType.NodeCreated)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;========创建了节点&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;路径：&quot;</span>+watchedEvent.getPath()+<span class="string">&quot;节点值：&quot;</span>+zooKeeper.getData(watchedEvent.getPath(),<span class="literal">true</span>,<span class="keyword">new</span> <span class="title class_">Stat</span>()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(watchedEvent.getType() == Event.EventType.NodeDataChanged)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;========更改了节点的值&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;路径：&quot;</span>+watchedEvent.getPath()+<span class="string">&quot;更改后的值：&quot;</span>+zooKeeper.getData(watchedEvent.getPath(),<span class="literal">true</span>,<span class="keyword">new</span> <span class="title class_">Stat</span>()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(watchedEvent.getType() == Event.EventType.NodeDeleted)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=======删除了节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/passageImg/Zookeeper.assets/image-20210319213309521.png"></p><h3 id="4-3-访问权限控制"><a href="#4-3-访问权限控制" class="headerlink" title="4.3 访问权限控制"></a>4.3 访问权限控制</h3><p><code>schema</code>：授权对象</p><p><code>ip</code>：授权地址</p><p><code>digest</code>：username password    (授权用户名和密码)</p><p><code>world</code>：开方式的权限控制模式，访问权限对所有的用户开放。 world:anyone</p><p><code>super</code>：超级用户 可以对zookeeper上的数据节点进行操作</p><p><img src="/passageImg/Zookeeper.assets/1670b03bf982a601"></p><h3 id="4-4-连接状态"><a href="#4-4-连接状态" class="headerlink" title="4.4 连接状态"></a>4.4 连接状态</h3><blockquote><p>连接状态包括 KeeperState、EventType</p></blockquote><p><img src="/passageImg/Zookeeper.assets/image-20210320234347033.png"></p><p><code>KeeperState</code>：连接状态</p><ul><li><code>Disconnected</code>：断开连接</li><li><code>NoSyncConnected</code>：连接失败</li><li><code>SyncConnected</code>：客户端和服务器端在某个节点上建立连接，并且完成一次ersion，<br>zxid的同步</li><li><code>AuthFailed</code>：授权失败</li></ul><p><code>EventType</code>：节点操作状态</p><ul><li><code>NodeCreated</code> 当节点被创建时触发</li><li><code>NodeDeleted</code> 节点被删除</li><li><code>NodeDataChanged</code> 节点数据发生改变</li><li><code>NodeChildrenChanged</code> 标识子节点被创建，被删除，子节点数据发生变化</li><li><code>None</code> 客户端和服务器连接状态发生变化</li></ul><p>参考文章：</p><p><a href="https://www.jianshu.com/p/ac0a8363c23d">Zookeeper学习</a></p><p><a href="https://www.jianshu.com/p/e233bb37d2e6">countDownLatch详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网（二）、网络层</title>
      <link href="/2021/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2021/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="一、网络层提供的服务"><a href="#一、网络层提供的服务" class="headerlink" title="一、网络层提供的服务"></a>一、网络层提供的服务</h2><ul><li><p>网络层只向上层提供简单灵活的、无连接的、尽最大努力交付的数据报服务。</p></li><li><p>网络层不提供端到端的可靠传输服务。</p></li><li><p>虚电路方式和数据报方式传递数据的不同：</p></li></ul><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210325191357159.png"></p><span id="more"></span><h2 id="二、网络层的协议"><a href="#二、网络层的协议" class="headerlink" title="二、网络层的协议"></a>二、网络层的协议</h2><p><img src="/passageImg/计算机网络_网络层.assets/image-20210325191602705.png" alt="image-20210325191602705" style="zoom:67%;" /><img src="/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210325192206379.png" alt="image-20210325192206379"></p><p><img src="/passageImg/计算机网络_网络层.assets/image-20210325191602705.png" alt="image-20210325191602705" style="zoom:67%;" /><img src="/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210325192206379.png" alt="image-20210325192206379"></p><blockquote><p>虚拟互联网络：</p><p>互联起来的各种网络之间的异构性本来是客观存在的，但是我们利用 IP 协议可以使这些性能各异的网络从用户看起来好像是一个统一的网络。</p></blockquote><h3 id="2-1-分类的-IP-地址"><a href="#2-1-分类的-IP-地址" class="headerlink" title="2.1 分类的 IP 地址"></a>2.1 分类的 IP 地址</h3><img src="/passageImg/计算机网络_网络层.assets/image-20210325192936944.png" alt="image-20210325192936944" style="zoom:67%;" /><ul><li>A类地址：以0开头， 1个字节的网络号3个字节的主机号；第一个可以指派的网络号为1，最后一个可以指派的网络号为126，最大可以指派的网络数为 <code>2^7-2</code>（因为网络号全0表示本网络、网络号127保留作为本地软件换回测试、本主机的进程之间通信使用），每个网络中最大的主机数为 <code>2^24-2</code>（因为主机号全0表示本主机、全1表示所有主机）。</li><li>B类地址：以10开头， 2个字节的网络号和2个字节的主机号；第一个可以指派的网络号为128.1，最后一个可以指派的网络号为191.255，最大可以指派的网络数为<code>2^14-1</code>（因为 128.0.0.0一般是不指派的），每个网络中的最大主机数为 <code>2^16-2</code>，同样要去除全0全1。B类地址空间共有 <code>2^30</code>个地址，占整个IP地址空间的 25%。</li><li>C类地址：以110开头， 1个字节的网络号和3个字节的主机号；第一个可以指派的网络号为<code>192.0.1</code>，最后一个可以指派的网络号为<code>233.255.255</code>，最大可以指派的网络数为 <code>2^21-1</code>（因为网络地址 192.0.0.0是不指派的），每个网络中的最大主机数为 <code>2^8-2</code>，整个C类地址空间共有 <code>2^29</code>个地址，占整个IP地址的 12.5%</li><li>D、E类地址都是多播地址了</li></ul><p>网络号和主机号全为1对应的网络是受限网络；主机号全部为1但是网络号不全为1称为直接广播；</p><h2 id="三、互联网的IP地址"><a href="#三、互联网的IP地址" class="headerlink" title="三、互联网的IP地址"></a>三、互联网的IP地址</h2><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210325200436112.png"></p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210325200504929.png"></p><p>网络层面上看始终都是都是源地址和目的地址的 IP 地址；</p><p>实际过程中变化的只有数据链路层上的 MAC地址；</p><h2 id="四、地址解析协议（ARP）"><a href="#四、地址解析协议（ARP）" class="headerlink" title="四、地址解析协议（ARP）"></a>四、地址解析协议（ARP）</h2><h4 id="4-1-ARP的作用（Address-Resolution-Protocol）"><a href="#4-1-ARP的作用（Address-Resolution-Protocol）" class="headerlink" title="4.1 ARP的作用（Address Resolution Protocol）"></a>4.1 ARP的作用（Address Resolution Protocol）</h4><p>为了解决同一局域网上主机或路由器的 IP 地址和硬件地址的映射关系；能够从已知的 IP 地址中解析出数据链路层使用的硬件地址。</p><p>每一个主机都设有一个 ARP高速缓存（ARP Cache），里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</p><h4 id="4-2-ARP的工作原理"><a href="#4-2-ARP的工作原理" class="headerlink" title="4.2 ARP的工作原理"></a>4.2 ARP的工作原理</h4><p>1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。<br>　　2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。<br>　　3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。<br>　　4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。广播发送ARP请求，单播发送ARP响应。</p><h4 id="4-3-使用ARP的四种典型情况"><a href="#4-3-使用ARP的四种典型情况" class="headerlink" title="4.3 使用ARP的四种典型情况"></a>4.3 使用ARP的四种典型情况</h4><ol><li>处于同一网络的两个主机；</li></ol><p>​          <img src="/passageImg/计算机网络_网络层.assets/image-20210325203146275.png" alt="image-20210325203146275" style="zoom:50%;" /></p><ol start="2"><li>处于不同网络中的两个主机想要交流信息，通过路由器进行转发。(路由器有两个硬件地址)；</li></ol><img src="/passageImg/计算机网络_网络层.assets/image-20210325203158405.png" alt="image-20210325203158405" style="zoom:50%;" /><ol start="3"><li>发送方是路由器，要把 IP 数据报转发到与该路由器连接在同一网络上的主机；</li></ol><img src="/passageImg/计算机网络_网络层.assets/image-20210325203246681.png" alt="image-20210325203246681" style="zoom:50%;" /><ol start="4"><li>发送方是路由器，要把 IP 数据报转发到另一个网络上的主机；</li></ol><img src="/passageImg/计算机网络_网络层.assets/image-20210325203221409.png" alt="image-20210325203221409" style="zoom:50%;" /><h4 id="4-4-为什么我们不直接使用硬件地址进行通信"><a href="#4-4-为什么我们不直接使用硬件地址进行通信" class="headerlink" title="4.4 为什么我们不直接使用硬件地址进行通信"></a>4.4 为什么我们不直接使用硬件地址进行通信</h4><p>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构的网络互相通信就必须进行非常复杂的硬件地址转换工作。</p><p>但是 IP 编址把这个复杂的过程解决了。连接到互联网的主机只需要各自拥有一个唯一的 IP 地址，它们之间的通信就像连接在一个网络上那样方便简单，调用 ARP 的复杂过程都是计算机软件自动进行的。</p><h4 id="4-5-IP-数据报结构"><a href="#4-5-IP-数据报结构" class="headerlink" title="4.5 IP 数据报结构"></a>4.5 IP 数据报结构</h4><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210325210008974.png"></p><ul><li>版本： 占4位，IP协议的版本，比如 IPv4、IPv6。</li><li>首部长度：占4位，可以表示的最大数值是 15个单位（一个单位 4个字节），因此 IP 的首部长度的最大值是60字节，相应的可选长度最大为 40字节；另外每次添加的可选部分只能是4个字节的整数倍，不足则进行填充。首部长度中的固定长度是20个字节。</li><li>区分服务：占8位。</li><li>总长度：占16位，当前整个 IP 数据报的长度(首部+数据)。最大长度必须不超过最大传送单元 MTU(Max Transmission Unit，最大1500个字节)。</li><li>标识：占16位，存储维持一个计数器，每产生一个数据报，计数器就加1.</li><li>标志：占3位，暂时只有后两位有意义，最低位是MF(More Fragment)，为1表示后面还有分片，否则表示当前是最后一个；中间一位是 DF(Don’t Fragment)只有值为0才可以分片。</li><li>片偏移：占13位，相对于用户数据部分的起点。代表该位置之前的数据报大小。</li><li>生存时间：占8位，数据包在网络中的寿命，每经过一次转发就会导致TTL的值减去1，当减到0时就将该数据包丢弃。</li><li>协议：占8位，指出此数据报携带的数据是何种协议，以便使目的主机的IP层知道应该将数据部分上交给哪个协议进行处理。 </li><li>首部校验和：占16位，只检验IP数据报的首部，不会检验数据部分，因为网络层的数据传输不是可靠的。</li><li>源地址：占32位，IP 数据报的源地址。</li><li>目的地址：占32位，IP 数据报的目的转发地址。</li></ul><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210325212449036.png"></p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210325212424780.png"></p><h4 id="4-6-IP-层转发分组的流程"><a href="#4-6-IP-层转发分组的流程" class="headerlink" title="4.6 IP 层转发分组的流程"></a>4.6 IP 层转发分组的流程</h4><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210325214001406.png"></p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210326195307109.png"></p><blockquote><p>路由器和主机的路由表组成：</p></blockquote><p>每一个路由器都会存储一个路由表，其中存储的有 目的网络地址和下一跳地址。</p><p>每一个主机也会存储一个路由表，其中包含三部分：①到本网络的路由，不需要进行转发，而是直接交付；②到网络N2的路由，对应下一跳路由器；③到其它网络(除开N1、N2)的下一跳路由器；</p><p>默认路由：当前路由表中的所有目的地址不包括目的网络时，路由器应该转发的方向。（没有办法转发时才采用默认路由）</p><blockquote><p>IP 数据报转发过程：</p></blockquote><p>当路由器确定了下一跳的 IP 地址时，不是直接把这个 IP 地址写入 IP数据报，而是送交数据链路层的网络接口软件，该软件通过 ARP协议将 IP地址解析为 MAC硬件地址，并且将该地址设置到 MAC帧的首部，然后根据这个硬件地址找到下一跳的路由器。</p><blockquote><p>分组转发算法：</p></blockquote><p>（1）从 IP 数据报的首部提取出 目的主机的IP地址D、目的网络地址N(目的地址的网络号)；</p><p>（2）若N就是直接与此路由器相连的某个网络地址，则进行直接交付；</p><p>（3）否则若路由表中有目的地址为D的特定主机路由或者路由表中有到达网络N的路由，则把数据报传递给路由表中所指定的下一跳路由器；</p><p>（4）否则若路由表中有默认路由，则把数据报传递给路由表中所指明的默认路由器；</p><p>（5）否则报告转发分组出错。</p><h2 id="五、划分子网和构造超网"><a href="#五、划分子网和构造超网" class="headerlink" title="五、划分子网和构造超网"></a>五、划分子网和构造超网</h2><blockquote><p>划分子网是属于一个单位内部的事情，对外而言仍然是一个网络。</p><p>子网是从主机号中借用若干位来形成子网号的。</p></blockquote><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210326201250325.png"></p><h4 id="5-1-子网掩码"><a href="#5-1-子网掩码" class="headerlink" title="5.1 子网掩码"></a>5.1 子网掩码</h4><blockquote><p>设置了子网号后，从一个 IP 数据报的首部无法判断源主机或目的主机所连接的网络是否进行了子网划分。</p><p>使用子网掩码来区分IP数据报的 网络号+子网号 和  主机号</p><p>注意子网全0 和 全1都不能用</p></blockquote><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210326201629422.png"></p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210326201704261.png"></p><p>因此， <code>（IP地址） AND （子网掩码）= 网络号</code></p><h4 id="5-2-使用子网进行分组转发"><a href="#5-2-使用子网进行分组转发" class="headerlink" title="5.2 使用子网进行分组转发"></a>5.2 使用子网进行分组转发</h4><blockquote><p>在划分子网的情况下从 IP地址不能唯一得出网络地址来，这是因为网络地址取决于那个网络所采用的子网掩码，但是数据报的首部没有提供子网掩码的信息。</p></blockquote><ul><li><p>判断两个网络地址是否一样？</p><p>掩码是否一样 +  掩码 AND 网络地址 是否一样</p></li></ul><p>使用了子网掩码后的路由表：  <code>目的网络地址+子网掩码+下一跳地址</code></p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210326203205283.png"></p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210326204215688.png"></p><h4 id="5-3-加上子网后的分组转发算法："><a href="#5-3-加上子网后的分组转发算法：" class="headerlink" title="5.3 加上子网后的分组转发算法："></a>5.3 加上子网后的分组转发算法：</h4><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210326202932782.png"></p><h2 id="六、网际控制报文协议（ICMP）"><a href="#六、网际控制报文协议（ICMP）" class="headerlink" title="六、网际控制报文协议（ICMP）"></a>六、网际控制报文协议（ICMP）</h2><blockquote><p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP（Internet Control Message Procotol）。</p><p>通常用于数据报出现异常时，用于报告异常信息。</p><p>ICMP 不是高层协议，因为 ICMP报文是装在 IP 数据报中，作为其中的数据部分进行，ICMP 不能够保证可靠传输。</p></blockquote><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210326205123778.png"></p><h4 id="6-1-ICMP-报文的种类"><a href="#6-1-ICMP-报文的种类" class="headerlink" title="6.1 ICMP 报文的种类"></a>6.1 ICMP 报文的种类</h4><h6 id="（1）ICMP-差错报文：比如路由器将数据报丢弃后向原站发送一个差错报文，通知它因为什么原因将报文丢弃，不需要回复。"><a href="#（1）ICMP-差错报文：比如路由器将数据报丢弃后向原站发送一个差错报文，通知它因为什么原因将报文丢弃，不需要回复。" class="headerlink" title="（1）ICMP 差错报文：比如路由器将数据报丢弃后向原站发送一个差错报文，通知它因为什么原因将报文丢弃，不需要回复。"></a>（1）ICMP 差错报文：比如路由器将数据报丢弃后向原站发送一个差错报文，通知它因为什么原因将报文丢弃，不需要回复。</h6><p>① 差错报文共有如下4种：</p><p>（1）终点不可达；</p><p>（2）时间超过；</p><p>（3）参数问题；</p><p>（4）改变路由 [重定向]；</p><p>② 举例：</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210326210348085.png"></p><p>A 要发送数据到 B，当它将数据发送给 R1 后，由于 R1 也不知道下一步往哪里走，误将数据发送给了R2，R2接收后解析发现它不能够到达B，因此向R1 发送差错报文(终点不可达+改变路由)。R1 接收后会改变路由再次发送数据报。</p><p>③ 差错报文的组成：</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210326213844074.png"></p><p>差错报文会把收到的需要进行差错报告的 IP数据报的首部和数据字段的前8个字节抽取出来，作为ICMP报文的数据字段。然后再加上相应的 ICMP差错报告报文的前8个字节，构成 ICMP 差错报告报文。</p><p>提取收到的数据报的数据字段的前8个字节是为了获取运输层的端口号（对于TCP和UDP），以及运输层报文的发送序号（对于TCP）。这些信息对于源点通知高层协议是有用的。</p><p>④ 不发送差错报文的几种情况：</p><ol><li>对 ICMP 差错报告报文(如果被丢弃)，不再发送差错报告报文；</li><li>对于第一个分片后的所有后续数据报片，不再发送 ICMP 差错报告报文；</li><li>对于具有多播地址的数据报，不发送 ICMP 差错报告报文；</li><li>对于具有特殊地址（127.0.0.1 或 0.0.0.0）的数据报，不再发送 ICMP 差错报告报文；</li></ol><h6 id="（2）ICMP-询问报文：比如原站和目的站的通信，来确定发送时间是否一致、发送地址是否正确等等信息，需要接受方进行回复。"><a href="#（2）ICMP-询问报文：比如原站和目的站的通信，来确定发送时间是否一致、发送地址是否正确等等信息，需要接受方进行回复。" class="headerlink" title="（2）ICMP 询问报文：比如原站和目的站的通信，来确定发送时间是否一致、发送地址是否正确等等信息，需要接受方进行回复。"></a>（2）ICMP 询问报文：比如原站和目的站的通信，来确定发送时间是否一致、发送地址是否正确等等信息，需要接受方进行回复。</h6><p> 常用的有两种：</p><ol><li>回送请求和回答：主机向目的主机发送询问。收到此报文的目的主机必须给源主机发送ICMP回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态；</li></ol><p>​         举例： 比如利用 PING 命令来测试两个主机之间的连通性； </p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210328154612124.png"></p><ol start="2"><li>时间戳请求和回答：用于时钟同步和时间测量。</li></ol><h2 id="七、互联网的路由选择协议"><a href="#七、互联网的路由选择协议" class="headerlink" title="七、互联网的路由选择协议"></a>七、互联网的路由选择协议</h2><blockquote><p>为什么采用分层次的路由选择协议？</p><pre><code>1. 互联网非常大，如果让所有的路由器都知道其它的网络如何到达此时路由表会非常大；   2. 许多单位不愿意外界了解自己单位网络的布局但是同时还希望连接到互联网上；</code></pre><p>为此，可以将整个互联网划分为许多较小的自治系统，一般记为 AS。自治系统 AS是在单一技术管理下的一组路由器。一个AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略。</p></blockquote><h4 id="7-1-自治系统-AS"><a href="#7-1-自治系统-AS" class="headerlink" title="7.1 自治系统 AS"></a>7.1 自治系统 AS</h4><ul><li>自治系统AS的定义：在单一技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该AS内的路由；同时还使用一种AS之间的路由选择协议用以确定分组在AS之间的路由。</li><li>尽管一个 AS 使用了多种内部路由选择协议和度量，但重要的是一个 AS 对其它 AS表现出的是一个单一的和和一致的路由选择协议。</li><li>自治域内通常使用 RIP、OSPF；自治域之间使用 BGP协议。</li></ul><h4 id="7-2-内部网关协议-RIP"><a href="#7-2-内部网关协议-RIP" class="headerlink" title="7.2 内部网关协议 RIP"></a>7.2 内部网关协议 RIP</h4><blockquote><p>RIP  (Routing  Information  Protocol) 是内部网关协议中使用最广泛的协议，它是一种基于距离向量的路由选择协议。</p></blockquote><p>RIP 协议要求每一个路由器都维护从它自己到其他每一个目的网络的距离记录。</p><p>距离定义为：从一路由器到它直接连接的网络的距离为1；否则每次经过一个路由器距离就加1；RIP 允许一条路径最多只能包含15个路由器，距离16表示为不可达状态。</p><p>RIP 适用于小型互联网。</p><h5 id="RIP-协议的特点："><a href="#RIP-协议的特点：" class="headerlink" title="RIP 协议的特点："></a>RIP 协议的特点：</h5><ol><li>仅和相邻的路由器交换信息；(需要通过不断交换路由信息来实时更新路由信息)</li><li>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。</li><li>按照固定时间间隔(30s)交换路由信息。</li></ol><h5 id="RIP-优缺点："><a href="#RIP-优缺点：" class="headerlink" title="RIP 优缺点："></a>RIP 优缺点：</h5><p>优点：实现简单，开销较小；</p><p>缺点：当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器；</p><p>好消息传播快，坏消息传播蛮</p><h5 id="RIP协议报文格式："><a href="#RIP协议报文格式：" class="headerlink" title="RIP协议报文格式："></a>RIP协议报文格式：</h5><p>RIP使用运输层的 用户数据报UDP进行传送(使用 UDP 端口520)</p><h5 id="距离向量算法："><a href="#距离向量算法：" class="headerlink" title="距离向量算法："></a>距离向量算法：</h5><ol><li><p>对地址为 X 的相邻路由器发送来的RIP报文，先修改此报文中的所有项目，把下一跳的地址都改为 X，并把所有距离字段都加1。 每一个项目都包含三个关键数据：到目的网络N，距离 d，下一跳路由器 X。</p></li><li><p>对RIP报文的每一个项目，执行判断。</p><ul><li>如果原路由表中没有目的网络N，则添加该项目到路由表；</li><li>否则查看下一跳路由器地址，如果和原路由表相同，则用接收到的项目替换原路由表的项目；</li><li>否则根据项目中的距离 d判断是否进行更新。</li></ul><p>这种算法的基础就是 弗洛伊德算法(Ford)，用来求单元</p></li></ol><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210328163930614.png"></p><h2 id="八、OSPF协议"><a href="#八、OSPF协议" class="headerlink" title="八、OSPF协议"></a>八、OSPF协议</h2><blockquote><p>(Open Shortest Path First) 开放最短路径优先，使用了 Dijkstra 算法</p></blockquote><p>OSPF 协议的最主要特征是使用分布式的链路状态协议，而不是像 RIP 那样的距离向量协议。</p><h5 id="OSPF和RIP协议的不同点："><a href="#OSPF和RIP协议的不同点：" class="headerlink" title="OSPF和RIP协议的不同点："></a>OSPF和RIP协议的不同点：</h5><ol><li>OSPF 协议使用洪泛法向本自治区域中的所有路由器发送信息。（路由器通过输出端口向所有相邻的路由器发送信息，相邻的路由器再向其相邻的路由器发送信息，最终整个区域中所有路由器都得到了这个信息的一个副本）。</li></ol><p>​          RIP 协议仅仅向自己相邻的几个路由器发送信息。</p><ol start="2"><li>OSPF发送的信息就是与本路由器相邻的所有路由器的链路状态（链路状态指本路由器都和哪些路由器相邻，以及该链路的度量）。</li></ol><p>​          RIP协议发送的是到所有目的网路的距离和下一跳路由器。</p><ol start="3"><li>只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。</li></ol><p>​          RIP 不管网络拓扑有无变化，路由器之间都要定期交换路由表的信息。</p><ol start="4"><li><p>OSPF协议能够通过频繁的交换信息来构建一个全网的网络拓扑图，进而使用 Dijkstra 算法计算最短路径。</p><p>RIP协议的每一个路由器虽然知道到所有的网络的距离以及下一跳路由器，但是不知道全网的拓扑结构。</p></li><li><p>OSPF的更新过程收敛地快。</p></li><li><p>OSPF不使用UDP而是直接用IP数据报进行传送。</p></li></ol><h2 id="九、BGP（外部网关协议）"><a href="#九、BGP（外部网关协议）" class="headerlink" title="九、BGP（外部网关协议）"></a>九、BGP（外部网关协议）</h2><blockquote><p>互联网规模太大，使得自治系统AS之间路由选择非常困难，因此对于自治系统AS间的路由选择使用代价作为度量来寻找最佳路由是很不现实的。</p><p>比较合理的做法是在自治系统之间交换“可达性” 信息。</p></blockquote><p>边界网关协议 BGP 只能是力求找到一条能够到达目的网络且比较好的路由，而并非找到一条最佳路由。</p><p>BGP采用路径向量协议，它与距离向量协议和链路状态协议有很大区别。</p><h2 id="十、路由器的结构"><a href="#十、路由器的结构" class="headerlink" title="十、路由器的结构"></a>十、路由器的结构</h2><blockquote><p>路由器是一个 具有多个输入端口、多个输出端口的专用计算机，它的任务是转发分组。</p></blockquote><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20210328203008848.png"></p><p><strong>整个路由器包括： 路由选择 和 分组转发</strong></p><p>（1）路由选择：</p><p>核心组件是路由选择处理机，根据所选定的路由选择协议构造出路由表，同时经常定期地和相邻路由器交换路由信息而不断地更新和维护路由表。</p><p>（2）分组转发：</p><p>核心部分包括 一组输入端口、一组输出端口、交换结构</p><p>交换结构的作用是根据转发表对分组进行处理，将某个输入端口输入的分组通过转发表选择一个合适的输出端口输出出去。</p><p><strong>注意转发和路由选择的区别</strong></p><p>（1）转发：路由器根据转发表把收到的 IP数据报从路由器合适端口转发出去；转发仅仅涉及到一个路由器；</p><p>（2）路由选择：路由选择涉及到很多路由器，路由表是许多路由器协同工作的结果。这些路由器按照复杂的路由算法，得出整个网络的拓扑变化情况，因而能够动态的改变所选择的路由。</p><p>转发表应当使得查找过程最优化，路由表需要对网络拓扑变化的计算最优化。</p><p><strong>路由器工作过程</strong></p><p>如图所示，图中的 1、2、3 分别代表物理层、数据链路层、网络层的处理模块。物理层进行比特接收，数据链路层按照链路层协议接收传送分组的帧。去掉帧的头部和尾部后，分组就被送入网络层的处理模块。</p><p>若接收到的分组是路由器之间交换信息的分组（RIP或 OSPF），则把这种分组送交路由器的路由选则处理机。若接收到的是数据分组，则按照分组首部中的目的地址查找转发表，根据得出的结果转发到合适的输出端口。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网（三）、传输层</title>
      <link href="/2021/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2021/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="一、传输层协议概述"><a href="#一、传输层协议概述" class="headerlink" title="一、传输层协议概述"></a>一、传输层协议概述</h2><p>运输层的作用： <strong>运输层提供应用进程间的逻辑通信</strong></p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><ol><li>端口的复用和分用功能：</li></ol><img src="/passageImg/计算机网络_传输层.assets/image-20210328210839296.png" alt="image-20210328210839296" style="zoom:67%;" /><span id="more"></span><ol start="2"><li>TCP&#x2F;IP 运输层端口：  16位二进制；</li></ol><p>​          MAC地址：48位二进制；</p><p>​          IP地址：32位二进制；</p><ol start="3"><li>两大类端口</li></ol><p>（1）服务器端使用的端口号</p><pre><code>       * 熟知端口，数值一般为 0~1023       * 登记端口号，数值为 1024~49151   为没有熟知端口号的应用程序使用，不能重复；</code></pre><p>（2）客户端使用的端口号</p><ul><li>短暂端口号，数值为 49152 ~ 65535   留给客户进程选择暂时使用。</li></ul><h2 id="二、用户数据报协议-UDP-User-Datagram-Protocol"><a href="#二、用户数据报协议-UDP-User-Datagram-Protocol" class="headerlink" title="二、用户数据报协议 UDP [ User Datagram Protocol]"></a>二、用户数据报协议 UDP [ User Datagram Protocol]</h2><blockquote><p>UDP 与 IP 协议都是无连接协议（不可靠），UDP只在 IP的数据报服务之上增加了很少一点功能：</p><ol><li>复用和分用功能；</li><li>差错检测功能；</li></ol></blockquote><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><p>（1）UDP是无连接的，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延；</p><p>（2）UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表；</p><p>（3）UDP是面向报文的。UDP对应用层交下来的报文，既不合并也不拆分，而是保留这些报文的边界。UDP一次交付一个完整的报文。</p><p>（4）UDP没有拥塞控制。因此网络出现的拥塞不会使源主机的发送速率降低。这对实时通信是很重要的。</p><p>（5）UDP支持一对一、一对多、多对一、多对多。</p><p>（6）UDP首部开销小，只有8个字节，比TCP的20个字节的首部要短。</p><h3 id="UDP用户数据报结构"><a href="#UDP用户数据报结构" class="headerlink" title="UDP用户数据报结构"></a>UDP用户数据报结构</h3><img src="/passageImg/计算机网络_传输层.assets/image-20210329094215759.png" alt="image-20210329094215759" style="zoom:67%;" /><p>总共 8个字节，包括 源端口、目的端口、长度、校验和。</p><p><strong>伪首部：</strong></p><p>但是如果只是 通过源端口和目的端口两个信息是不能唯一确定一次通信的源主机和目的主机的。比如多台主机通过相同的端口向相同的目的主机发送发送请求，目的主机通过端口无法确认是哪台主机发送的数据信息。</p><p>因此校验和中必须携带上主机的 IP 地址的信息，所以产生了伪首部（里面包括 源IP地址、目的IP地址等等），校验和通过对伪首部、源端口、目的端口、长度 一起的计算校验得出校验结果。发送UDP数据报时不需要伪首部信息，因此丢弃后发送。</p><h2 id="三、传输控制协议-TCP-Transmission-Control-Protocol"><a href="#三、传输控制协议-TCP-Transmission-Control-Protocol" class="headerlink" title="三、传输控制协议 TCP [Transmission Control Protocol]"></a>三、传输控制协议 TCP [Transmission Control Protocol]</h2><h3 id="主要特点-1"><a href="#主要特点-1" class="headerlink" title="主要特点"></a>主要特点</h3><ol><li>面向连接的运输层协议；</li><li>只能是点对点的可靠协议；</li><li>提供全双工通信；</li><li>面向字节流（消息是有序的、无论多大都可以进行传输）；</li><li>TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系；但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。</li><li>累计确认（采用滑动窗口的发送和接收方式）；</li></ol><img src="/passageImg/计算机网络_传输层.assets/image-20210329095810051.png" alt="image-20210329095810051" style="zoom:67%;" /><p>TCP不管应用程序给出多大的内存数据，每次传输都是按照自己的规划进行。在接收从上层传输下来的字节流时会对数据进行编号，然后将字节写入发送缓存中；从发送缓存中发送数据也不一定是完全按照顺序发送的，接收方只管接收到了一定编号范围的数据才将该数据块的内容向上交递。</p><img src="/passageImg/计算机网络_传输层.assets/image-20210329100344551.png" alt="image-20210329100344551" style="zoom:67%;" /><h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><p>每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。</p><p>即<code> TCP连接：：=&#123;socket1 ，socket2&#125; =&#123;(IP1：port1)，(IP2：port2)&#125;</code></p><h3 id="连续-ARQ协议-滑动窗口协议"><a href="#连续-ARQ协议-滑动窗口协议" class="headerlink" title="连续 ARQ协议(滑动窗口协议)"></a>连续 ARQ协议(滑动窗口协议)</h3><img src="/passageImg/计算机网络_传输层.assets/image-20210329121028066.png" alt="image-20210329121028066" style="zoom:67%;" /><ul><li>累计确认</li></ul><p>接收方一般采用累计确认的方式。即不需要对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认。</p><p>优点是：容易实现，即使确认丢失也不必重新传送；</p><p>缺点是：不能向发送方反映出接收方已经正确接收到的所有分组的信息；</p><ul><li>Go-back-N（回退N）</li></ul><img src="/passageImg/计算机网络_传输层.assets/image-20210329121604468.png" alt="image-20210329121604468" style="zoom:67%;" /><ul><li>TCP可靠通信的具体实现</li></ul><p>TCP连接的每一端都必须设有两个窗口，一个发送窗口和一个接收窗口；</p><p>TCP的可靠传输机制用<strong>字节的序号</strong>进行控制。TCP所有的确认都是基于序号而不是基于报文段；</p><p>TCP的四个窗口处于动态变化之中；</p><p>TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算比较合理的重传时间。</p><h3 id="TCP报文组成"><a href="#TCP报文组成" class="headerlink" title="TCP报文组成"></a>TCP报文组成</h3><p>TCP报文段首部的前20个字节是固定的，后面4n 个字节是根据需要而增加的选项（n是整数）。</p><p>因此 TCP 首部的最小长度是 20字节。</p><img src="/passageImg/计算机网络_传输层.assets/image-20210329130538159.png" alt="image-20210329130538159" style="zoom:67%;" /><p><strong>注意！</strong></p><ul><li><p><strong>序号和确认号：</strong>在同一个报头当中的序号和确认号没有关系，序号是指本次从哪个序号开始给对方发送数据；确认号是指上次发送的数据已经接收了，下次要求对方从 N 开始发送数据。</p><p>序号用来解决包乱序问题</p><p>序号和确认号是发送双方不断交替变换的。</p></li><li><p>URG ：紧急字段，表明此时有紧急数据报需要传送，应当立刻发送，和紧急指针配合使用。</p></li><li><p>ACK ：连接刚开始时可能没有发送数据，只有当 ACK &#x3D; 1 的时候确认号字段才有效。当 ACK &#x3D; 0时，确认号无效。</p></li><li><p>PSH：PSH&#x3D;1 表示有真正的数据包内容需要传送。</p></li><li><p>RST ：RST&#x3D;1 表明TCP连接中出现连接差错，必须释放连接然后再重新建立运输连接。</p></li><li><p>SYN ：SYN&#x3D;1 表明这是一个连接请求，正在建立连接。</p></li><li><p>FIN ：用来释放一个连接，为1 表明此报文的发送端数据已经发送完毕，并要求释放运输连接。</p></li><li><p>窗口 ：接收窗口，每次交互时告诉对方自己的接收能力以便调整对方的发送窗口大小；同理如果是在对方角度，对方需要根据它的接收窗口大小来调整我的发送窗口的发送能力。</p></li></ul><h3 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h3><h5 id="1-传输时的情况"><a href="#1-传输时的情况" class="headerlink" title="1. 传输时的情况"></a>1. 传输时的情况</h5><img src="/passageImg/计算机网络_传输层.assets/image-20210329101910647.png" alt="image-20210329101910647" style="zoom:67%;" /><img src="/passageImg/计算机网络_传输层.assets/image-20210329102026071.png" alt="image-20210329102026071" style="zoom:67%;" /><p>由于接收方B 根本无法判断发送方A 是否发送过数据，因此无法给发送方A 发送回复。</p><p>那么发送方A如果想要判断数据是否发送成功，就需要给每个已经发送的分组设置一个超时计时器，只要在超时计时器到期之前接收到了确认，就撤销该超时计时器，继续发送下一个分组。</p><h5 id="2-以字节为单位的滑动窗口"><a href="#2-以字节为单位的滑动窗口" class="headerlink" title="2. 以字节为单位的滑动窗口"></a>2. 以字节为单位的滑动窗口</h5><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20210329134828727.png" alt="image-20210329134828727"></p><p>发送窗口的大小根据接收窗口的大小进行调整。发送窗口在没有收到接收窗口的确认的情况下，发送窗口可以连续地把窗口内的数据发送出去。</p><p>注意发送窗口的前沿只能前移不能收缩，当接收窗口的接收能力增强时发送窗口会通过将前沿前移来扩大发送能力；发送窗口的后沿只能前移，当接收窗口的接收能力削弱时发送窗口会通过将后沿前移来削弱发送能力。</p><p>发送窗口中的序号不会销毁直到它收到了接收窗口的接收成功的消息。</p><p>发送窗口只是发送缓存的一部分。</p><img src="/passageImg/计算机网络_传输层.assets/image-20210329135810837.png" alt="image-20210329135810837" style="zoom:67%;" /><h5 id="3-需要强调的几点"><a href="#3-需要强调的几点" class="headerlink" title="3. 需要强调的几点"></a>3. 需要强调的几点</h5><p>（1）A的发送窗口不一定和B的接收窗口一样大，发送窗口需要一定的滞留时间的调整来适合到接收窗口的大小；</p><p>（2）对于不按序到达的数据的处理。通常是先放在接收窗口中，等到字节流中缺少的字节收到后，再按序交付上层的应用进程；</p><p>（3）TCP要求接收方必须有累计确认的功能，这样可以减小传输的开销。</p><p>（4）接收方可以在合适的时候发送确认，也可以在自己有数据要发送的时候把确认信息顺便捎上。</p><h3 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h3><p>发送方在发送数据后如果长时间没有收到回复，就需要进行重传。</p><p>根据其设置的超时计时器，如果将超时时间设置的太长会降低传输效率；如果设置太短会引起不必要的重传，进而使网络负荷增大。</p><p>TCP 采用了一种自适应算法，它记录一个报文段的发出时间和收到确认的时间。使用加权平均的往返时间 RTTs 来计算最合适的超时时间。</p><img src="/passageImg/计算机网络_传输层.assets/image-20210329141317386.png" alt="image-20210329141317386" style="zoom:67%;" /><h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><h5 id="1-利用可变窗口进行流量控制"><a href="#1-利用可变窗口进行流量控制" class="headerlink" title="1. 利用可变窗口进行流量控制"></a>1. 利用可变窗口进行流量控制</h5><img src="/passageImg/计算机网络_传输层.assets/image-20210329161455441.png" alt="image-20210329161455441" style="zoom:67%;" /><p><strong>存在的问题：</strong></p><p>seq 表示发送的数据的序号；</p><p>接收窗口只能在回复发送窗口时才能携带上 rwnd （窗口大小）；</p><p>如果某一时刻发送窗口已经根据接收窗口大小将窗口大小更改为0，那么就不会再给接收窗口发送数据了。即使此时接收窗口大小发生了改变，发送窗口也无法得知。这种情况下就造成了死锁。</p><p><strong>解决方法—-持续计时器：</strong></p><p>只要 TCP 连接的一方收到对方的零窗口通知，就会启动该持续计时器；</p><p>若持续计时器的时间到期，就会发送一个零窗口探测报文段（仅携带1字节的数据）；而对方就在确认这个探测报文段时给出现在的窗口值。若窗口仍然是零，就重置持续计时器；否则死锁僵局就可以被打破了。</p><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><h4 id="1-拥塞控制的一般原理"><a href="#1-拥塞控制的一般原理" class="headerlink" title="1. 拥塞控制的一般原理"></a>1. 拥塞控制的一般原理</h4><blockquote><p>拥塞控制就是防止过多的数据注入到网络中，使网络中的路由器或链路不至于过载。</p></blockquote><p>某段时间对网络中某资源的需求超过了该资源所能够提供的可用部分，网络的性能就会变坏，这种现象就称为拥塞。</p><p>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</p><p>拥塞常常趋于恶化。如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组。当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至还可能重传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃。</p><h4 id="2-拥塞控制所起的作用"><a href="#2-拥塞控制所起的作用" class="headerlink" title="2. 拥塞控制所起的作用"></a>2. 拥塞控制所起的作用</h4><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20210329170321572.png" alt="image-20210329170321572"></p><h4 id="3-监测网络拥塞的指标"><a href="#3-监测网络拥塞的指标" class="headerlink" title="3. 监测网络拥塞的指标"></a>3. 监测网络拥塞的指标</h4><ul><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差。</li></ul><h4 id="4-拥塞控制的实现"><a href="#4-拥塞控制的实现" class="headerlink" title="4. 拥塞控制的实现"></a>4. 拥塞控制的实现</h4><p>TCP采用基于窗口的方法进行拥塞控制，该方法属于闭环控制法。</p><p>TCP发送方维持一个拥塞窗口 CWND（Congestion Window）</p><ul><li>拥塞窗口的大小取决于网络的拥塞程度，并且动态变化；</li><li>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量；</li><li>发送窗口大小不仅取决于接收方公告的接收窗口大小，还取决于网络的拥塞程度，所以真正的发送窗口大小为：  Min(公告窗口值，拥塞窗口值)；</li><li>只要网络中没有出现拥塞，拥塞窗口就能再增大一些，但只要出现了拥塞，拥塞窗口大小就会减小一些。</li></ul><p><strong>拥塞的判断：</strong></p><ol><li><p>重传定时器超时；</p></li><li><p>收到 3 个相同（重复）的 ACK(确认)，预示着可能出现拥塞，因此尽快采取拥塞控制措施避免拥塞；</p><p>比如 A 向 B分别发送分组 1、2、3、4、5，但是 B 成功接受了 分组1并且返回给了 A响应1；B 未成功接收分组2，但此时A不会停止缓存窗口中的序号的发送，它会继续发送 分组3、分组4、分组5。B 都成功接收到了这些分组，但是返回的 ack 不是 3、4、5，而都是2.</p></li></ol><h4 id="5-TCP拥塞控制算法（重点）"><a href="#5-TCP拥塞控制算法（重点）" class="headerlink" title="5. TCP拥塞控制算法（重点）"></a>5. TCP拥塞控制算法（重点）</h4><h5 id="5-1-四种拥塞控制算法："><a href="#5-1-四种拥塞控制算法：" class="headerlink" title="5.1 四种拥塞控制算法："></a>5.1 四种拥塞控制算法：</h5><ul><li>慢开始；</li><li>拥塞控制；</li><li>快重传；</li><li>快恢复；</li></ul><h5 id="5-2-拥塞控制过程："><a href="#5-2-拥塞控制过程：" class="headerlink" title="5.2 拥塞控制过程："></a>5.2 拥塞控制过程：</h5><p>假设发送方将拥塞窗口的大小作为发送窗口的大小，即 swnd &#x3D; cwnd；</p><p>初始会维护一个慢开始门限 ssthresh 状态量：</p><p>​        当 cwnd &lt; ssthresh 时，使用慢开始算法；</p><p>​        当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法；</p><p>​        当 cwnd &#x3D; ssthresh 时，既可以使用慢开始算法也可以使用拥塞避免算法；</p><img src="/passageImg/计算机网络_传输层.assets/image-20210329192756017.png" alt="image-20210329192756017" style="zoom:67%;" /><ul><li>慢开始：<br>假设当前发送方拥塞窗口cwnd的值为1，而发送窗口swnd等于拥塞窗口cwnd，因此发送方当前只能发送一个数据报文段（拥塞窗口cwnd的值是几，就能发送几个数据报文段），接收方收到该数据报文段后，给发送方回复一个确认报文段，发送方收到该确认报文后，将拥塞窗口的值变为2。发送方此时可以连续发送两个数据报文段，接收方收到该数据报文段后，给发送方一次发回2个确认报文段，发送方收到这两个确认报文后，将拥塞窗口的值加2变为4，发送方此时可连续发送4个报文段，接收方收到4个报文段后，给发送方依次回复4个确认报文，发送方收到确认报文后，将拥塞窗口加4，置为8，发送方此时可以连续发送8个数据报文段，接收方收到该8个数据报文段后，给发送方一次发回8个确认报文段，发送方收到这8个确认报文后，将拥塞窗口的值加8变为16，</li></ul><blockquote><p>当前的拥塞窗口cwnd的值已经等于慢开始门限值，之后改用拥塞避免算法。</p></blockquote><ul><li><p>拥塞避免：</p><p>也就是每个传输轮次，拥塞窗口cwnd只能线性加一，而不是像慢开始算法时，每个传输轮次，拥塞窗口cwnd按指数增长。同理，16+1……直至到达24，假设24个报文段在传输过程中丢失4个，接收方只收到20个报文段，给发送方依次回复20个确认报文段，一段时间后，丢失的4个报文段的重传计时器超时了，发送发判断可能出现拥塞，更改cwnd和ssthresh.并重新开始慢开始算法。</p></li></ul><blockquote><p>将 cwnd 改为 1，将 ssthresh 改为发生拥塞时的窗口大小的一半。</p></blockquote><ul><li><p>快重传、快恢复：</p><p>但有时候个别报文段在网络中丢失，但是实际上网络中并没有出现拥塞。此时若使用拥塞避免算法会极大的将低传送效率。</p><p>发送方发送1号数据报文段，接收方收到1号报文段后给发送方发回对1号报文段的确认，在1号报文段到达发送方之前，发送方还可以将发送窗口内的2号数据报文段发送出去，接收方收到2号报文段后给发送方发回对2号报文段的确认，在2号报文段到达发送方之前，发送方还可以将发送窗口内的3号数据报文段发送出去。</p><p><strong>假设该报文丢失，接收方便不会发送针对该报文的确认报文给发送方</strong>，发送方还可以将发送窗口内的4号数据报文段发送出去，接收方收到后，发现这不是按序到达的报文段，因此给发送方发送针对2号报文段的重复确认，表明我现在希望收到的是3号报文段，但是我没有收到3号报文段，而收到了未按序到达的报文段，发送方还可以将发送窗口中的5号报文段发送出去,接收方收到后，发现这不是按序到达的报文段，因此给发送方发送针对2号报文段的重复确认，表明我现在希望收到的是3号报文段，但是我没有收到3号报文段，而收到了未按序到达的报文段,，发送方还可以将发送窗口内的最后一个数据段即6号数据报文段发送出去，接收方收到后，发现这不是按序到达的报文段，因此给发送方发送针对2号报文段的重复确认，表明我现在希望收到的是3号报文段，但是我没有收到3号报文段，而收到了未按序到达的报文段。</p><p>此时，发送方收到了累计3个连续的针对2号报文段的重复确认，立即重传3号报文段，接收方收到后，给发送方发回针对6号报文的确认，表明，序号到6为至的报文都收到了，这样就不会造成发送方对3号报文的超时重传，而是提早收到了重传。</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E4%BC%A0%E8%BE%93%E5%B1%82.assets/20190731184640178.png" alt="在这里插入图片描述"></p></li></ul><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E4%BC%A0%E8%BE%93%E5%B1%82.assets/20190731184935595.png" alt="在这里插入图片描述"></p><blockquote><p>所谓的快重传，就是使发送方尽快进行重传，而不是等到超时重传计时器超时才重传。</p><p>它要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认；</p><p>即使收到了失序的报文段也要立刻发送对已收到报文的重复确认；</p><p>发送方一旦接收到了3个相同的重复确认，就将相应的报文段立即重传，而不是等到重传计时器超时才重传。</p></blockquote><h4 id="6-流量控制和拥塞控制的区别"><a href="#6-流量控制和拥塞控制的区别" class="headerlink" title="6. 流量控制和拥塞控制的区别"></a>6. 流量控制和拥塞控制的区别</h4><p>（1）概念不同：</p><ul><li>流量控制指的是端到端的控制，比如 A通过网络给 B发数据，A发送的太快导致 B无法接收（B的缓冲窗口过小或者处理过慢）。这时候的控制就是流量控制，原理是通过滑动窗口的大小来实现。</li><li>拥塞控制指的是 A 与 B 之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及降低网络性能相关的所有因素。</li></ul><p>（2）控制机制不同：</p><ul><li>流量控制中每次根据接收窗口大小动态调整发送窗口的大小；当接收窗口的大小变为0时，会触发发送出窗口启动持续计时器，发送方会发送一个1字节大小的探测报文段，接收方会将自己的窗口大小捎带返回给发送方，这样打破了僵局解开了死锁；</li><li>拥塞控制如上所描述，采用了 慢开始、拥塞避免、快重传、快恢复算法。</li></ul><h2 id="四、TCP-运输连接管理"><a href="#四、TCP-运输连接管理" class="headerlink" title="四、TCP 运输连接管理"></a>四、TCP 运输连接管理</h2><h3 id="4-1-TCP-建立连接过程中要解决的三个问题"><a href="#4-1-TCP-建立连接过程中要解决的三个问题" class="headerlink" title="4.1 TCP 建立连接过程中要解决的三个问题"></a>4.1 TCP 建立连接过程中要解决的三个问题</h3><p>（1）要使得每一方能够确认对方的存在；</p><p>（2）要允许双方协商一些参数[比如窗口的最大值、是否使用窗口扩大选项和时间戳选项以及服务质量]；</p><p>（3）能够对运输实体资源（比如缓存大小、连接表中的项目等）进行分配；</p><h3 id="4-2-TCP建立连接的三次报文握手"><a href="#4-2-TCP建立连接的三次报文握手" class="headerlink" title="4.2 TCP建立连接的三次报文握手"></a>4.2 TCP建立连接的三次报文握手</h3><ol><li><p>首先 A 给 B 发送一次请求（设置 SYN&#x3D;1；seq&#x3D;x；ACK&#x3D;0）；</p></li><li><p>B 接收到请求后需要对 A做出响应，同时 B也要测试 A能否接收到自己发送的请求；</p><p>（SYN&#x3D;1； ACK&#x3D;1；seq&#x3D;y；ack&#x3D;x+1）</p></li><li><p>A 接收到请求后再次发送响应给B（设置 ACK&#x3D;1；seq&#x3D;x+1；ack&#x3D;y+1；SYN&#x3D;0）</p></li></ol><img src="/passageImg/计算机网络_传输层.assets/image-20210329202743221.png" alt="image-20210329202743221" style="zoom:67%;" /><h3 id="4-3-TCP连接的释放—四次握手"><a href="#4-3-TCP连接的释放—四次握手" class="headerlink" title="4.3 TCP连接的释放—四次握手"></a>4.3 TCP连接的释放—四次握手</h3><ol><li><p>A的所有数据已经发送完毕，主动关闭（客户端主动关闭），发送关闭请求给 B（服务器）（设置 FIN&#x3D;1；seq&#x3D;u）；</p></li><li><p>B 接收到请求后发送回复（ACK&#x3D;1；ack&#x3D;u+1；seq&#x3D;v）；但是B此时可能还有数据未完全发送；</p><p>B 不断发送数据给A（数据传送），A中途不会发送回应（累计响应，此阶段 ack始终为 u+1）；</p></li><li><p>B 完成所有的数据发送，也发送关闭请求给A（ACK&#x3D;1；FIN&#x3D;1；seq&#x3D;w；ack&#x3D;u+1）；</p><p>如果A成功接收所有数据，会发送回复给B（ACK&#x3D;1；FIN&#x3D;1；seq&#x3D;u+1；ack&#x3D;w+1）；</p></li><li><p>但是A的回复B是否真的收到了呢？如果此次回复发送失败，那么A肯定不能结束。</p><p>同时对于B来说，它发送给A的结束请求在规定时间内(重传计时器)没有收到回复也会重新发送请求。</p><p>那么A就设置了一个等待计时器(等待时间 2MSL，比对方的超时计时器还要长)，如果在计时器结束之前没有收到第三次握手的重复数据包，说明B成功接收了此次回复，那么整个过程就结束了。</p></li></ol><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20210329203613469.png" alt="image-20210329203613469"></p><blockquote><p>TCP 连接必须等待 2MSL 后才能真正释放掉。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池</title>
      <link href="/2021/03/15/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2021/03/15/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="一、Java线程池-ExecutorService"><a href="#一、Java线程池-ExecutorService" class="headerlink" title="一、Java线程池 ExecutorService"></a>一、Java线程池 ExecutorService</h2><h3 id="1-ExecutorService介绍"><a href="#1-ExecutorService介绍" class="headerlink" title="1. ExecutorService介绍"></a>1. ExecutorService介绍</h3><blockquote><p>ExecutorService 是Java中对线程池定义的一个接口，它存在于 java.util.concurrent 包中，这个接口中定义了后台执行任务相关的方法。</p></blockquote><img src="/passageImg/Java杂记.assets/image-20210406180221611.png" alt="image-20210406180221611" style="zoom: 80%;" /><p><img src="/passageImg/Java%E6%9D%82%E8%AE%B0.assets/20151027091552190" alt="这里写图片描述"></p><p>ExecutorService 继承自<code> Executor</code> 接口（区分开工厂类 Executors），它有两个实现的子类 <code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code>。</p><span id="more"></span><h3 id="2-ExecutorService的创建"><a href="#2-ExecutorService的创建" class="headerlink" title="2. ExecutorService的创建"></a>2. ExecutorService的创建</h3><blockquote><p>Java 提供了一个工厂类 Executors 来创建各种类型的 ExecutorService 线程池，总共可以创建以下四种线程池。</p></blockquote><ul><li><p><code>newCachedThreadPool</code>：创建一个可缓存的线程池，如果线程池长度超过需要可以灵活地回收空闲线程；如果没有可以回收的，则创建新线程。</p></li><li><p><code>newFixedThreadPool</code>：创建一个固定大小的线程池，可以控制最大的线程并发数，超出的线程必须在队列中等待。</p></li><li><p><code>newScheduledThreadPool</code>：创建一个定长的线程池，支持周期性的执行任务；</p></li><li><p><code>newSingleThreadExecutor</code>：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO、LIFO）执行。</p><p><code>Executors</code>只是一个工厂类，它所有方法返回的都是 ThreadPoolExecutor、ScheduledThreadPoolExecutor两个类的实例。</p></li></ul><h3 id="3-ExecutorService的使用"><a href="#3-ExecutorService的使用" class="headerlink" title="3. ExecutorService的使用"></a>3. ExecutorService的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Asynchoronus task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><h3 id="4-ExecutorService的执行"><a href="#4-ExecutorService的执行" class="headerlink" title="4. ExecutorService的执行"></a>4. ExecutorService的执行</h3><h4 id="4-1-execute-Runnable-xxx"><a href="#4-1-execute-Runnable-xxx" class="headerlink" title="4.1 execute(Runnable xxx)"></a>4.1 execute(Runnable xxx)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">  executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Runnable task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>execute(Runnable xxx)</code>方法接收一个 Runnable 的实例，并且异步执行。</p><p>这个方法的缺点就是无法获取任务的执行结果，我们如果想要获取任务的执行结果就需要传入一个 Callable的实例。</p><h4 id="4-2-submit-Runnable-xxx"><a href="#4-2-submit-Runnable-xxx" class="headerlink" title="4.2 submit(Runnable xxx)"></a>4.2 submit(Runnable xxx)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;submit Runnable task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure><p><code>execute()</code>和<code>submit()</code>方法的区别是后一个方法可以返回一个<code>Future</code>对象，通过返回的 <code>Future</code>对象我们可以检查提交的任务是否执行完毕。</p><p>如果执行完毕，那么<code>future.get()</code>方法会返回一个null。注意 <code>future.get()</code>方法会产生阻塞。</p><h4 id="4-3-submit-Callable-xxx"><a href="#4-3-submit-Callable-xxx" class="headerlink" title="4.3 submit(Callable xxx)"></a>4.3 submit(Callable xxx)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Future</span> <span class="variable">future1</span> <span class="operator">=</span> executorService.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;callable submit&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future1.get());</span><br></pre></td></tr></table></figure><p><code>submit(Callable xxx)</code>和<code>submit(Runnable xxx)</code>方法类似，都能够返回一个 Future对象但是，submit(Callable)接收的是一个Callable的实现，Callable接口中的<code>call()</code>方法有一个返回值，可以返回任务的执行结果，而Runnable接口中的<code>run()</code>方法是<code>void</code>的，没有返回值。</p><h4 id="4-4-invokeAny-Callable集合"><a href="#4-4-invokeAny-Callable集合" class="headerlink" title="4.4 invokeAny(Callable集合)"></a>4.4 invokeAny(Callable集合)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">Set&lt;Callable&lt;String&gt;&gt; callables = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Callable&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">callables.add(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Task 1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">callables.add(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Task 2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">callables.add(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Task 3&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> executorService.invokeAny(callables);</span><br><span class="line">System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><p>该方法接收一个Callable的集合，执行这个方法不会返回 Future，但是会返回所有 Callable()任务中一个任务的执行结果，这个方法也无法保证返回的是哪个任务的结果。</p><h4 id="4-5-invokeAll-Callable集合"><a href="#4-5-invokeAll-Callable集合" class="headerlink" title="4.5 invokeAll(Callable集合)"></a>4.5 invokeAll(Callable集合)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">Set&lt;Callable&lt;String&gt;&gt; callables = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Callable&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">callables.add(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Task 1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">callables.add(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Task 2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">callables.add(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Task 3&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callables);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Future&lt;String&gt; future : futures)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;future.get = &quot;</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><p>该方法与 <code>invokeAny(xxx)</code>类似，不过返回的是所有任务执行后的 Future集合。</p><h3 id="5-ExecutorService关闭"><a href="#5-ExecutorService关闭" class="headerlink" title="5. ExecutorService关闭"></a>5. ExecutorService关闭</h3><p>当我们使用完成ExecutorService之后应该关闭它，否则它里面的线程会一直处于运行状态。</p><p>举个例子，如果的应用程序是通过main()方法启动的，在这个main()退出之后，如果应用程序中的ExecutorService没有关闭，这个应用将一直运行。之所以会出现这种情况，是因为ExecutorService中运行的线程会阻止JVM关闭。</p><p>如果要关闭ExecutorService中执行的线程，我们可以调用ExecutorService.shutdown()方法。在调用shutdown()方法之后，ExecutorService不会立即关闭，但是它不再接收新的任务，直到当前所有线程执行完成才会关闭，所有在shutdown()执行之前提交的任务都会被执行。</p><p>如果我们想立即关闭ExecutorService，我们可以调用ExecutorService.shutdownNow()方法。这个动作将跳过所有正在执行的任务和被提交还没有执行的任务。但是它并不对正在执行的任务做任何保证，有可能它们都会停止，也有可能执行完成。</p><h2 id="二、线程的生命周期及五种状态-操作系统版本"><a href="#二、线程的生命周期及五种状态-操作系统版本" class="headerlink" title="二、线程的生命周期及五种状态(操作系统版本)"></a>二、线程的生命周期及五种状态(操作系统版本)</h2><p><img src="/passageImg/Java%E6%9D%82%E8%AE%B0.assets/20190407112603812.png" alt="在这里插入图片描述"></p><ul><li><p><strong>新建状态（New）</strong>：当线程对象对创建后，即进入了新建状态，如：Thread t &#x3D; new MyThread();</p></li><li><p><strong>就绪状态（Runnable）</strong>：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p></li><li><p><strong>运行状态（Running）</strong>：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p></li><li><p><strong>阻塞状态（Blocked）</strong>：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p></li></ul><p>​           1.  等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</p><p>​           2.  同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</p><p>​           3.  其他阻塞 – 通过调用线程的sleep()或join()或发出了I&#x2F;O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入<strong>就绪状态</strong>。</p><ul><li><strong>死亡状态（Dead）</strong>：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ul><p> 线程资源包括两部分：锁资源、CPU资源；</p><p><code>sleep(long mills)</code>：让出CPU资源，但是不会释放锁资源；</p><p><code>wait()</code>：让出CPU资源，同时释放锁资源；</p><p>锁是用来线程同步的，sleep(long mills)虽然让出了CPU，但是不会让出锁，其他线程可以利用CPU时间片了，但如果其他线程要获取sleep(long mills)拥有的锁才能执行，则会因为无法获取锁而不能执行，继续等待。<br>但是那些没有和sleep(long mills)竞争锁的线程，一旦得到CPU时间片即可运行了。</p><h2 id="三、线程的生命周期和六种状态-Java版本"><a href="#三、线程的生命周期和六种状态-Java版本" class="headerlink" title="三、线程的生命周期和六种状态(Java版本)"></a>三、线程的生命周期和六种状态(Java版本)</h2><ul><li><p><strong>初始(New)：</strong>新建了一个线程对象，但是还没有调用start()方法；</p></li><li><p><strong>运行(Runnable)：</strong>Java中将就绪（Ready）和运行中（Running）统称为运行；</p><p>线程对象创建后，当其它线程调用了 start()方法后线程进入 Ready，线程进入线程池等待被调度选用；当获得CPU时间片后变为运行状态 Running；</p></li><li><p><strong>阻塞(Blocked)：</strong>表示线程阻塞于锁；</p></li><li><p><strong>等待(Waiting)：</strong>进入该状态的线程需要等待其它线程做出一些特定的操作；</p></li><li><p><strong>超时等待(TIMED_Waiting)：</strong>该状态不同于Waiting，它可以在指定的时间后自行返回；</p></li><li><p><strong>终止(TERMINATED)：</strong>表示线程已经执行完毕。</p></li></ul><h3 id="3-1-线程状态图"><a href="#3-1-线程状态图" class="headerlink" title="3.1 线程状态图"></a>3.1 线程状态图</h3><p><img src="/passageImg/Java%E6%9D%82%E8%AE%B0.assets/20181120173640764.jpeg" alt="    "></p><p>线程创建之后会调用 start() 方法开始执行，此时线程进入 Runnable(运行状态)；</p><p>当调用 wait()、join()、LockSupport.lock()方法时，会进入到 Waiting 状态；</p><p>当调用 wait()、join()、sleep()、LockSupport.parkNanos()、LockSupport.parkUntil()方法时会进入超时等待状态，当超时等待结束后线程会切换到Runnable 状态；</p><p>另外处于 Waiting、TIMED_Waiting 两个状态时可以通过 Object.notify()、Object.notifyAll() 、LockSupport.unpark()方法切换到 Runnable状态。</p><p>当线程出现竞争锁资源的时候，即等待获取锁的时候会进入 BLOCKED阻塞状态。当线程获取到锁资源时进入Runnable状态。</p><p>线程运行结束后，线程进入到TERMINATED状态。</p><blockquote><p>当线程进入到synchronized方法或者synchronized代码块时，线程切换到的是BLOCKED状态；而使用java.util.concurrent.locks下lock进行加锁的时候线程切换的是WAITING或者TIMED_WAITING状态，因为lock会调用LockSupport的方法。</p><p>ReentrantLock 底层加锁的原理就是调用了 LockSupport.park()方法，相比对Synchorized 它所占用的资源更少，在JDK层面就解决了问题，不必等到os 层面去解决。</p></blockquote><h2 id="四、线程状态的基本操作"><a href="#四、线程状态的基本操作" class="headerlink" title="四、线程状态的基本操作"></a>四、线程状态的基本操作</h2><h3 id="4-1-interrupt"><a href="#4-1-interrupt" class="headerlink" title="4.1 interrupt"></a>4.1 interrupt</h3><p>中断可以理解为线程的一个标志位，它表示一个运行中的线程是否被其它线程进行了中断操作。</p><p>其它线程可以调用该线程的 interrupt() 方法对其进行中断操作，同时该线程可以调用 isInterrupt() 方法来感知其它线程对自身的中断操作，从而做出响应；同时可以调用 Thread的静态方法 interrupt() 对当前线程进行中断操作，该方法会清除标志位。<strong>需要注意的是，当抛出 InterruptedException时候，会清除中断标志位，也就是在调用 isInterrupted 方法时会返回 false</strong></p><p><img src="/passageImg/Java%E6%9D%82%E8%AE%B0.assets/163159c1a4cc499d" alt="线程中断的方法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//sleepThread睡眠1000ms</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">sleepThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">super</span>.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//busyThread一直执行死循环</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">busyThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        sleepThread.start();</span><br><span class="line">        busyThread.start();</span><br><span class="line">        sleepThread.interrupt();</span><br><span class="line">        busyThread.interrupt();</span><br><span class="line">        <span class="keyword">while</span> (sleepThread.isInterrupted()) ;</span><br><span class="line">        System.out.println(<span class="string">&quot;sleepThread isInterrupted: &quot;</span> + sleepThread.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;busyThread isInterrupted: &quot;</span> + busyThread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/passageImg/Java杂记.assets/image-20210407133450340.png" alt="image-20210407133450340" style="zoom:80%;" /><p>开启了两个线程分别为sleepThread和BusyThread, sleepThread睡眠1s，BusyThread执行死循环。然后分别对着两个线程进行中断操作，可以看出sleepThread抛出InterruptedException后清除标志位，而busyThread就不会清除标志位。</p><p>另外，同样可以通过中断的方式实现线程间的简单交互， while (sleepThread.isInterrupted()) 表示在Main中会持续监测sleepThread，一旦sleepThread的中断标志位清零，即sleepThread.isInterrupted()返回为false时才会继续Main线程才会继续往下执行。因此，中断操作可以看做线程间一种简便的交互方式。一般在<strong>结束线程时通过中断标志位或者标志位的方式可以有机会去清理资源，相对于武断而直接的结束线程，这种方式要优雅和安全。</strong></p><h3 id="4-2-join"><a href="#4-2-join" class="headerlink" title="4.2 join"></a>4.2 join</h3><blockquote><p>join方法可以看做是线程间协作的一种方式，很多时候，一个线程的输入可能非常依赖于另一个线程的输出。如果一个线程实例A执行了threadB.join(),其含义是：当前线程A会等待threadB线程终止后threadA才会继续执行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJoin</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">previousThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JoinThread</span>(previousThread);</span><br><span class="line">            current.start();</span><br><span class="line">            previousThread = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JoinThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">JoinThread</span><span class="params">(Thread thread)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">&quot;terminated.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了10个线程，每次后一个线程都必须等待前一个线程操作完毕后才能继续执行。</p><h3 id="4-3-sleep"><a href="#4-3-sleep" class="headerlink" title="4.3 sleep"></a>4.3 sleep</h3><p><code>public static native void sleep(long millis) throws InterruptedException;</code></p><p>sleep 方法是 Thread的静态方法，它是让当前线程按照指定的时间休眠。注意的是 sleep方法并不会释放锁，而只是释放掉 cpu 资源，sleep经常与 wait 方法拿来做比较。</p><h4 id="sleep-VS-wait"><a href="#sleep-VS-wait" class="headerlink" title="sleep VS  wait"></a>sleep VS  wait</h4><p>两者的主要区别：</p><ul><li>sleep 是Thread的静态方法；而 wait 是Object类的方法；</li><li>wait() 必须在同步方法或同步代码块中使用，也就是必须获取到对象锁[类似的还有 notify()方法]。而 sleep方法没有限制，可以在任何地方使用。</li><li>wait() 会释放掉cpu资源和对象锁，使得该线程进入等待池中(Waiting状态)；而 sleep 只会释放掉cpu资源不会释放锁，该线程进入超时等待状态(TIMED_Waiting状态)。</li><li>sleep() 在进过超时时间后会自动转换为 Runnable状态等待cpu的再次调度；而 wait() 方法必须等待 Object.notify()&#x2F;Object.notifyAll() 通知后，才能进行 Runnable状态。</li></ul><h4 id="4-4-yield"><a href="#4-4-yield" class="headerlink" title="4.4 yield"></a>4.4 yield</h4><p><code>public static native void yield();</code></p><p>yield 是一个静态方法，一旦执行它会使当前线程让出 CPU ，但是这并不意味着当前线程不能再执行。如果在下一次竞争中当前线程又获得了CPU时间片，那么依旧会继续执行。</p><p>yield让出的时间片只会分配给<strong>同优先级</strong>的线程去使用；而sleep 方法让出的时间片可供<strong>所有线程</strong>去竞争。</p><blockquote><p>关于线程优先级：</p></blockquote><p>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当前时间片用完后就会发生线程调度，并等待这下次分配。线程分配到的时间多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要或多或少分配一些处理器资源的线程属性。</p><p>线程优先级可以通过 <code>xxx.setPriority(int)</code>来设置优先级，优先级范围为1~10，默认为5，优先级高的线程相较于低的线程优先获取处理器的时间片。</p><h4 id="4-5-守护线程-Daemon"><a href="#4-5-守护线程-Daemon" class="headerlink" title="4.5 守护线程 Daemon"></a>4.5 守护线程 Daemon</h4><blockquote><p>守护线程是一种特殊的线程，比如 垃圾回收线程、JIT线程都可以理解为守护线程。</p><p>与之对应的是用户线程，用户线程可以理解为工作线程，它会完成整个系统的业务操作。用户线程结束后就意味着整个业务工作结束了，守护线程会退出。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDaemon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;守护中....&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;finally block&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        daemonThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">800</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：</p><p>​        <a href="https://blog.csdn.net/suifeng3051/article/details/49443835">https://blog.csdn.net/suifeng3051/article/details/49443835</a></p><p>​        <a href="https://blog.csdn.net/suifeng3051/article/details/49444177">https://blog.csdn.net/suifeng3051/article/details/49444177</a></p><p>​        <a href="https://blog.csdn.net/pange1991/article/details/53860651?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control">https://blog.csdn.net/pange1991/article/details/53860651?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加密算法</title>
      <link href="/2021/03/01/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2021/03/01/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>常见的加密编码等算法解析包括</strong>： MD5、SHA、ASC、进制、时间戳、URL、BASE64、AES、DES等</p><p><strong>常见加密形式算法解析</strong>：直接加密、带salt、带密码、带偏移、带位数、带模式、带干扰、自定义组合等；</p><p><strong>常见解密方式</strong>：枚举、自定义逆向算法、可逆向</p></blockquote><h2 id="MD4"><a href="#MD4" class="headerlink" title="MD4"></a>MD4</h2><p><strong>介绍：</strong></p><ol><li><p>在执行MD4算法前，首先需要对输入的内容进行填充和分段。对于长于448位的信息，在其后添加一个1和n个0，使其按位长度对512求余后值为448。随后用64位的输入长度信息附加在已经填充好的原始信息后，使其长度为512 的整数倍。每次处理一段(512位)，输出四个32位字。</p></li><li><p>MD4算法中包括四个32位无符号整数类型的参数H1、H2、H3、H4，四个参数在处理第一块内容前初始化为 H1&#x3D;0x67452301、H2&#x3D;0xefcdab89、H3&#x3D;0x98badcfe、H4&#x3D;0x10335476。在计算完第 i 块后，将更新这四个值作为第 i+1 块的输入。计算完最后一块，它们就作为MD4算法对整个输入内容的计算结果。</p></li><li><p>算法中涉及到不同的三类参数：常数y[j]、访问输入内容的索引z[j]、移位次数s[j]。整个算法分为3轮，每轮16步。</p><p><img src="/../passageImg/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20211019140434221.png" alt="image-20211019140434221"></p></li></ol><p><strong>实现：</strong></p><p><img src="/../passageImg/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20211019140508386.png" alt="image-20211019140508386"></p><span id="more"></span><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p><strong>介绍：</strong>MD4由于加密过程中所涉及到的部分变量是固定不变的(比如参数y[i]在每轮加密中是固定不变的)，因此安全性不高。所以产生了MD5加密算法来优化。MD5整体上和MD4算法相同，输出也是128位 (4个32位)。额外优化体现在：MD5是不可逆加密算法。</p><ol><li>算法由3轮增加到了4轮；</li><li>每步算法中增加了一个加法操作；</li><li>访问消息的索引z[j]和移位次数s[j]发生了变化；</li><li>常数y[j] 由每轮相同更改为每轮不同；</li><li>第二轮中非线性函数g() 发生了变化。</li></ol><p>更新后的参数列表：</p><p><img src="/../passageImg/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20211019141200802.png" alt="image-20211019141200802"></p><p><strong>实现：</strong></p><p><img src="/../passageImg/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20211019141215753.png" alt="image-20211019141215753"></p><h2 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h2><p><strong>介绍：</strong>SHA-1 算法参考 MD4 算法进行了实现。SHA-1 算法将输入字符串分为了若干个512位长的段，每次处理一个段然后输出5个32位字。同理在处理前需要对待处理字段进行填充，使得长度为512的整数倍。初始时的5个整数为：H0 &#x3D; 0x67452301、H1 &#x3D; 0xefcdab89、H2 &#x3D; 0x98badcfe、H3 &#x3D; 0x10325476、H4 &#x3D; 0xc3d2e1f0。计算完第i 块后，更新这五个值作为第 i+1 块的输入。</p><p>参数：</p><p><img src="/../passageImg/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20211019142005410.png" alt="image-20211019142005410"></p><p><strong>实现：</strong></p><p><img src="/../passageImg/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20211019142032547.png" alt="image-20211019142032547"></p><h2 id="SHA-2"><a href="#SHA-2" class="headerlink" title="SHA-2"></a>SHA-2</h2><p><strong>介绍：</strong> SHA-2 算法包括了一系列散列函数：SHA-224、SHA-256、SHA-384、SHA-512等等。应用最广泛的就是SHA-256&#x2F; SHA-512。</p><p>详细介绍 SHA-256 算法的实现细节：首先对输入字段进行分段处理，每段大小为512位，如果段长大于448位就在字段后补充一个1和n个0使得总的字段长度为512的整数倍。每次对一段进行处理，输出8个32位字的结果，该结果作为下一轮的参数输入。最终处理完所有块后就是最终结果。</p><p>涉及到的主要数据体：信息块<code>M[0:15](16个32位字)</code>、扩展信息块<code>W[0:63](64个32位字)</code>、常量<code>K[0:63](64个32位字)</code>、摘要<code>H[0:7] = [0x6a09e667，0xbb67ae85、0x3c6ef372、0xa54ff53a、0x510e527f、0x9b05688c、0x1f83d9ab、0x5be0cd19]</code></p><p><img src="/../passageImg/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20211019143424519.png" alt="image-20211019143424519"></p><p><strong>实现：</strong></p><p><img src="/../passageImg/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20211019143442931.png" alt="image-20211019143442931"></p><h2 id="加密解密案例"><a href="#加密解密案例" class="headerlink" title="加密解密案例"></a>加密解密案例</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网（一）、数据链路层</title>
      <link href="/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><ul><li><p>链路：一条无源的点到点的物理线路段，中间没有任何其它的交换节点；</p></li><li><p>数据链路：除了物理线路外，还必须有通信协议来控制这些数据的传输；把这些协议的硬件和软件加到链路上，就构成了数据链路；</p><p>最常用的方法是：适配器（网卡）来实现软件和硬件，网卡一般都包括了数据链路层和物理层这两层；</p></li><li><p>数据链路层传送的是帧。网络层将 ip数据报传入数据链路层封装成帧，数据链路层再将帧传送给物理层转换为比特流的形式发送给对方机器，对方机器接收后再反过来进行转换。</p></li></ul><span id="more"></span><h2 id="二、三个基本问题"><a href="#二、三个基本问题" class="headerlink" title="二、三个基本问题"></a>二、三个基本问题</h2><ul><li>封装成帧；</li><li>透明传输；</li><li>差错控制；</li></ul><h3 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="(1) 封装成帧"></a>(1) 封装成帧</h3><blockquote><p>在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。首部和尾部的重要作用就是对帧进行定界。</p></blockquote><p><code>MTU</code>：Maximum Transfer Unit 最大传输单元，规定了链路层所能传输帧的数据部分的长度上限。</p><p><code>SOH</code>：Start Of Header 控制字符，放在帧的最前端，表示帧的首部开始；</p><p><code>EOT</code>：End Of Tail  ，表示帧的尾部结束部分。</p><h3 id="2-透明传输"><a href="#2-透明传输" class="headerlink" title="(2) 透明传输"></a>(2) 透明传输</h3><blockquote><p>当帧的首尾部分出现在帧的数据部分可能会造成数据的误识别，因此需要采用一些措施来使得这些问题好像没有发生过一样。</p></blockquote><ul><li>解决办法：</li></ul><p>​        字节填充(byte stuffing)、字符填充(character stuffing)。</p><p>​        在当数据部分出现帧的控制符时，在其前面插入一个转义字符以便接收方接收识别。</p><ul><li>字符填充（同步传输时使用）：</li></ul><img src="/passageImg/计算机网络_数据链路层.assets/image-20210321162808891.png" alt="image-20210321162808891" style="zoom: 67%;" /><ul><li>零比特传输：</li></ul><img src="/passageImg/计算机网络_数据链路层.assets/image-20210321162932524.png" alt="image-20210321162932524" style="zoom:67%;" /><p>* </p><h3 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="(3) 差错检测"></a>(3) 差错检测</h3><blockquote><p>传送过程中可能会出现比特差错，1 变成 0 而 0 也可能变成 1</p></blockquote><p>循环冗余检测：</p><ol><li>在要发送的数M后边添加 n个0；</li><li>将得到的数除以收发双方事先商定的长度为(n+1) 位的除数P，得出的商是Q而余数是R；</li><li>将R拼接在M后边一起发送给接收端；</li><li>接收端接收到数据后再除以P，如果余数为0则表明没有出错，否则传输过程中出现了错误。</li></ol><p>循环冗余检测只能用于检错不能用于纠错，数据链路层使用 CRC 检验，能够实现无比特差错传输，但是不是可靠传输。</p><h2 id="三、点对点协议PPP"><a href="#三、点对点协议PPP" class="headerlink" title="三、点对点协议PPP"></a>三、点对点协议PPP</h2><blockquote><p>目前数据链路层使用的最多的协议是点对点协议</p></blockquote><p>PPP协议应该满足的需求：</p><ol><li>简单—首要要求；</li><li>封装成帧；</li><li>透明传输；</li><li>差错检测；</li><li>在同一链路上支持多种网络层协议；能够在多种链路上运行(既需要满足上层又需要满足下层)；</li></ol><p>PPP协议不需要的功能：</p><ol><li>纠错；</li><li>流量控制；</li><li>给帧添加序号，判断帧的重复、失序、丢失；</li><li>多点线路；</li><li>半双工或单工链路；</li></ol><p>PPP协议的组成部分：</p><ol><li>一个将 IP 数据报封装到串行链路的方法；</li><li>链路控制协议 LCP（Link Control Protocol）：用来建立、检测链路连接的协议；</li><li>网络控制协议 NCP（Network Control Protocol）：用来支持多种网络层协议；</li></ol><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.assets/image-20210321162612678.png" alt="image-20210321162612678"></p><h2 id="四、以太网"><a href="#四、以太网" class="headerlink" title="四、以太网"></a>四、以太网</h2><blockquote><p>适配器：计算机与外界局域网的连接是通过通信适配器(网卡)进行的。</p></blockquote><h3 id="1-适配器的主要功能如下："><a href="#1-适配器的主要功能如下：" class="headerlink" title="1. 适配器的主要功能如下："></a>1. 适配器的主要功能如下：</h3><ol><li>数据串行传输和并行传输的转换；    适配器和局域网之间的通信是通过双绞线或电缆进行串行传输的，适配器和计算机之间的通信则是通过主板上的IO总线的方式进行传输的。</li><li>对数据进行缓存；局域网的数据传输率和计算机的数据传输率不一致，需要缓存调整；</li><li>在计算机操作系统中安装设备；在主板安装适配器时必须将管理适配器的设备驱动程序安装在计算机操作系统中；</li><li>实现以太网协议；</li></ol><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.assets/image-20210321164536629.png" alt="image-20210321164536629"></p><h3 id="2-以太网-MAC网帧"><a href="#2-以太网-MAC网帧" class="headerlink" title="2. 以太网 MAC网帧"></a>2. 以太网 MAC网帧</h3><blockquote><p>MAC地址：媒体接入层上使用的地址，也叫做物理地址、硬件地址或者链路地址，由网络设备制造商生产时写在硬件内部。MAC地址与网络无关，也即无论将带有这个地址的硬件设备接入到网络的何处，都有相同的MAC地址。现在一般采用 6字节(48位)的MAC地址。前24位由 IEEE 注册，后24位由厂家指定。</p><p>在OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。因此一个主机会有一个唯一的MAC地址，而每个网络位置会有一个唯一的IP地址。工作在数据链路层的交换机维护着 计算机MAC地址和MAC地址表，交换机根据接收到的数据帧中的 “目的MAC地址” 字段来转发数据帧。</p></blockquote><p>以太网 MAC帧的格式：</p><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.assets/20131017004657921" alt="img"></p><p>组成：</p><ul><li>6字节长的目的地址和源地址；</li><li>2字节的类型字段；用来标志上一层使用的是什么协议，以便把接收到的MAC帧的数据上交给上一层；</li><li>数据字段（46~1500字节长度），46是通过最小长度64字节减去18字节的首部和尾部；</li><li>4字节的帧检验序列FCS（使用CRC冗余检验）；</li></ul><p>注意：</p><ul><li><p>当数据字段小于46字节时，会在尾部进行填充。但是这样上层协议如何知道填充字段的长度呢？</p><p>当上层使用 ip 协议时，其首部会有一个总长度字段，总长度字段长度+填充字段长度&#x3D;MAC帧数据部分长度</p></li><li><p>在传输媒体上实际传输的要比MAC帧还多8个字节，这是因为当一个站刚开始接收MAC帧时，由于适配器的时钟没有与到达的比特流形成同步，因此MAC帧最前面的若干位就会无法接收，这个帧就会被丢弃。因此从MAC 子层向下传输到物理层时还要再帧的前面加上8个字节（7字节前同步码：使接收端的适配器在接受MAC帧时能够迅速调整其时钟频率；1字节的帧开始定界符：前6位与前同步码作用相同，后2位都是1为了提示适配器接收MAC帧）；</p></li><li><p>以太网帧在传输时，接收端只需要找到它的开始定界符，后续到达的比特流都属于一个MAC帧。它不使用帧结束定界符也不需要使用字节插入来保证透明传输。</p></li></ul><h3 id="3-以太网独特的工作方式"><a href="#3-以太网独特的工作方式" class="headerlink" title="3. 以太网独特的工作方式"></a>3. 以太网独特的工作方式</h3><p>（1）较灵活的无连接工作方式—-采用广播的形式，尽最大努力交付，不可靠交付；</p><p>（2）曼彻斯特编码：方便发送方、接收方进行同步，缺点是跳变太多，频带宽度比原始基带信号增加一倍；</p><p>（3）CSMA&#x2F;CD  协议，载波监听多点接入&#x2F;碰撞检测：计算机边发送数据边检测信道上的信号电压大小。在发送期间进行碰撞检测，以检测冲突。使用 CSMA&#x2F;CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。</p><h3 id="4-CSMA-x2F-CD-协议："><a href="#4-CSMA-x2F-CD-协议：" class="headerlink" title="4. CSMA&#x2F;CD 协议："></a>4. CSMA&#x2F;CD 协议：</h3><blockquote><p>A 和 B分别双向发送数据，那么一定会在某一时刻两列电磁波相遇，相遇后的电磁波会被叠加，那么在两个接收端接收到的信号数据都将被废弃。</p></blockquote><img src="/passageImg/计算机网络_数据链路层.assets/image-20210321193103480.png" alt="image-20210321193103480" style="zoom:67%;" /><p>解决方法： </p><img src="/passageImg/计算机网络_数据链路层.assets/image-20210321194923942.png" alt="image-20210321194923942" style="zoom: 67%;" /><p><strong>二进制指数类型退避算法：</strong></p><p>发生碰撞的站在停止发送数据后，要推迟一个随机时间才能再次发送数据。</p><p>基本退避时间为争用期 2t，从整数集合  [0,1,2,3,….,(2^k-1)] 中随机选择一个值 r。重传所需的时延就是 r 倍的基本退避时间；参数 k 的计算： <code>k = min[重传次数,10]</code>。当 k ≤ 10时，参数 k 等于重传次数。如果重传达到16次都不成功，向上层报告。</p><p>可以发现，重传次数越多，每个站等待时间相同的几率就越小，那么就能够避开彼此正常传输了。</p><blockquote><p>由此得出结论，在 10 M&#x2F;s 以太网取 51.2us 为争用期的长度。对于 10M&#x2F;s 以太网，在争用期内最多可以发送 512bit 即 64字节的数据。</p><p>如果这64字节的数据没有发生冲突，那么说明后续的数据就不会发生冲突。</p><p>因此 64字节就变成了有效帧的最短长度，如果小于这个值说明这个帧的数据不完整，在传送过程中可能发生了冲突，因此会被丢弃。</p><p>因为发送过程总可能会发生冲突，为了保证信道利用率，就必须增加帧的长度，因此最短帧长就是争用期内能够发送的数据量。</p></blockquote><img src="/passageImg/计算机网络_数据链路层.assets/image-20210321200728032.png" alt="image-20210321200728032" style="zoom:80%;" /><p>总结：**先听后发 → 边听边发 → 冲突停止 → 延迟后发 **</p><p>​    </p><h2 id="五、集线器"><a href="#五、集线器" class="headerlink" title="五、集线器"></a>五、集线器</h2><p><img src="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.assets/image-20210321201453233.png" alt="image-20210321201453233"></p><p>集线器仅仅将计算机之间的连接由总线方式改变为星型结构；在逻辑上仍然是一个总线网，各工作站使用的还是 CSMA&#x2F;CD 协议，并共享逻辑上的总线。是一个物理层的设备。</p><p><strong>集线器和交换机的区别：</strong></p><ol><li><p>工作层次：   </p><p>集线器工作在物理层，采用广播的方式发送数据，因此网络性能会受到限制；</p><p>交换机工作在数据链路层，通过学习后每个端口形成一张 MAC地址转发表，根据数据包的 MAC地址转发数据，而不是广播形式；</p></li><li><p>转发方式：</p><p>集线器工作原理是广播形式，无论哪个端口收到数据之后，都要广播到所有的端口，当接入设备比较多时，网络性能就会受到影响；</p><p>交换机根据 MAC地址转发数据，受到数据包之后，检查报文的目的MAC地址，找到对应的端口进行转发；</p></li><li><p>传输模式：</p><p>集线器内部采用总线型拓扑结构，各个节点公用一条总线通信，数据包的发送和接收采用 CSMA&#x2F;CD 协议，在同一时间必须是单向的，只能维持在半双工模式下。</p><p>交换机上两个端口进行通信时，它们之间的通道是相互独立的，可以进行全双工通信。</p></li></ol><img src="/passageImg/计算机网络_数据链路层.assets/image-20210321210839931.png" alt="image-20210321210839931" style="zoom:80%;" /><h2 id="六、交换机"><a href="#六、交换机" class="headerlink" title="六、交换机"></a>六、交换机</h2><h3 id="1-交换机使用了生成树协议"><a href="#1-交换机使用了生成树协议" class="headerlink" title="1.交换机使用了生成树协议"></a>1.交换机使用了生成树协议</h3><p>(1) 存在的问题：</p><p>当增加了冗余链路时，交换机自学习的过程就可能导致以太网帧在网络的某个环路中无限制地兜圈子。这样就在网络中产生了环路；</p><p>例如 主机A的数据帧的目的地址为1号端口，那么就会通过交换机一的3号端口转发给交换机二的1号端口；</p><p>同时交换机二接收到数据帧后发现目的MAC地址为4号端口，那么又会通过交换机二的2号端口发送给交换机一的4号端口，这样就形成了回路。数据帧会在交换机一和交换机二之间来回不停地传输，这样就消耗掉了很多资源。</p><img src="/passageImg/计算机网络_数据链路层.assets/image-20210325180049945.png" alt="image-20210325180049945" style="zoom:67%;" /><p>(2) 解决方案：</p><p>IEEE 802.1 标准制定了一个生成树协议 STP(Spanning Tree Protocol)。</p><p>在不改变网络拓扑结构的前提下，在逻辑上切断某些链路，使得一台主机到其他所有主机的路径是无环路的树状结构，从而消除了兜圈子的现象。</p><h3 id="2-虚拟局域网"><a href="#2-虚拟局域网" class="headerlink" title="2. 虚拟局域网"></a>2. 虚拟局域网</h3><blockquote><p>当多个主机处在不同的局域网环境中，它们是不能直接进行数据交换的；但是通过连接在同一个虚拟局域网环境下，多个主机之间能够通过广播的形式交换数据。</p></blockquote><img src="/passageImg/计算机网络_数据链路层.assets/image-20210325181145180.png" alt="image-20210325181145180" style="zoom:67%;" /><p>如图，A1、A2、A3、A4处于同一虚拟局域网 VLAN1中，它们虽然没有连接在同一以太网交换机上但是仍然能够交换数据信息；</p><p>A1、A2、B1、C1虽然连接在同一交换机下，但是所处的虚拟局域网不同，因此不能交换数据。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码解读</title>
      <link href="/2021/01/10/Java%E6%BA%90%E7%A0%81_HashMap%E6%BA%90%E7%A0%81/"/>
      <url>/2021/01/10/Java%E6%BA%90%E7%A0%81_HashMap%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="一、JDK-1-7-的HashMap"><a href="#一、JDK-1-7-的HashMap" class="headerlink" title="一、JDK 1.7 的HashMap"></a>一、JDK 1.7 的HashMap</h2><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt;</span><br><span class="line">         <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; </span><br><span class="line">         <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure><ul><li>HashMap 继承了 AbstractMap 抽象类，实现了 Cloneable、Serializable接口。HashMap的拷贝是一种浅拷贝，即拷贝对象的改变会影响到原对象；HashMap是线程不安全的，不保证插入的键值对有序，但是允许存储键为null的值；HashTable是线程安全的，但是不能存储键为 null的值。</li><li>jdk 1.7 中的HashMap 是基于 数组+链表 的模式构建的。虽然 HashMap定义了hash函数来避免冲突，但是还是会存在两个 key在计算后桶的位置一样，因此考虑使用 链表的方式解决冲突；</li></ul><span id="more"></span><ul><li>结构： Entry节点(包括键、值、next、hash)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry &#123;</span><br><span class="line">    <span class="comment">/** 键对象*/</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">/** 值对象*/</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">/** 指向下一个Entry对象*/</span></span><br><span class="line">    Entry next;</span><br><span class="line">    <span class="comment">/** 键对象哈希值*/</span></span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><ul><li>由于是数组组成，因此 O(1)的平均查找、插入、删除时间；</li></ul><img src="/passageImg/Java源码解读.assets/1628a5174a8f1f3a" alt="img" style="zoom: 50%;" /><table><thead><tr><th>结构</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>数组（主）</td><td>（1）底层的核心是数组(table[]) ，数组中存储的是结点Entry。                                                                             （2）数组的下标是经过处理的键Key的hash值。                                                                                                                                  （3）数组元素 &#x3D; 1个Entry结点 &#x3D; hash值+key+value+next指针 &#x3D; 1个链表头结点                                                            （4）数组大小 &#x3D; HashMap的容量</td><td></td></tr><tr><td>单链表（辅）</td><td>（1）每个链表 &#x3D; 哈希表的桶（bucket）                                                                                                                                  （2）链表的结点值 &#x3D;  1个键值对                                                                                                                                               （3）链表长度 &#x3D; 桶的大小</td><td>链表的主要作用是用来解决Hash冲突的。发生冲突时，新元素插入到链表头中；新元素总是添加到数组中，旧元素移动到单链表中。</td></tr><tr><td></td><td>HashMap的键值对数量 &#x3D; 数组中的键值对数量 + 链表中的键值对数量</td><td></td></tr></tbody></table><h3 id="2-重要参数"><a href="#2-重要参数" class="headerlink" title="2. 重要参数"></a>2. 重要参数</h3><p>重要参数包括三个： 容量、负载因子、扩容阈值</p><h5 id="容量："><a href="#容量：" class="headerlink" title="容量："></a>容量：</h5><p>容量（Capicity）是指 HashMap中的数组长度；而 Size 指的是HashMap中存储的键值对的数量；</p><p>容量的范围必须是 2的整数次幂；最大容量是 2^30；初始容量是 16；</p><h5 id="负载因子："><a href="#负载因子：" class="headerlink" title="负载因子："></a>负载因子：</h5><p>负载因子是用来描述 HashMap在扩容前能够存储达到多满的一种程度；</p><p>负载因子越大，说明能够填满的元素越多，空间利用率就越高，但是相对应的Hash冲突的概率就会越大；</p><p>负载因子越小，说明能填满的元素越少，空间利用率越低，对应Hash越不容易冲突，查找效率更高。</p><h5 id="扩容阈值："><a href="#扩容阈值：" class="headerlink" title="扩容阈值："></a>扩容阈值：</h5><p>当容量 &gt; 扩容阈值时需要进行扩容操作。</p><p>扩容是将 当前容量扩大为原容量的2倍，从而使哈希表具有2倍的桶数；</p><p>扩容阈值 &#x3D; 容量大小 × 负载因子  ，默认为 12</p><h3 id="3-构造方法分析"><a href="#3-构造方法分析" class="headerlink" title="3. 构造方法分析"></a>3. 构造方法分析</h3><p>构造方法包括四种，默认构造方法、根据容量进行初始化、根据容量和负载因子进行初始化、根据子Map进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定容量及负载因子构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="comment">//校验初始容量</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity:&quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">//当初始容量超过最大容量，初始容量为最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="comment">//校验初始负载因子    </span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="comment">//设置负载因子</span></span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">//设置扩容阈值</span></span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">        <span class="comment">//空方法，让其子类重写例如LinkedHashMap</span></span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认构造方法，采用默认容量16，默认负载因子0.75</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定容量构造方法，负载因子默认0.75</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据子Map进行初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置容量大小 &amp; 加载因子 = 默认</span></span><br><span class="line">        <span class="built_in">this</span>(Math.max((<span class="type">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该方法用于初始化 数组 &amp; 阈值，下面会详细说明</span></span><br><span class="line">        inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将传入的子Map中的全部元素逐个添加到HashMap中</span></span><br><span class="line">        putAllForCreate(m);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>重点：</strong>构造方法初始化只是设置了初始容量大小（capicity）、负载因子（Load factor），并没有真正的初始化哈希表。哈希表中数组的初始化，必须等到第一次 <code>put()</code>操作时进行。</p><h3 id="4-插入-put-方法分析"><a href="#4-插入-put-方法分析" class="headerlink" title="4. 插入 put() 方法分析"></a>4. 插入 put() 方法分析</h3><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1jMDkwMmU5MjM3Yzg0YzBkLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 源码分析：主要分析： HashMap的put函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span></span><br><span class="line">（分析<span class="number">1</span>）<span class="comment">// 1. 若 哈希表未初始化（即 table为空) </span></span><br><span class="line">        <span class="comment">// 则使用 构造函数时设置的阈值(即初始容量) 初始化 数组table  </span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123; </span><br><span class="line">        inflateTable(threshold); </span><br><span class="line">    &#125;  </span><br><span class="line">        <span class="comment">// 2. 判断key是否为空值null</span></span><br><span class="line">（分析<span class="number">2</span>）<span class="comment">// 2.1 若key == null，则将该键-值 存放到数组table 中的第1个位置，即table [0]</span></span><br><span class="line">        <span class="comment">// （本质：key = Null时，hash值 = 0，故存放到table[0]中）</span></span><br><span class="line">        <span class="comment">// 该位置永远只有1个value，新传进来的value会覆盖旧的value</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line"></span><br><span class="line">（分析<span class="number">3</span>） <span class="comment">// 2.2 若 key ≠ null，则计算存放数组 table 中的位置（下标、索引）</span></span><br><span class="line">        <span class="comment">// a. 根据键值key计算hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        <span class="comment">// b. 根据hash值 最终获得 key对应存放的数组Table中位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 判断该key对应的值是否已存在（通过遍历 以该数组元素为头结点的链表 逐个判断）</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">（分析<span class="number">4</span>）<span class="comment">// 3.1 若该key已存在（即 key-value已存在 ），则用 新value 替换 旧value</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue; <span class="comment">//并返回旧的value</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">（分析<span class="number">5</span>）<span class="comment">// 3.2 若 该key不存在，则将“key-value”添加到table中</span></span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>分析一、哈希表为空时进行初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inflateTable</span><span class="params">(<span class="type">int</span> toSize)</span> &#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 将传入的容量大小转化为：&gt;传入容量大小的最小的2的次幂</span></span><br><span class="line">    <span class="comment">// 即如果传入的是容量大小是19，那么转化后，初始化容量大小为32（即2的5次幂）</span></span><br><span class="line">    <span class="comment">// 初始时传入的是阈值12，大于它的最小的2的整数次幂就是16，即默认容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> roundUpToPowerOf2(toSize);-&gt;&gt;分析<span class="number">1</span>   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 重新计算阈值 threshold = 容量 * 加载因子  </span></span><br><span class="line">    threshold = (<span class="type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用计算后的初始容量（已经是2的次幂） 初始化数组table（作为数组长度）</span></span><br><span class="line">    <span class="comment">// 即 哈希表的容量大小 = 数组大小（长度）</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity]; <span class="comment">//用该容量初始化table  </span></span><br><span class="line"></span><br><span class="line">    initHashSeedAsNeeded(capacity);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析1：roundUpToPowerOf2(toSize)</span></span><br><span class="line"><span class="comment">     * 作用：将传入的容量大小转化为：&gt;传入容量大小的最小的2的幂</span></span><br><span class="line"><span class="comment">     * 特别注意：容量大小必须为2的幂，该原因在下面的讲解会详细分析</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">roundUpToPowerOf2</span><span class="params">(<span class="type">int</span> number)</span> &#123;  </span><br><span class="line">   </span><br><span class="line">       <span class="comment">//若 容量超过了最大值，初始化容量设置为最大值 ；否则，设置为：&gt;传入容量大小的最小的2的次幂</span></span><br><span class="line">       <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY  ? </span><br><span class="line">            MAXIMUM_CAPACITY  : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><strong>分析二、当key为null时，将key-value插入到数组的第一个位置 table[0]</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">private</span> V <span class="title function_">putForNullKey</span><span class="params">(V value)</span> &#123;  </span><br><span class="line">        <span class="comment">// 遍历以table[0]为首的链表，寻找是否存在key==null 对应的键值对</span></span><br><span class="line">        <span class="comment">// 1. 若有：则用新value 替换 旧value；同时返回旧的value值</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;  </span><br><span class="line">          <span class="keyword">if</span> (e.key == <span class="literal">null</span>) &#123;   </span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    modCount++;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 .若无key==null的键，那么调用addEntry（），将空键 &amp; 对应的值封装到Entry中，并放到table[0]中</span></span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="literal">null</span>, value, <span class="number">0</span>); </span><br><span class="line">    <span class="comment">// 注：</span></span><br><span class="line">    <span class="comment">// a. addEntry（）的第1个参数 = hash值 = 传入0</span></span><br><span class="line">    <span class="comment">// b. 即 说明：当key = null时，也有hash值 = 0，所以HashMap的key 可为null</span></span><br><span class="line">    <span class="comment">// c. 对比HashTable，由于HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null</span></span><br><span class="line">    <span class="comment">// d. 此处只需知道是将 key-value 添加到HashMap中即可，关于addEntry（）的源码分析将等到下面再详细说明，</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line"></span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><p><strong>分析三、计算键值对实际在哈希表中应该存储的位置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数使用原型</span></span><br><span class="line"><span class="comment">     * 主要分为2步：计算hash值、根据hash值再计算得出最后数组位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="comment">// a. 根据键值key计算hash值 -&gt;&gt; 分析1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        <span class="comment">// b. 根据hash值 最终获得 key对应存放的数组Table中位置 -&gt;&gt; 分析2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 源码分析1：hash(key)</span></span><br><span class="line"><span class="comment">     * 该函数在JDK 1.7 和 1.8 中的实现不同，但原理一样 = 扰动函数 = 使得根据key生成的哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）</span></span><br><span class="line"><span class="comment">     * JDK 1.7 做了9次扰动处理 = 4次位运算 + 5次异或运算</span></span><br><span class="line"><span class="comment">     * JDK 1.8 简化了扰动函数 = 只做了2次扰动 = 1次位运算 + 1次异或运算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">        h ^= k.hashCode(); </span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）</span></span><br><span class="line">      <span class="comment">// 1. 取hashCode值： h = key.hashCode() </span></span><br><span class="line">     <span class="comment">//  2. 高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16)  </span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">           <span class="type">int</span> h;</span><br><span class="line">            <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">            <span class="comment">// a. 当key = null时，hash值 = 0，所以HashMap的key 可为null      </span></span><br><span class="line">            <span class="comment">// 注：对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null</span></span><br><span class="line">            <span class="comment">// b. 当key ≠ null时，则通过先计算出 key的 hashCode()（记为h），然后 对哈希码进行 扰动处理： 按位 异或（^） 哈希码自身右移16位后的二进制</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数源码分析2：indexFor(hash, table.length)</span></span><br><span class="line"><span class="comment">     * JDK 1.8中实际上无该函数，但原理相同，即具备类似作用的函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">      <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;  </span><br><span class="line">          <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); </span><br><span class="line">          <span class="comment">// 将对哈希码扰动处理后的结果 与运算(&amp;) （数组长度-1），最终得到存储在数组table的位置（即数组下标、索引）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS04NGU5NTAzZmI0OWM0NmFiLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA" alt="示意图"></p><p><strong>关键点：</strong>计算哈希码，通过扰动函数去二次处理哈希码，最后用 <code>h&amp;(length-1)</code> 来计算最终的存储位置。</p><p><strong>问题（1）：</strong>为什么不采用经过扰动处理的 hashcode 作为最终的存储位置？</p><blockquote><p>因为经过扰动处理的哈希码的范围可能与数组长度不匹配，这样存储就会出现错误。因此要想办法将哈希码的范围约束在数组长度范围内。</p><p>一般想到的解决方案就是将 hash值对 数组范围取模（求余运算）。但是 JDK7中并没有这么做，而是采用了与运算（&amp;）：<code>h &amp; (length-1)</code>来得到最终的存储下标。</p></blockquote><p><strong>问题（2）：</strong>为什么采用哈希码和数组长度-1 与运算来计算数组的下标？</p><blockquote><p>我认为关键有两点：</p><p>​        <strong>1. 提高运算效率：</strong></p><p>与运算的实质是采用取模运算，即用 Hash值对数组长度取模 <code>h % length</code>，但是由于求余运算的效率很低，因此采用与运算来提高效率。而且由于数组的长度为2的整数次幂，那么 <code>h &amp; (length-1)</code>实质上是用 <strong>哈希码与length-1 个1进行与运算，结果就是哈希码对应长度为 length-1 低位的部分</strong>。</p><p>​        <strong>2. 保证哈希码的均匀性：</strong></p><p>因为下标的求解方法是：将hash值和 数组长度-1 进行与运算。当长度为2^n时，数组长度减1后得到的所有位都为1，那么与运算的结果就是 hash值，一定程度上减小了碰撞的几率；</p><p>而如果不是 2^n，那么数组长度-1 后一定会产生0位，0 和任何数求与都为0，那么无论hash值为何值，对应该位为1时的那个位置的桶会一直空着。</p></blockquote><p><strong>问题（3）：</strong>为什么在计算数组下标前，需要对哈希码进行二次处理(扰动处理)？</p><blockquote><p>扰动处理的目的就是为了让哈希码分布的更加均匀，使得存储在hashmap中的数组位置更加均匀，从而避免出现 hash冲突。</p></blockquote><p><strong>问题（4）：</strong>为什么数组的长度一定为 2^n ？</p><blockquote><p> 因为下标的求解方法是：将hash值和 数组长度-1 进行与运算。当长度为2^n时，数组长度减1后得到的所有位都为1，那么与运算的结果就是 hash值，一定程度上减小了碰撞的几率；</p><p>而如果不是 2^n，那么数组长度-1 后一定会产生0位，0 和任何数求与都为0，那么无论hash值为何值，对应该位为1时的那个位置的桶会一直空着。</p></blockquote><p><strong>分析四、若对应的key已经存在，就使用新value去替换旧value</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">    Object k;</span><br><span class="line">    <span class="comment">// 2.1 若该key已存在（即 key-value已存在 ），则用 新value 替换 旧value</span></span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> oldValue; <span class="comment">//并返回旧的value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modCount++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2 若 该key不存在，则将“key-value”添加到table中</span></span><br><span class="line">addEntry(hash, key, value, i);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>方法很简单，就是顺序查找链表，找到对应值进行覆盖即可。</p><p><strong>分析五、若对应的key不存在，就将该key-value添加到数组对应位置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//若 该key对应的值不存在，则将“key-value”添加到table中</span></span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 源码分析：addEntry(hash, key, value, i)</span></span><br><span class="line"><span class="comment">     * 作用：添加键值对（Entry ）到 HashMap中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;  </span><br><span class="line">          <span class="comment">// 参数3 = 插入数组table的索引位置 = 数组下标</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 1. 插入前，先判断容量是否足够</span></span><br><span class="line">          <span class="comment">// 1.1 若不足够，则进行扩容（2倍）、重新计算Hash值、重新计算存储数组下标</span></span><br><span class="line">          <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;  </span><br><span class="line">            resize(<span class="number">2</span> * table.length); <span class="comment">// a. 扩容2倍  --&gt; 分析1</span></span><br><span class="line">            hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;  <span class="comment">// b. 重新计算该Key对应的hash值</span></span><br><span class="line">            bucketIndex = indexFor(hash, table.length);  <span class="comment">// c. 重新计算该Key对应的hash值的存储数组下标位置</span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 若容量足够，则创建1个新的数组元素（Entry） 并放入到数组中--&gt; 分析2</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析1：resize(2 * table.length)</span></span><br><span class="line"><span class="comment">   * 作用：当容量不足时（容量 &gt; 阈值），则扩容（扩到2倍）</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 保存旧数组（old table） </span></span><br><span class="line">    Entry[] oldTable = table;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 保存旧容量（old capacity ），即数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 若旧容量已经是系统默认最大容量了，那么将阈值设置成整型的最大值，退出    </span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  </span><br><span class="line">        threshold = Integer.MAX_VALUE;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 4. 根据新容量（2倍容量）新建1个数组，即新table  </span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 将旧数组上的数据（键值对）转移到新table中，从而完成扩容 -&gt;&gt;分析1.1 </span></span><br><span class="line">    transfer(newTable); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 新数组table引用到HashMap的table属性上</span></span><br><span class="line">    table = newTable;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 重新设置阈值  </span></span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析1.1：transfer(newTable); </span></span><br><span class="line"><span class="comment">   * 作用：将旧数组上的数据（键值对）转移到新table中，从而完成扩容</span></span><br><span class="line"><span class="comment">   * 过程：按旧链表的正序遍历链表、在新链表的头部依次插入</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">      <span class="comment">// 1. src引用了旧数组</span></span><br><span class="line">      Entry[] src = table; </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 获取新数组的大小 = 获取新容量大小                 </span></span><br><span class="line">      <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 通过遍历 旧数组，将旧数组上的数据（键值对）转移到新数组中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123; </span><br><span class="line">        <span class="comment">// 3.1 取得旧数组的每个元素  </span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];           </span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 3.2 释放旧数组的对象引用（for循环后，旧数组不再引用任何对象）</span></span><br><span class="line">              src[j] = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line">              <span class="keyword">do</span> &#123; </span><br><span class="line">                  <span class="comment">// 3.3 遍历 以该数组元素为首 的链表</span></span><br><span class="line">                  <span class="comment">// 注：转移链表时，因是单链表，故要保存下1个结点，否则转移后链表会断开</span></span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next; </span><br><span class="line">                 <span class="comment">// 3.4 重新计算每个元素的存储位置</span></span><br><span class="line">                 <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity); </span><br><span class="line">                 <span class="comment">// 3.5 将元素放在数组上：采用单链表的头插入方式 = 在链表头上存放数据 = 将数组位置的原有数据放在后1个指针、将需放入的数据放到数组位置中</span></span><br><span class="line">                 <span class="comment">// 即 扩容后，可能出现逆序：按旧链表的正序遍历链表、在新链表的头部依次插入</span></span><br><span class="line">                 e.next = newTable[i]; </span><br><span class="line">                 newTable[i] = e;  </span><br><span class="line">                 <span class="comment">// 3.6 访问下1个Entry链上的元素，如此不断循环，直到遍历完该链表上的所有节点</span></span><br><span class="line">                 e = next;             </span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">             <span class="comment">// 如此不断循环，直到遍历完数组上的所有数据元素</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析2：createEntry(hash, key, value, bucketIndex);  </span></span><br><span class="line"><span class="comment">   * 作用： 若容量足够，则创建1个新的数组元素（Entry） 并放入到数组中</span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 把table中该位置原来的Entry保存  </span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 在table中该位置新建一个Entry：将原头结点位置（数组上）的键值对 放入到（链表）后1个节点中、将需插入的键值对 放入到头结点中（数组上）-&gt; 从而形成链表</span></span><br><span class="line">    <span class="comment">// 即 在插入元素时，是在链表头插入的，table中的每个位置永远只保存最新插入的Entry，旧的Entry则放入到链表中（即 解决Hash冲突）</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 哈希表的键值对数量计数增加</span></span><br><span class="line">    size++;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  创建新结点时会检查是否需要进行扩容(阈值12)；如果需要就将容量扩大为原来的2倍，然后将旧数组中的值转移到新数组(会重新计算hash和下标点进行插入)，数据转移过程使用的是头插法(头插法在多线程环境下会造成死锁问题)。</p><p><strong>问题（1）：</strong>transfer 为什么采用头插而不是尾插？为什么不用二维数组解决冲突？</p><blockquote><p>因为后插入的数据被使用的频次更高，而单链表无法随机访问只能从头开始遍历查询，所以采用头插.突然又想为什么不采用二维数组的形式利用线性探查法来处理冲突，数组末尾插入也是O(1)，可数组其最大缺陷就是在于若不是末尾插入删除效率很低，其次若添加的数据分布均匀那么每个桶上的数组都需要预留内存.</p></blockquote><p><strong>问题（2）：</strong>头插法为什么造成死锁问题？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transfer() 方法重要部分</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; next = e.next; <span class="comment">// &lt;--假设线程一执行到这里就被调度挂起了</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">    e.next = newTable[i];</span><br><span class="line">    newTable[i] = e;</span><br><span class="line">    e = next;</span><br><span class="line">&#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><img src="/passageImg/Java源码解读.assets/HashMap01.jpg" alt="img"  /><p>单线程下：当HashMap 被扩容后，key值为 7和3的节点分别插入到了下标为3的位置。</p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/HashMap02.jpg" alt="img"></p><p>多线程下：如果线程1执行到第一句被挂起了；此时线程2将整个插入操作执行完了（key:7 放在了 key:3的前面）；此时如果线程1又被调度，执行<code>e.next= newTable[i]</code>又会将7连接在3的尾部，这样就形成了环。那么如果对环进行查找时(找一个不存在的量)就会造成死锁。</p><h3 id="5-扩容操作-resize-分析"><a href="#5-扩容操作-resize-分析" class="headerlink" title="5. 扩容操作 resize()分析"></a>5. 扩容操作 resize()分析</h3><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wMDBlMDg4MzFjNDViNjZjLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA" alt="示意图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 保存旧数组（old table） </span></span><br><span class="line">    Entry[] oldTable = table;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 保存旧容量（old capacity ），即数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 若旧容量已经是系统默认最大容量了，那么将阈值设置成整型的最大值，退出    </span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  </span><br><span class="line">        threshold = Integer.MAX_VALUE;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 4. 根据新容量（2倍容量）新建1个数组，即新table  </span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 将旧数组上的数据（键值对）转移到新table中，从而完成扩容 -&gt;&gt;分析1.1 </span></span><br><span class="line">    transfer(newTable); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 新数组table引用到HashMap的table属性上</span></span><br><span class="line">    table = newTable;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 重新设置阈值  </span></span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>扩容操作首先会复制出一个大小为原数组大小二倍的新数组。然后需要遍历旧数组中的每个值，采用和<code>put()</code>方法相同的方式，重新计算每个数据在新数组中的存储位置<code>h &amp; (length-1)</code>，然后将旧数组的值转移到新数组中。对于旧数组的链表结点，在新数组中采用头插法进行插入。最后重新计算扩容阈值，重新计算需要插入数据对应的hash值，然后进行插入。</p><p>JDK7 中为了防止 hash 碰撞引起的拒绝服务攻击，在计算 hash 的过程中引入了随机种子。以增强 hash 的随机性，使得键值对均匀分布在桶数组中。在扩容过程中，相关方法会根据容量判断是否需要生成新的随机种子，并重新计算所有节点的hash。</p><h3 id="6-获取数据-get-方法分析"><a href="#6-获取数据-get-方法分析" class="headerlink" title="6. 获取数据 get() 方法分析"></a>6. 获取数据 get() 方法分析</h3><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03OGNmMjFkZjRmMzM1MzE5LnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA" alt="示意图"></p><p><code>get()</code> 方法原理和<code>put()</code> 方法类似，都是根据 key计算hash值，然后扰乱处理，结合数组长度计算最终的存放位置。然后到该存放位置去查找，如果找到了就返回，否则就没有找到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析1：getForNullKey()</span></span><br><span class="line"><span class="comment">   * 作用：当key == null时，则到 以哈希表数组中的第1个元素（即table[0]）为头结点的链表去寻找对应 key == null的键</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line"><span class="keyword">private</span> V <span class="title function_">getForNullKey</span><span class="params">()</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历以table[0]为头结点的链表，寻找 key==null 对应的值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从table[0]中取key==null的value值 </span></span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="literal">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> e.value; </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析2：getEntry(key)</span></span><br><span class="line"><span class="comment">   * 作用：当key ≠ null时，去获得对应值</span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 根据key值，通过hash（）计算出对应的hash值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 根据hash值计算出对应的数组下标</span></span><br><span class="line">    <span class="comment">// 3. 遍历 以该数组下标的数组元素为头结点的链表所有节点，寻找该key对应的值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  e != <span class="literal">null</span>;  e = e.next) &#123;  </span><br><span class="line"></span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="comment">// 若 hash值 &amp; key 相等，则证明该Entry = 我们要的键值对</span></span><br><span class="line">        <span class="comment">// 通过equals（）判断key是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;  </span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">            <span class="keyword">return</span> e;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>HashMap的关键点主要包括： 数据结构+重要参数+重点方法</p><ul><li>数据结构和核心参数</li></ul><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1jZDUzMTk5YzQ2MjNlZWZhLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA" alt="示意图"></p><ul><li>添加、查询数据操作</li></ul><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS04NjJkYWQ4ZmQxMDAxMjc5LnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA" alt="示意图"></p><h2 id="二、JDK-1-8-的HashMap"><a href="#二、JDK-1-8-的HashMap" class="headerlink" title="二、JDK 1.8 的HashMap"></a>二、JDK 1.8 的HashMap</h2><p>JDK8 中的 hashMap相较于 JDK7做出了很大的改变，主要包括 数据结构、插入查找方法、扩容操作这三个方面。</p><h3 id="1-数据结构-1"><a href="#1-数据结构-1" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p>JDK8 采用的是 数组+链表+红黑树 来实现的。</p><p><strong>为什么要引入红黑树？</strong></p><p>​        因为如果像 JDK7 那样，采用链地址法解决哈希冲突，那么当链表长度过长时查找是非常耗时的。因此引入红黑树的结构来加快查找过程，并且根据链表的长度来控制链表和红黑树之间的转化，这样一方面提高了查找的效率（时间复杂度从 O(n) 减少为了 O(logn)）；另一方面又不至于浪费很多资源空间。</p><p><strong>如何转化？</strong></p><ul><li><p>没有冲突时，完全采用数组存储；</p></li><li><p>当出现冲突时，优先使用链表进行存储，如果此时链表长度 &lt;8  ，会一直使用链表存储；</p></li><li><p>当出现冲突，并且链表长度 &gt;&#x3D;8 时，存储结构转化为红黑树；当链表长度小于6时又会变回链表存储。</p></li></ul><p><strong>红黑树的特点？</strong></p><ul><li><p>红黑树本质上是一棵二叉搜索树，因此查找的时间复杂度为 O(logn)，效率很高。</p></li><li><p>红黑树每个结点不是红色就是黑色，而且父子结点必须是不同的颜色。根节点和叶子节点都是黑色。</p></li><li><p>从1个结点到该子孙结点的所有路径上包含相同数量的黑色结点，因此红黑树是相对接近平横二叉树。</p></li></ul><h3 id="2-重要结构"><a href="#2-重要结构" class="headerlink" title="2. 重要结构"></a>2. 重要结构</h3><p>主要看一下 Node结点和 TreeNode结点</p><p><code>Node结点</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;    <span class="comment">//哈希值</span></span><br><span class="line">        <span class="keyword">final</span> K key;       <span class="comment">//key值</span></span><br><span class="line">        V value;           <span class="comment">//value值</span></span><br><span class="line">        Node&lt;K,V&gt; next;    <span class="comment">//链表下一个结点</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Node结点和 JDK7 中的结点结构完全类似。</p><p><code>TreeNode 结点：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父结点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;    <span class="comment">// 左子树</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;   <span class="comment">// 右子树</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// 前一个结点</span></span><br><span class="line">    <span class="type">boolean</span> red;           <span class="comment">// 结点颜色</span></span><br><span class="line">    TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-重要变量"><a href="#3-重要变量" class="headerlink" title="3. 重要变量"></a>3. 重要变量</h3><p>由于引入了红黑树，因此也引入了一些与红黑树相关的临界变量。</p><p>（1）桶的树化阈值，即链表转化为红黑树的阈值，当链表长度大于该值时，将链表转化为红黑树</p><p><code>static final int TREEIFY_THRESHOLD = 8;</code></p><p>（2）桶的还原阈值，当原有红黑树中的结点数小于6时，转换回链表</p><p><code>static final int UNTREEIFY_THRESHOLD = 6;</code></p><p>（3）最小树化容量阈值，当哈希表中的容量大于该值时，才允许进行树化。为树化阈值的4倍</p><p><code>static final int MIN_TREEIFY_CAPACITY = 64;</code></p><h3 id="4-插入-put-方法分析-1"><a href="#4-插入-put-方法分析-1" class="headerlink" title="4. 插入 put() 方法分析"></a>4. 插入 put() 方法分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d70bb28ea42" alt="示意图"></p><h4 id="4-1-哈希的计算方式"><a href="#4-1-哈希的计算方式" class="headerlink" title="4.1 哈希的计算方式"></a>4.1 哈希的计算方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK8 中的 hash计算方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK7 中的 hash计算方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    h ^= k.hashCode(); </span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>JDK7 中总共采用了9次扰动处理，包括4次位运算、5次异或运算；</p><p>JDK8 中总共采用了2次扰动处理，包括1次位运算、1次异或运算；</p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d70cf5e0917" alt="示意图"></p><p><strong>问题（1）：这里计算 hash值为什么采用  <code>key.hashcode() ^  h&gt;&gt;&gt;16</code> 这种方式？</strong></p><p>因为如果直接使用 hashcode 去进行 <code>index = key.hashcode() &amp; (n-1)</code>运算来计算最终的存储位置，那么相当于 hashcode 的高位都没有用到 (因为n为2的整数次幂，减一后低位都1，高位都为0，0和任何数与运算都为0)；简单的来说，直接使用 hashcode 去计算最终位置会使得取余的计算结果只对低位有效，当hash 值高位变化时低位不变，取余结果仍然一样，容易发生哈希冲突。</p><p>因为哈希值为32位，那么如果我将整个hash 值右移16位，得到的结果就是哈希值的高16位；再将高16位和低16位进行异或运算，那就相当于用到了整个 hash部分。无论此时是 hash的高位还是低位发生改变，最终的 hash求余结果一定会发生改变，巧妙地避免了哈希冲突。</p><h4 id="4-2-putVal-方法分析"><a href="#4-2-putVal-方法分析" class="headerlink" title="4.2 putVal() 方法分析"></a>4.2 putVal() 方法分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//tab:旧的数组   i:根据hash计算后的存储位置  p:存储位置对应的结点   n:数组长度</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果数组未初始化，先进行数组初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果对应存储位置没有值，生成一个结点插入</span></span><br><span class="line"> <span class="comment">// i = (n-1) &amp; hash  操作类似于 JDK7 中的 indexFor()函数，都是根据hash值和数组长度计算最终位置</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 否则存在hash冲突</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果对应位置的key相同，用新值覆盖旧值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 否则判断当前的数据结构，如果是红黑树的结构</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 否则是链表存储的结构,那么需要遍历的同时记录节点个数，如果大于了8就要转化为红黑树的结构</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// binCount 就是用来记录结点个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 遍历到了链表末尾，说明没有找到，就在末尾插入新结点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 判断结点个数是否大于8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到了链表中的对应结点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 更新p指向下一个结点，继续遍历</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对于i情况的后续操作，发现key已存在，就用新value覆盖旧value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d70ef1a145c" alt="示意图"></p><p>JDK8 与 JDK7 的插入操作有了很大的不同：</p><ol><li><p>第一步都是判断数组是否被初始化，没有初始化就进行初始化（容量大小为大于输入数值的最小的2的整数次幂）；</p></li><li><p>第二步就是根据 key 计算应该存放的位置，这里的计算方法和JDK7 也不相同，主要体现在扰动函数上，只进行了2次扰动处理；</p></li><li><p>如果该位置没有值就生成一个新的结点插入；否则有值但是 key可能相同，这样的话进行覆盖就可以了。</p></li><li><p>但是如果 key不相同却有值，说明存在hash冲突（不同的key经过计算得到相同的存储位置）；就需要根据此时的存储数据结构进行判断，如果是红黑树就采用红黑树的方式插入然后调整；如果是链表就查找链表中是否已经存在，存在就覆盖，不存在就在链表尾插入一个新的。</p><p>但是注意链表超过一定长度是需要转化为红黑树进行存储的，因此遍历链表的过程中还需要记录链表的位置，源码中使用<code>binCount</code>进行记录。记录完毕后判断是否需要变换结构。</p></li><li><p>最后判断是否需要进行扩容处理，如果当前键值对的数量大于扩容阈值，就采用 <code>resize()</code> 方法进行扩容。扩容操作接下来分析。</p></li></ol><h3 id="5-扩容操作-resize-分析-1"><a href="#5-扩容操作-resize-分析-1" class="headerlink" title="5. 扩容操作 resize() 分析"></a>5. 扩容操作 resize() 分析</h3><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d70f4301afd" alt="示意图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法会在数组初始化和扩容时被调用 </span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      <span class="comment">//oldTab：旧表    oldThr：旧的阈值    oldCap：旧的容量  </span></span><br><span class="line">    </span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">      <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 数组已经进行了初始化</span></span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果旧容量大于最大容量，则不能进行扩容处理</span></span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 否则容量扩大为之前的2倍</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 初始化数组</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 新的扩容阈值为空，就进行重新计算并初始化</span></span><br><span class="line">      <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 将原数组中的值复制到新数组中</span></span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                  oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                </span><br><span class="line">                  <span class="comment">// 原数组中单个结点重新计算hash值存储</span></span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  <span class="comment">// 如果是红黑树结点</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                  <span class="comment">// 如果是链表结点</span></span><br><span class="line">                  <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                      Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          </span><br><span class="line">                          <span class="comment">// 原hash值的最高位的上一位如果为0，则采用原索引</span></span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="comment">//采用尾插法</span></span><br><span class="line">                              <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="comment">// 否则为1，采用新索引</span></span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                      <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                          loTail.next = <span class="literal">null</span>;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                          hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>重点在重新计算数组中元素在新数组中的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原hash值的最高位的上一位如果为0，则采用原索引</span></span><br><span class="line"><span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">    loHead = e;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    loTail.next = e;</span><br><span class="line">  loTail = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则为1，采用新索引</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">    hiHead = e;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    hiTail.next = e;</span><br><span class="line">  hiTail = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码，这里只存在两种情况，要么仍然是原位置，要么是原位置+原数组的长度作为新位置。</p><p>因为扩容后容量为原来的2倍，相当于把容量的2进制值往左移动1位。在计算存储位置 <code>i = (n-1) &amp; hash</code>时，<code>n-1</code> 的二进制比原来的二进制高位多了一个1，那么原hash 值与这个1相与结果就可能是1或者0了。如果是0，则新计算的存储位置和原存储位置相同；如果是1，新存储位置 &#x3D; 原长度+原来的存储位置。</p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d7111482968" alt="示意图"></p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d711301a22e" alt="示意图"></p><h3 id="6-获取数据-get-方法分析-1"><a href="#6-获取数据-get-方法分析-1" class="headerlink" title="6. 获取数据 get() 方法分析"></a>6. 获取数据 get() 方法分析</h3><p>获取数据类似于插入操作，包括计算存储位置，判断存储的数据结构然后去对应位置查找。</p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d71332fc308" alt="示意图"></p><h3 id="7-总结-1"><a href="#7-总结-1" class="headerlink" title="7. 总结"></a>7. 总结</h3><ul><li>数据结构</li></ul><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d713a14fa7a" alt="示意图"></p><ul><li>添加、查询数据流程</li></ul><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d713e10dfce" alt="示意图"></p><ul><li>扩容机制</li></ul><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d714a3472fe" alt="示意图"></p><h2 id="三、JDK7-和-JDK8-HashMap的区别"><a href="#三、JDK7-和-JDK8-HashMap的区别" class="headerlink" title="三、JDK7 和 JDK8  HashMap的区别"></a>三、JDK7 和 JDK8  HashMap的区别</h2><h3 id="3-1-数据结构不同"><a href="#3-1-数据结构不同" class="headerlink" title="3.1 数据结构不同"></a>3.1 数据结构不同</h3><p>JDK7 的数据结构为 数组+链表，当发生哈希冲突时采用链地址法解决冲突；缺点是当冲突过多导致链表过长时，对链表中数据的查询效率非常低；</p><p>JDK8 的数据结构为 数组+链表+红黑树，当发生哈希冲突时优先采用链表解决冲突，但是如果链表的长度大于8，就要将结构转换为红黑树，红黑树的查找时间复杂度为 O(logn) 比 链表的 O(n) 在结点很多的情况下要好很多。如果链表长度低于6时，就没必要使用红黑树了，此时将红黑树转换回链表结构。</p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d714525211d" alt="示意图"></p><h3 id="3-2-插入数据、获取数据"><a href="#3-2-插入数据、获取数据" class="headerlink" title="3.2 插入数据、获取数据"></a>3.2 插入数据、获取数据</h3><p>JDK7 的插入数据首先会检查数组是否初始化，初始化完毕后判断key是否为空，为空直接插在数组第一个位置；然后根据 key对应的哈希值进行扰动处理，这里的扰动处理包括4次位运算和5次异或运算；紧接着根据 <code>index = h &amp; (length-1)</code> 计算出最终的插入位置；如果该位置没有冲突，直接插入；否则需要插入到单链表中，这就涉及到了扩容操作，在扩容之后又重新计算需要插入的数据的位置进行插入。<strong>是先扩容后计算插入位置进行插入</strong></p><p>JDK8 的插入数据首先也会检查数据是否初始化，初始化完毕后紧接着计算哈希值，哈希值的计算与JDK7不同，是通过采用 <code>hashcode &amp; (hashcode&gt;&gt;&gt;16)</code>计算得到hash值，然后根据 <code>index=h&amp;(length-1)</code>得出最终插入位置。没有冲突直接插入，如果有冲突，判断当前数据结构的类型进行冲突解决，对于链表而言需要特别注意当结点数大于8时需要转化为红黑树的结构。最后插入完毕后判断是否需要进行扩容操作。<strong>是先插入后判断是否需要扩容</strong></p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d7167830234" alt="示意图"></p><h3 id="3-3-扩容机制"><a href="#3-3-扩容机制" class="headerlink" title="3.3 扩容机制"></a>3.3 扩容机制</h3><p>JDK7 中扩容是生成一个大小为原容量2倍的数组，然后重新计算原数组中各个头结点的存储位置，接着插入到新数组中。对于原数组中的链表结构，采用头插法依次插入到新数组中，这种头插法在多线程情况下可能会出现环形链表，因此会出现死循环问题。</p><p>JDK8 中扩容也是生成一个大小为原容量2倍的新数组，然后按照扩容规律计算新位置，不同的是它的位置只有两种情况，一种是原位置、一种是原位置+旧容量；接着采用尾插法插入结点，尾插法保证了即使在多线程情况下也不会出现问题。</p><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d71685c05a4" alt="示意图"></p><h2 id="四、一些面试问题"><a href="#四、一些面试问题" class="headerlink" title="四、一些面试问题"></a>四、一些面试问题</h2><h3 id="4-1-哈希表如何解决哈希冲突？"><a href="#4-1-哈希表如何解决哈希冲突？" class="headerlink" title="4.1 哈希表如何解决哈希冲突？"></a>4.1 哈希表如何解决哈希冲突？</h3><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d717abd5222" alt="示意图"></p><h3 id="4-2-为什么-HashMap中-String、Integer这样的包装类适合作为键？"><a href="#4-2-为什么-HashMap中-String、Integer这样的包装类适合作为键？" class="headerlink" title="4.2 为什么 HashMap中 String、Integer这样的包装类适合作为键？"></a>4.2 为什么 HashMap中 String、Integer这样的包装类适合作为键？</h3><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d71ad453bf9" alt="示意图"></p><h3 id="4-3-HashMap中的key若为Object类型，需要实现哪些方法？"><a href="#4-3-HashMap中的key若为Object类型，需要实现哪些方法？" class="headerlink" title="4.3 HashMap中的key若为Object类型，需要实现哪些方法？"></a>4.3 HashMap中的key若为Object类型，需要实现哪些方法？</h3><p><img src="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d71b496f303" alt="示意图"></p><h3 id="4-4-HashMap的链表大小超过8个时会自动转化为红黑树，当小于6个时会转换为链表，为什么呢？"><a href="#4-4-HashMap的链表大小超过8个时会自动转化为红黑树，当小于6个时会转换为链表，为什么呢？" class="headerlink" title="4.4 HashMap的链表大小超过8个时会自动转化为红黑树，当小于6个时会转换为链表，为什么呢？"></a>4.4 HashMap的链表大小超过8个时会自动转化为红黑树，当小于6个时会转换为链表，为什么呢？</h3><p>因为根据泊松分布的原理，单个桶中结点个数大于8的概率小于百万分之一，所以将7作为一个分水岭，大于等8时转换为红黑树进行存储；小于等于6时转换回链表的结构。</p><p>参考文章：</p><p><a href="https://juejin.cn/post/6844903589236703239#heading-1">Java集合——HashMap（jdk1.7）</a></p><p><a href="https://coolshell.cn/articles/9606.html">《疫苗：Java HashMap的死循环》的相关评论</a></p><p><a href="https://segmentfault.com/a/1190000039367730?utm_source=tag-newest#HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84">[彻底拿下HashMap面试问题！！！]</a></p><p><a href="http://www.codeinn.net/misctech/1718.html">HashMap常见面试题汇总（一）</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码解读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ(一)、基础入门</title>
      <link href="/2020/12/20/RabbitMQ_%E5%85%A5%E9%97%A8/"/>
      <url>/2020/12/20/RabbitMQ_%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么叫做消息队列"><a href="#一、什么叫做消息队列" class="headerlink" title="一、什么叫做消息队列"></a>一、什么叫做消息队列</h2><p>消息（Message）指在应用间传输的数据。消息包含 数字、文本、更复杂的嵌入对象等等。</p><p>消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传输。消息发布者只管把消息发送到 MQ 中而不管谁来取，消费者只管从 MQ 中拿消息而不管谁发送的消息。消息的发送和接收都不知道双方的存在。</p><span id="more"></span><h2 id="二、消息队列出现的原因"><a href="#二、消息队列出现的原因" class="headerlink" title="二、消息队列出现的原因"></a>二、消息队列出现的原因</h2><p>消息队列是一种异步协作的机制。</p><p>比如说订单系统，一般订单涉及的业务操作包括：扣减库存、生成订单信息、发红包、发送短信提示等。业务量较少时这些操作可以放在一起同步执行，但随着业务量的增多，需要提升系统的服务性能，这时可以将一些不需要立即生效的操作单独抽取出来异步执行。比如说 发红包、发短信提示 这两个操作可以不用那么急，这种情况下使用 MQ，在下单的主流程（扣减库存、生成订单信息）完成后发送一条消息到 MQ　让主流程快速完结，而另外的由单独的线程拉取  MQ 的消息，当发现 MQ 中有对应的消息时进行执行。</p><blockquote><p>常用场景包括： 最终一致性、广播、错峰流控等。</p></blockquote><h2 id="三、RabbitMQ-特点"><a href="#三、RabbitMQ-特点" class="headerlink" title="三、RabbitMQ 特点"></a>三、RabbitMQ 特点</h2><blockquote><p>RabbitMQ 是一款由 Erlang 语言开发的 AMQP 的开源实现。</p></blockquote><p>AMQP： Advanced Message Queue，高级消息队列协议。它是应用层协议的一个标准。</p><p>RabbitMQ 主要特性如下：</p><ol><li>可靠性（Reliability）RabbitMQ 使用一些机制来保证可靠性，比如持久化、传输确认、发布确认。</li><li>灵活的路由（Flexible Routing）在消息进入消息队列之前，通过 Exchange交换机来路由消息。对于典型的路由功能，已经有了一些内置的交换机来实现；但是对于更复杂的路由，可以将多个交换机绑定到一起来实现。</li><li>消息集群（Clustering）多个RabbitMQ 服务器可以组合成为一个集群。</li><li>高可用（High Available Queues）队列可以在集群中的服务器上进行镜像，使得部分结点在出现问题的情况下队列仍然可以使用。</li><li>多种协议（Multi-protocol）RabbitMQ 支持多种消息队列协议，如 STOMP、MQTT。</li><li>多语言客户端（Many Clients）RabbitMQ 支持多种常用的语言。</li><li>管理界面、跟踪机制、插件机制。</li></ol><h2 id="四、RabbitMQ-中的概念"><a href="#四、RabbitMQ-中的概念" class="headerlink" title="四、RabbitMQ 中的概念"></a>四、RabbitMQ 中的概念</h2><h3 id="4-1-消息模型"><a href="#4-1-消息模型" class="headerlink" title="4.1 消息模型"></a>4.1 消息模型</h3><p><img src="/passageImg/RabbitMQ.assets/161260568dd200d6"></p><h3 id="4-2-RabbitMQ-基本概念"><a href="#4-2-RabbitMQ-基本概念" class="headerlink" title="4.2 RabbitMQ 基本概念"></a>4.2 RabbitMQ 基本概念</h3><p><img src="/passageImg/RabbitMQ.assets/161260568dd66584"></p><ol><li>Message 消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</li><li>Publisher 消息的生产者，也是一个向交换器发布消息的客户端应用程序。</li><li>Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</li><li>Binding 绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li><li>Queue 消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li><li>Connection 网络连接，比如一个TCP连接。</li><li>Channel 信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</li><li>Consumer 消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</li><li>Virtual Host 虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。</li><li>Broker 表示消息队列服务器实体。</li></ol><h2 id="五、AMQP-中的消息路由"><a href="#五、AMQP-中的消息路由" class="headerlink" title="五、AMQP 中的消息路由"></a>五、AMQP 中的消息路由</h2><p>AMQP 中增加了 Exchange 交换机和 Binding 的角色。生产者把消息发送到交换机，由 Binging 和路由键共同决定消息应该发往哪个队列。</p><p>Exchange 根据分发消息时的类型有着不同的发送策略。总共四种类型：direct、fanout、topic、headers。</p><p>headers匹配的不是路由键而是消息的 header，但是用的很少。</p><h3 id="5-1-Direct"><a href="#5-1-Direct" class="headerlink" title="5.1 Direct"></a>5.1 Direct</h3><p><img src="/passageImg/RabbitMQ.assets/161260568dc498b6"></p><p>如果消息头中的 路由键和 Binding 中的 binding key一致，交换器就将消息发送到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。</p><h3 id="5-2-Fanout"><a href="#5-2-Fanout" class="headerlink" title="5.2 Fanout"></a>5.2 Fanout</h3><p><img src="/passageImg/RabbitMQ.assets/161260568fe5ce35"></p><p>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p><h3 id="5-3-Topic"><a href="#5-3-Topic" class="headerlink" title="5.3 Topic"></a>5.3 Topic</h3><p><img src="/passageImg/RabbitMQ.assets/161260569051565f"></p><p>topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“<em>”。#匹配0个或多个单词，</em>匹配不多不少一个单词。</p><h2 id="六、RabbitMQ-的运行"><a href="#六、RabbitMQ-的运行" class="headerlink" title="六、RabbitMQ 的运行"></a>六、RabbitMQ 的运行</h2><p>找到 RabbitMQ 安装后的 sbin 目录，里面有一个 rabbitmq-server 可执行文件，执行即可。</p><h3 id="6-1-启动-RabbitMQ"><a href="#6-1-启动-RabbitMQ" class="headerlink" title="6.1 启动 RabbitMQ"></a>6.1 启动 RabbitMQ</h3><p><code>./sbin/rabbitmq-server</code>：启动</p><p><code>./sbin/rabbitmq-server -detached</code>：后台启动</p><h3 id="6-2-查看-RabbitMQ-服务器状态信息"><a href="#6-2-查看-RabbitMQ-服务器状态信息" class="headerlink" title="6.2 查看 RabbitMQ 服务器状态信息"></a>6.2 查看 RabbitMQ 服务器状态信息</h3><p><code>./sbin/rabbitmqctl status</code>：查询 RabbitMQ 服务器的状态信息</p><h3 id="6-3-关闭-RabbitMQ-结点"><a href="#6-3-关闭-RabbitMQ-结点" class="headerlink" title="6.3 关闭 RabbitMQ 结点"></a>6.3 关闭 RabbitMQ 结点</h3><p>RabbitMQ 是使用 Erlang 语言写的，在 Erlang中有两个概念：<strong>结点和应用程序</strong>。结点就是 Erlang虚拟机的每个实例，而多个 Erlang 应用程序可以运行在同一个结点上。结点之间可以进行本地通信（不管它们是不是运行在同一台服务器上）。比如一个运行在结点A上的应用程序可以调用运行在B上的应用程序的方法。如果应用程序由于某些原因出现崩溃，Erlang 就会自动尝试重启。</p><p>关闭整个 RabbitMQ 结点：<code>./sbin/rabbitmqctl stop</code></p><p>也可以关闭远程结点： <code>./sbin/rabbitmqctl -n rabbit@server.example.com stop</code></p><p>-n node 默认 node 名称是 rabbit@server ，如果你的主机名是 server.example.com ，那么 node 名称就是 <a href="mailto:&#114;&#x61;&#98;&#x62;&#105;&#116;&#64;&#x73;&#101;&#114;&#118;&#x65;&#114;&#x2e;&#101;&#x78;&#x61;&#109;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;">&#114;&#x61;&#98;&#x62;&#105;&#116;&#64;&#x73;&#101;&#114;&#118;&#x65;&#114;&#x2e;&#101;&#x78;&#x61;&#109;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;</a> 。</p><h3 id="6-4-关闭-RabbitMQ-应用程序"><a href="#6-4-关闭-RabbitMQ-应用程序" class="headerlink" title="6.4 关闭 RabbitMQ 应用程序"></a>6.4 关闭 RabbitMQ 应用程序</h3><p>如果只想关闭 RabbitMQ 应用程序同时保持 Erlang 结点的运行，可以使用 stop_app</p><p><code>./sbin/rabbitmqctl stop_app</code></p><h3 id="6-5-启动-RabbitMQ-应用程序"><a href="#6-5-启动-RabbitMQ-应用程序" class="headerlink" title="6.5 启动 RabbitMQ 应用程序"></a>6.5 启动 RabbitMQ 应用程序</h3><p><code>./sbin/rabbitmqctl start_app</code></p><h3 id="6-6-重置-RabbitMQ-结点"><a href="#6-6-重置-RabbitMQ-结点" class="headerlink" title="6.6  重置 RabbitMQ 结点"></a>6.6  重置 RabbitMQ 结点</h3><p><code>./sbin/rabbitmqctl reset</code>    该命令会清除所有队列</p><h3 id="6-7-查看已经声明的队列"><a href="#6-7-查看已经声明的队列" class="headerlink" title="6.7  查看已经声明的队列"></a>6.7  查看已经声明的队列</h3><p><code>./sbin/rabbitmqctl list_queues</code></p><h3 id="6-8-查看交换器"><a href="#6-8-查看交换器" class="headerlink" title="6.8  查看交换器"></a>6.8  查看交换器</h3><p><code>./sbin/rabbitmqctl list_exchanges</code></p><p>该命令还可以附带参数，比如交换器的名称、类型、是否持久化是否自动删除</p><p><code>./sbin/rabbitmqctl list_exchanges name type durable auto_delete</code></p><h3 id="6-9-查看绑定"><a href="#6-9-查看绑定" class="headerlink" title="6.9  查看绑定"></a>6.9  查看绑定</h3><p><code>./sbin/rabbitmqctl list_bindings</code></p><h2 id="七、RabbitMQ-的安装"><a href="#七、RabbitMQ-的安装" class="headerlink" title="七、RabbitMQ 的安装"></a>七、RabbitMQ 的安装</h2><h3 id="7-1-下载-erlang"><a href="#7-1-下载-erlang" class="headerlink" title="7.1 下载 erlang"></a>7.1 下载 erlang</h3><p><a href="https://www.erlang.org/downloads/22.3">https://www.erlang.org/downloads/22.3</a></p><p>版本参照 rabbitMQ 官网的对应版本</p><h3 id="7-2-下载-RabbitMQ"><a href="#7-2-下载-RabbitMQ" class="headerlink" title="7.2  下载 RabbitMQ"></a>7.2  下载 RabbitMQ</h3><p><img src="/passageImg/RabbitMQ.assets/image-20210409150610436.png"></p><img src="/passageImg/RabbitMQ.assets/image-20210409150627460.png" alt="image-20210409150627460" style="zoom: 50%;" /><h3 id="7-3-上传服务器并解压"><a href="#7-3-上传服务器并解压" class="headerlink" title="7.3 上传服务器并解压"></a>7.3 上传服务器并解压</h3><p>注意 RabbitMQ压缩包为 .xz 格式，要先用 xz 命令进行解压为 .tar 文件，然后使用 tar 命令进行解压</p><p><code>xz -d rabbitmq-server-generic-unix-3.7.16.tar.xz</code>：解压 .xz 文件</p><p><code>tar -xvf rabbitmq-server-generic-unix-3.7.16.tar</code>：解压 .tar 文件</p><p>然后在 &#x2F;usr&#x2F;local 下创建一个 RabbitMQ文件夹用来存储RabbitMQ 软件运行时的数据等等，并将解压后的文件也移动到当前文件夹下。</p><h3 id="7-4-安装-Erlang"><a href="#7-4-安装-Erlang" class="headerlink" title="7.4 安装 Erlang"></a>7.4 安装 Erlang</h3><ol><li>安装 Erlang 编译所依赖的环境</li></ol><p><code>yum install make gcc gcc-c++ build-essential openssl openssl-devel unixODBC unixODBC-devel kernel-devel m4 ncurses-devel</code></p><ol start="2"><li>在 &#x2F;usr&#x2F;local 目录下创建一个erlang文件夹，因为erlang编译安装默认是装在&#x2F;usr&#x2F;local下的bin和lib中，这里我们将他统一装到&#x2F;usr&#x2F;local&#x2F;erlang中，方便查找和使用</li></ol><p><code>mkdir -p /usr/local/erlang</code></p><ol start="3"><li>编译Erlang</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd otp_src_22.0/        #进入Erlang目录下</span><br><span class="line">./configure --prefix=/usr/local/erlang --without-javac   #编译 erlang，这里不要使用java编译器了</span><br></pre></td></tr></table></figure><ol start="4"><li>安装 Erlang</li></ol><p><code>make &amp;&amp; make install</code></p><ol start="5"><li>配置 Erlang 环境变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> vim /etc/profile           <span class="comment">//编译环境配置文件</span></span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line"><span class="comment">//添加如下信息</span></span><br><span class="line">   export ERLANG_HOME=/usr/local/erlang</span><br><span class="line">   export PATH=$&#123;ERLANG_HOME&#125;/bin:$&#123;PATH&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让配置生效</span></span><br><span class="line">   source /etc/profile</span><br></pre></td></tr></table></figure><ol start="6"><li>创建软连接</li></ol><p><code> ln -s /usr/local/erlang/bin/erl /usr/local/bin/erl</code></p><h3 id="7-5-安装-RabbitMQ"><a href="#7-5-安装-RabbitMQ" class="headerlink" title="7.5 安装 RabbitMQ"></a>7.5 安装 RabbitMQ</h3><ol><li>配置环境变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile    <span class="comment">//切换到目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加如下信息</span></span><br><span class="line">export RABBITMQ_HOME=/usr/local/RabbitMQ_Softwork/rabbitmq_server-<span class="number">3.8</span><span class="number">.11</span></span><br><span class="line">export PATH=$&#123;RABBITMQ_HOME&#125;/sbin:$&#123;PATH&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>开启web 管理界面</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切换到 sbin 目录下</span></span><br><span class="line">cd /usr/local/RabbitMQ_Softwork/rabbitmq_server-<span class="number">3.8</span><span class="number">.11</span>/sbin</span><br><span class="line">  </span><br><span class="line"><span class="comment">//开启管理界面</span></span><br><span class="line">./rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><ol start="3"><li>设置开机启动</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rc.d/rc.local</span><br><span class="line">  </span><br><span class="line"><span class="comment">//添加如下代码到 rc.local 文件中</span></span><br><span class="line"><span class="comment">//注意：1.手动启动，用户登陆后会去加载/etc/profile中的配置文件中 Erlang和RabbitMQ环境</span></span><br><span class="line"><span class="comment">//     2.开机启动，在系统识别用户前加载配置文件中的环境。</span></span><br><span class="line">   </span><br><span class="line">source /etc/profile     <span class="comment">//表示加载配置文件</span></span><br><span class="line">/usr/local/RabbitMQ_Softwork/rabbitmq_server-<span class="number">3.8</span><span class="number">.11</span>/sbin/rabbitmq-server -detached  <span class="comment">//后台启动</span></span><br></pre></td></tr></table></figure><ol start="4"><li>后台启动 RabbitMQ</li></ol><p><code>/usr/local/RabbitMQ_Softwork/rabbitmq_server-3.8.11/sbin/rabbitmq-server -detached</code></p><h3 id="7-6-浏览器访问-RabbitMQ"><a href="#7-6-浏览器访问-RabbitMQ" class="headerlink" title="7.6 浏览器访问 RabbitMQ"></a>7.6 浏览器访问 RabbitMQ</h3><p>浏览器端口 15672访问 RabbitMQ web管理界面，初始用户名和密码都为 guest</p><p><img src="/passageImg/RabbitMQ.assets/image-20210409162025317.png"></p><p>可以看到Login failed (登录失败)，User can only log in via localhost (用户只能通过本地主机登录)，因为rabbitmq从3.3.0开始禁止使用guest&#x2F;guest管理员权限通过除localhost外的访问</p><p>解决方案：重新创建用户，设置权限进行登录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加用户</span></span><br><span class="line">rabbitmqctl add_user root <span class="number">123456</span>           <span class="comment">//创建用户名为root 密码为123456的用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给用户设置标签</span></span><br><span class="line">rabbitmqctl set_user_tags root administrator</span><br><span class="line">  </span><br><span class="line"><span class="comment">//查看所有用户列表</span></span><br><span class="line">rabbitmqctl list_users</span><br><span class="line">  </span><br><span class="line"><span class="comment">//但是这样只能登录，无权访问虚拟主机，需要添加权限操作</span></span><br><span class="line"><span class="comment">//给root用户在虚拟主机&quot;/&quot;上的配置、写、读的权限</span></span><br><span class="line">rabbitmqctl set_permissions root -p / <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span></span><br></pre></td></tr></table></figure><img src="/passageImg/RabbitMQ.assets/image-20210409163648224.png" alt="image-20210409163648224" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"># 帮助命令</span><br><span class="line">[root@RabbitMQ ~]# rabbitmqctl help</span><br><span class="line">Error:</span><br><span class="line"></span><br><span class="line">Usage</span><br><span class="line"></span><br><span class="line">rabbitmqctl [--node &lt;node&gt;] [--timeout &lt;timeout&gt;] [--longnames] [--quiet] &lt;command&gt; [&lt;command options&gt;]</span><br><span class="line"></span><br><span class="line">Available commands:</span><br><span class="line"></span><br><span class="line">Help:</span><br><span class="line"></span><br><span class="line">   help                          Displays usage information for a command</span><br><span class="line">   version                       Displays CLI tools version</span><br><span class="line"></span><br><span class="line">Nodes:</span><br><span class="line"></span><br><span class="line">   await_startup                 Waits for the RabbitMQ application to start on the target node</span><br><span class="line">   reset                         Instructs a RabbitMQ node to leave the cluster and return to its virgin state</span><br><span class="line">   rotate_logs                   Instructs the RabbitMQ node to perform internal log rotation</span><br><span class="line">   shutdown                      Stops RabbitMQ and its runtime (Erlang VM). Monitors progress for local nodes. Does not require a PID file path.</span><br><span class="line">   start_app                     Starts the RabbitMQ application but leaves the runtime (Erlang VM) running</span><br><span class="line">   stop                          Stops RabbitMQ and its runtime (Erlang VM). Requires a local node pid file path to monitor progress.</span><br><span class="line">   stop_app                      Stops the RabbitMQ application, leaving the runtime (Erlang VM) running</span><br><span class="line">   wait                          Waits for RabbitMQ node startup by monitoring a local PID file. See also &#x27;rabbitmqctl await_online_nodes&#x27;</span><br><span class="line"></span><br><span class="line">Cluster:</span><br><span class="line"></span><br><span class="line">   await_online_nodes            Waits for &lt;count&gt; nodes to join the cluster</span><br><span class="line">   change_cluster_node_type      Changes the type of the cluster node</span><br><span class="line">   cluster_status                Displays all the nodes in the cluster grouped by node type, together with the currently running nodes</span><br><span class="line">   force_boot                    Forces node to start even if it cannot contact or rejoin any of its previously known peers</span><br><span class="line">   force_reset                   Forcefully returns a RabbitMQ node to its virgin state</span><br><span class="line">   forget_cluster_node           Removes a node from the cluster</span><br><span class="line">   join_cluster                  Instructs the node to become a member of the cluster that the specified node is in</span><br><span class="line">   rename_cluster_node           Renames cluster nodes in the local database</span><br><span class="line">   update_cluster_nodes          Instructs a cluster member node to sync the list of known cluster members from &lt;seed_node&gt;</span><br><span class="line"></span><br><span class="line">Replication:</span><br><span class="line"></span><br><span class="line">   cancel_sync_queue             Instructs a synchronising mirrored queue to stop synchronising itself</span><br><span class="line">   sync_queue                    Instructs a mirrored queue with unsynchronised mirrors (follower replicas) to synchronise them</span><br><span class="line"></span><br><span class="line">Users:</span><br><span class="line"></span><br><span class="line">   add_user                      Creates a new user in the internal database</span><br><span class="line">   authenticate_user             Attempts to authenticate a user. Exits with a non-zero code if authentication fails.</span><br><span class="line">   change_password               Changes the user password</span><br><span class="line">   clear_password                Clears (resets) password and disables password login for a user</span><br><span class="line">   delete_user                   Removes a user from the internal database. Has no effect on users provided by external backends such as LDAP</span><br><span class="line">   list_users                    List user names and tags</span><br><span class="line">   set_user_tags                 Sets user tags</span><br><span class="line"></span><br><span class="line">Access Control:</span><br><span class="line"></span><br><span class="line">   clear_permissions             Revokes user permissions for a vhost</span><br><span class="line">   clear_topic_permissions       Clears user topic permissions for a vhost or exchange</span><br><span class="line">   list_permissions              Lists user permissions in a virtual host</span><br><span class="line">   list_topic_permissions        Lists topic permissions in a virtual host</span><br><span class="line">   list_user_permissions         Lists permissions of a user across all virtual hosts</span><br><span class="line">   list_user_topic_permissions   Lists user topic permissions</span><br><span class="line">   list_vhosts                   Lists virtual hosts</span><br><span class="line">   set_permissions               Sets user permissions for a vhost</span><br><span class="line">   set_topic_permissions         Sets user topic permissions for an exchange</span><br><span class="line"></span><br><span class="line">Monitoring, observability and health checks:</span><br><span class="line"></span><br><span class="line">   environment                   Displays the name and value of each variable in the application environment for each running application</span><br><span class="line">   list_bindings                 Lists all bindings on a vhost</span><br><span class="line">   list_channels                 Lists all channels in the node</span><br><span class="line">   list_ciphers                  Lists cipher suites supported by encoding commands</span><br><span class="line">   list_connections              Lists AMQP 0.9.1 connections for the node</span><br><span class="line">   list_consumers                Lists all consumers for a vhost</span><br><span class="line">   list_exchanges                Lists exchanges</span><br><span class="line">   list_hashes                   Lists hash functions supported by encoding commands</span><br><span class="line">   list_queues                   Lists queues and their properties</span><br><span class="line">   list_unresponsive_queues      Tests queues to respond within timeout. Lists those which did not respond</span><br><span class="line">   ping                          Checks that the node OS process is up, registered with EPMD and CLI tools can authenticate with it</span><br><span class="line">   report                        Generate a server status report containing a concatenation of all server status information for support purposes</span><br><span class="line">   schema_info                   Lists schema database tables and their properties</span><br><span class="line">   status                        Displays status of a node</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line"></span><br><span class="line">   clear_global_parameter        Clears a global runtime parameter</span><br><span class="line">   clear_parameter               Clears a runtime parameter.</span><br><span class="line">   list_global_parameters        Lists global runtime parameters</span><br><span class="line">   list_parameters               Lists runtime parameters for a virtual host</span><br><span class="line">   set_global_parameter          Sets a runtime parameter.</span><br><span class="line">   set_parameter                 Sets a runtime parameter.</span><br><span class="line"></span><br><span class="line">Policies:</span><br><span class="line"></span><br><span class="line">   clear_operator_policy         Clears an operator policy</span><br><span class="line">   clear_policy                  Clears (removes) a policy</span><br><span class="line">   list_operator_policies        Lists operator policy overrides for a virtual host</span><br><span class="line">   list_policies                 Lists all policies in a virtual host</span><br><span class="line">   set_operator_policy           Sets an operator policy that overrides a subset of arguments in user policies</span><br><span class="line">   set_policy                    Sets or updates a policy</span><br><span class="line"></span><br><span class="line">Virtual hosts:</span><br><span class="line"></span><br><span class="line">   add_vhost                     Creates a virtual host</span><br><span class="line">   clear_vhost_limits            Clears virtual host limits</span><br><span class="line">   delete_vhost                  Deletes a virtual host</span><br><span class="line">   list_vhost_limits             Displays configured virtual host limits</span><br><span class="line">   restart_vhost                 Restarts a failed vhost data stores and queues</span><br><span class="line">   set_vhost_limits              Sets virtual host limits</span><br><span class="line">   trace_off                     </span><br><span class="line">   trace_on                      </span><br><span class="line"></span><br><span class="line">Node configuration:</span><br><span class="line"></span><br><span class="line">   decode                        Decrypts an encrypted configuration value</span><br><span class="line">   encode                        Encrypts a sensitive configuration value</span><br><span class="line">   set_cluster_name              Sets the cluster name</span><br><span class="line">   set_disk_free_limit           Sets the disk_free_limit setting</span><br><span class="line">   set_log_level                 Sets log level in the running node</span><br><span class="line">   set_vm_memory_high_watermark  Sets the vm_memory_high_watermark setting</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line"></span><br><span class="line">   export_definitions            Exports definitions in JSON or compressed Erlang Term Format.</span><br><span class="line">   import_definitions            Imports definitions in JSON or compressed Erlang Term Format.</span><br><span class="line"></span><br><span class="line">Deprecated:</span><br><span class="line"></span><br><span class="line">   node_health_check             DEPRECATED. Performs intrusive, opinionated health checks on a fully booted node. See https://www.rabbitmq.com/monitoring.html#health-checks instead</span><br><span class="line"></span><br><span class="line">Feature flags:</span><br><span class="line"></span><br><span class="line">   enable_feature_flag           Enables a feature flag on target node</span><br><span class="line">   list_feature_flags            Lists feature flags</span><br><span class="line"></span><br><span class="line">Operations:</span><br><span class="line"></span><br><span class="line">   close_all_connections         Instructs the broker to close all connections for the specified vhost or entire RabbitMQ node</span><br><span class="line">   close_connection              Instructs the broker to close the connection associated with the Erlang process id</span><br><span class="line">   eval                          Evaluates a snippet of Erlang code on the target node</span><br><span class="line">   exec                          Evaluates a snippet of Elixir code on the CLI node</span><br><span class="line">   force_gc                      Makes all Erlang processes on the target node perform/schedule a full sweep garbage collection</span><br><span class="line">   hipe_compile                  Only exists for backwards compatibility. HiPE support has been dropped starting with Erlang 22. Do not use</span><br><span class="line"></span><br><span class="line">Queues:</span><br><span class="line"></span><br><span class="line">   delete_queue                  Deletes a queue</span><br><span class="line">   purge_queue                   Purges a queue (removes all messages in it)</span><br><span class="line"></span><br><span class="line">Use &#x27;rabbitmqctl help &lt;command&gt;&#x27; to learn more about a specific command</span><br></pre></td></tr></table></figure><h2 id="八、Java客户端访问-RabbitMQ"><a href="#八、Java客户端访问-RabbitMQ" class="headerlink" title="八、Java客户端访问 RabbitMQ"></a>八、Java客户端访问 RabbitMQ</h2><h3 id="消息生产者代码模板"><a href="#消息生产者代码模板" class="headerlink" title="消息生产者代码模板"></a>消息生产者代码模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        factory.setHost(<span class="string">&quot;39.100.119.221&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取信道,声明交换机</span></span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> conn.createChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hello-exchange&quot;</span>;</span><br><span class="line">        channel.exchangeDeclare(exchangeName,<span class="string">&quot;direct&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//声明路由键</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;hola&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.发布消息</span></span><br><span class="line">        <span class="type">byte</span>[] messageBodyBytes = <span class="string">&quot;Hello RabbitMQ&quot;</span>.getBytes();</span><br><span class="line">        channel.basicPublish(exchangeName,routingKey,<span class="literal">null</span>,messageBodyBytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息生产者主要关注的就是生产消息，然后将消息交给交换机。剩下的消息的转接都由交换机去完成。</p><p>消费者传输消息时需要声明交换机的类型，包括（<code>direct</code>、<code>fanout</code>、<code>topic</code>、<code>headers</code>），通过信道来传输数据，因此要建立信道和交换机之间的关联。</p><p>最后需要定义路由键，因为需要通过路由键来绑定交换机和消息队列。</p><h3 id="消息消费者代码模板"><a href="#消息消费者代码模板" class="headerlink" title="消息消费者代码模板"></a>消息消费者代码模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.获取连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        factory.setHost(<span class="string">&quot;39.100.119.221&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="keyword">if</span>(conn!=<span class="literal">null</span>)</span><br><span class="line">            System.out.println(<span class="string">&quot;连接获取成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取信道、声明交换机、声明队列、定义路由键</span></span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> conn.createChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hello-exchange&quot;</span>;</span><br><span class="line">        channel.exchangeDeclare(exchangeName,<span class="string">&quot;direct&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;hola&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过路由键绑定队列与交换机</span></span><br><span class="line">        channel.queueBind(queueName,exchangeName,routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.接收消息</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//消费消息</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">consumerTag</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicConsume(queueName,autoAck,consumerTag,<span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    <span class="comment">//路由键</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> envelope.getRoutingKey();</span><br><span class="line">                    <span class="comment">//消息类型</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> properties.getContentType();</span><br><span class="line">                    System.out.println(<span class="string">&quot;路由键为：&quot;</span>+routingKey);</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息类型为：&quot;</span>+contentType);</span><br><span class="line">                    <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> envelope.getDeliveryTag();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//确认消息</span></span><br><span class="line">                    channel.basicAck(deliveryTag,autoAck);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//消息的内容</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息的内容为：&quot;</span>+message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消费者只关注从队列中获取数据，队列需要和交换机进行绑定，因此需要声明路由键、交换机、队列。</li></ul><p>​        然后通过 <code>channel.queueBind(queueName,exchangeName,routingKey)</code>来绑定交换机和队列。</p><ul><li>消费者接收消息是通过  channel.basicConsume()   方法来进行的，详细介绍如上。</li></ul><p>最后注意Java连接RabbitMQ 是通过 5672 端口进行的，而 15672是浏览器访问 RabbitMQ管理界面的端口，因此需要在Linux中打开 5672 端口。</p><p><img src="/passageImg/RabbitMQ.assets/image-20210409190430799.png"></p><h2 id="九、RabbitMQ-集群"><a href="#九、RabbitMQ-集群" class="headerlink" title="九、RabbitMQ 集群"></a>九、RabbitMQ 集群</h2><h3 id="9-1-为什么使用集群？"><a href="#9-1-为什么使用集群？" class="headerlink" title="9.1 为什么使用集群？"></a>9.1 为什么使用集群？</h3><p>（1）允许消费者和生产者在 RabbitMQ 结点崩溃时仍然能够保证正常的通信；</p><p>（2）增加结点来扩展 RabbitMQ 处理更多的消息，承载更多的业务量。</p><h3 id="9-2-集群的特点"><a href="#9-2-集群的特点" class="headerlink" title="9.2 集群的特点"></a>9.2 集群的特点</h3><blockquote><p>集群是由多个结点组成的，但不是每个结点都有所有队列的完整数据。—— 结点的不完全拷贝性</p></blockquote><ol><li>RabbitMQ 会始终记录以下四种类型的内部数据</li></ol><p>（1）队列元数据   包括队列的名称、属性，比如是否可以持久化，是否自动删除；</p><p>（2）交换机元数据   包括交换机的名称、属性、类型；</p><p>（3）绑定元数据  内部是一张表格，记录如何将消息路由到队列；</p><p>（4）vhost元数据  为vhost 内部的队列、交换机、绑定提供命名空间和安全属性；</p><ol start="2"><li>存储形式的不同</li></ol><p>在单一节点中，RabbitMQ 会将上述的四种类型的元数据存储在内存中，同时将可持久化的队列、交换机、绑定存储到磁盘上。存储到磁盘上保证了重启后能够恢复数据状态；</p><p>在集群中创建队列，只会在<strong>单个节点</strong>上创建完整的队列信息（元数据、状态、内容）。结果是只有队列所有者知道队列有关的所有信息，如果这个结点崩溃，该结点的队列和绑定就消失了，该队列的任何消息也就都消失了。好在  RabbitMQ 2.6.0 之后提供了 镜像队列来避免节点崩溃导致队列不可用的情况。</p><p>如上所说，RabbitMQ 可以共享 user、vhost、exchange等，所有的数据状态都是必须在所有结点上复制的，例外就是队列。</p><p>集群中有内存结点和磁盘结点两种类型，内存结点性能更好、速度更快，但是对于需要持久化的队列、交换机、绑定而言就必须使用磁盘节点，它保证了重启后仍然能够恢复数据。因此<strong>集群中必须至少有1个磁盘节点</strong>，如果这个结点崩溃了，那该集群可以继续路由消息，但是不能创建队列、交换机、绑定，不能创建用户、修改用户权限等等。也就是说如何唯一的磁盘节点崩溃，那么集群仍然可以运行，但是不能更改任何东西直到它恢复。</p><ol start="3"><li>为什么默认情况下不让队列的内容和状态复制到所有结点？</li></ol><p>（1）存储空间 —– 如果将队列的内容和状态复制到所有的结点，那么新增结点反而没有增大容量，而是增加了冗余数据；</p><p>（2）性能 —–  如果需要将消息发布拷贝到每一个结点，那么对于网络负载还有磁盘负载都会有所增加，与建立集群的初衷相违背。</p><h3 id="9-3-集群的异常处理"><a href="#9-3-集群的异常处理" class="headerlink" title="9.3 集群的异常处理"></a>9.3 集群的异常处理</h3><p>如果集群的结点崩溃了，那么该结点的队列和关联的绑定就都丢失了。</p><p>解决办法：如果该结点消息已经进行了持久化，那么等待结点恢复就可以了；</p><p>​                    如果未进行持久化，需要使用双活冗余队列、镜像队列。</p><h3 id="9-4-集群的搭建"><a href="#9-4-集群的搭建" class="headerlink" title="9.4 集群的搭建"></a>9.4 集群的搭建</h3><blockquote><p>这里使用比较热门的方法，使用 docker 来下载启动搭建 rabbitmq 集群</p></blockquote><ol><li>安装 rabbitmq 镜像</li></ol><p><code>docker pull rabbitmq:3.6.15-management</code></p><p>  后面的 -management  是指包含网页控制台的。</p><p>安装成功后使用 <code>docker images</code>来查看现有的镜像。<img src="/passageImg/RabbitMQ.assets/image-20210410142828183.png"></p><p><strong>列举一下Docker常用命令：</strong></p><p>（1）容器启动： docker start  容器名称；</p><p>（2）容器停止： docker stop  容器名称；</p><p>（3）删除容器： docker rm  容器名称&#x2F;容器ID；</p><p>（4）删除镜像： docker rmi  镜像名称&#x2F;镜像ID；</p><p>（5）查看所有镜像：docker images；</p><p>（6）查看运行中的容器：docker ps；</p><p>（7）查看所有容器： docker ps -a；</p><p>（8）进入docker目录：docker exec -it &#x2F;bin&#x2F;bash；</p><p>（9）启动容器：docker run -d  -h hostName -p  HostPort:ContainerPort  –name ContainerName  镜像名&#x2F;镜像ID:tag</p><ol start="2"><li>启动多个 rabbitmq</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动第一个  端口映射 5672:5672 15672:15672</span></span><br><span class="line">docker run -d -p <span class="number">5672</span>:<span class="number">5672</span> -p <span class="number">15672</span>:<span class="number">15672</span> -h rabbit1 -e RABBITMQ_ERLANG_COOKIE=<span class="string">&#x27;rabbitcookie&#x27;</span> --name myrabbit1 rabbitmq:management</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动第二个  端口映射 5673:5672 15673:15672</span></span><br><span class="line">docker run -d -p <span class="number">5673</span>:<span class="number">5672</span> -p <span class="number">15673</span>:<span class="number">15672</span> -h rabbit2 -e RABBITMQ_ERLANG_COOKIE=<span class="string">&#x27;rabbitcookie&#x27;</span> --name myrabbit2 --link myrabbit1:rabbit1 rabbitmq:management</span><br><span class="line">  </span><br><span class="line"><span class="comment">//启动第二个  端口映射 5674:5672 15674:15672</span></span><br><span class="line">docker run -d -p <span class="number">5674</span>:<span class="number">5674</span> -p <span class="number">15674</span>:<span class="number">15674</span> -h rabbit3 -e RABBITMQ_ERLANG_COOKIE=<span class="string">&#x27;rabbitcookie&#x27;</span> --name myrabbit3 --link myrabbit1:rabbit1 --link myrabbit2:rabbit2 rabbitmq:management</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>多个容器之间必须通过 <code>--link</code>进行连接，此属性不能少；</p><p>​             Erlang Cookie 必须相同，原因是：RabbitMQ 是通过 Erlang语言编写的，Erlang Cookie相当于各个结点之间的通信秘钥，Erlang结点通过交换 Erlang Cookie来获取认证。</p><ol start="3"><li>加入RabbitMQ 结点到集群</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置结点1</span></span><br><span class="line">docker exec -it myrabbit1 bash   <span class="comment">//进入容器</span></span><br><span class="line">rabbitmqctl stop_app      <span class="comment">//同步数据</span></span><br><span class="line">rabbitmqctl reset         </span><br><span class="line">rabbitmqctl start_app     </span><br><span class="line">exit</span><br><span class="line">  </span><br><span class="line"><span class="comment">//设置结点2</span></span><br><span class="line">docker exec -it myrabbit2 bash</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster --ram rabbit<span class="meta">@rabbit1</span></span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">exit</span><br><span class="line">  </span><br><span class="line"><span class="comment">//设置结点3</span></span><br><span class="line">docker exec -it myrabbit3 bash</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster --ram rabbit<span class="meta">@rabbit1</span></span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>由于初始时每个结点都是独立的状态，不知道其它结点的存在，因此需要停止程序然后重置结点来同步数据，然后再加入到集群中。   <code>--ram</code> 表示设置为内存结点，忽略此参数默认为磁盘结点</p><ol start="4"><li>这样就启动了3个结点，一个磁盘结点，两个内存结点，3个结点一起构成了 RabbitMQ 集群</li></ol><p><img src="/passageImg/RabbitMQ.assets/image-20210410153619367.png"></p><ol start="5"><li>集群其余操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更改结点类型</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl change_cluster_node_type dist    <span class="comment">//更改为磁盘结点</span></span><br><span class="line">rabbitmqctl change_cluster_node_type ram     <span class="comment">//更改为内存结点</span></span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">  </span><br><span class="line"><span class="comment">//移除结点</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p>集群启动时，先是磁盘结点然后是内存结点(顺序是固定地)；集群关闭时，先是内存结点然后是磁盘结点</p><h2 id="十、镜像队列"><a href="#十、镜像队列" class="headerlink" title="十、镜像队列"></a>十、镜像队列</h2><p><a href="https://blog.csdn.net/u013256816/article/details/71097186">https://blog.csdn.net/u013256816/article/details/71097186</a></p><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/269917155">https://zhuanlan.zhihu.com/p/269917155</a></p><p><a href="https://blog.csdn.net/qq_39135287/article/details/95725385?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/qq_39135287/article/details/95725385?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242</a></p><p><a href="https://juejin.cn/post/6844903554721775629#heading-12">https://juejin.cn/post/6844903554721775629#heading-12</a></p><p><a href="https://www.cnblogs.com/vipstone/p/9362388.html">https://www.cnblogs.com/vipstone/p/9362388.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客剑指offer(20~40题总结)</title>
      <link href="/2020/11/20/%E7%89%9B%E5%AE%A2%E5%89%91%E6%8C%87offer_t20~t40/"/>
      <url>/2020/11/20/%E7%89%9B%E5%AE%A2%E5%89%91%E6%8C%87offer_t20~t40/</url>
      
        <content type="html"><![CDATA[<h2 id="JZ23"><a href="#JZ23" class="headerlink" title="JZ23"></a>JZ23</h2><img src="/passageImg/牛客offer.assets/image-20210325083059996.png" alt="image-20210325083059996" style="zoom:80%;" /><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>二叉搜索树遍历顺序为左右根；而且左子树的所有值都小于根，根的值小于右子树的所有值。</p><p>根据大小关系找出划分点后还需要对右子树的所有值进行比较遍历，在满足二叉搜索树的大小规定后才能再次划分为左子树和右子树进行比较。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTPreOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">VerifySquenceOfBST</span><span class="params">(<span class="type">int</span>[] sequence)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence == <span class="literal">null</span> || sequence.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBST(sequence, <span class="number">0</span>, sequence.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isBST</span><span class="params">(<span class="type">int</span>[] seq, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> seq[end];</span><br><span class="line">        <span class="type">int</span> <span class="variable">split</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="keyword">for</span> (; split &lt; end &amp;&amp; seq[split] &lt; val; split++) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> split; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[i] &lt; val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBST(seq, start, split - <span class="number">1</span>) &amp;&amp;</span><br><span class="line">               isBST(seq, split, end - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目总结："><a href="#题目总结：" class="headerlink" title="题目总结："></a>题目总结：</h3><p>抓住题目的重点，后序遍历+二叉排序树。后序遍历则说明能够立刻确定二叉树的根结点，然后结合二叉排序树的特点，左子树的值一定小于根的值，根的值一定小于右子树的值，满足如上条件即为合法。</p><h2 id="JZ26"><a href="#JZ26" class="headerlink" title="JZ26"></a>JZ26</h2><img src="/passageImg/牛客offer.assets/image-20210325083607003.png" alt="image-20210325083607003" style="zoom:80%;" /><h3 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h3><p>设置一个前驱指针，然后每次当前驱指针的值不空时和后继指针进行连接，然后再变换前驱指针的位置。</p><h4 id="知识回顾：线索二叉树"><a href="#知识回顾：线索二叉树" class="headerlink" title="知识回顾：线索二叉树"></a>知识回顾：线索二叉树</h4><p><img src="/passageImg/t20~t30.assets/20170107155134727" alt="中序线索二叉树"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//节点存储结构</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;   </span><br><span class="line">   String data;          <span class="comment">//数据域</span></span><br><span class="line">   Node left;            <span class="comment">//左指针</span></span><br><span class="line">   Node right;           <span class="comment">//右指针</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isLeftThread</span> <span class="operator">=</span> <span class="literal">false</span>;    <span class="comment">//左指针域类型  false：指向子节点、true：前驱或后继线索</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isRightThread</span> <span class="operator">=</span> <span class="literal">false</span>;   <span class="comment">//右指针域类型  false：指向子节点、true：前驱或后继线索</span></span><br><span class="line">   Node(String data)&#123;</span><br><span class="line">   <span class="built_in">this</span>.data = data;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过数组构造一棵完全二叉树</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> Node <span class="title function_">createBinaryTree</span><span class="params">(String[] array,<span class="type">int</span> index)</span> &#123;</span><br><span class="line">   <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span>(index &lt; array.length) &#123;</span><br><span class="line">   node = <span class="keyword">new</span> <span class="title class_">Node</span>(array[index]);</span><br><span class="line">   node.left = createBinaryTree(array, index*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">   node.right = createBinaryTree(array, index*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 中序线索化二叉树</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">inThreadOrder</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(node == <span class="literal">null</span>)</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">   <span class="comment">//处理左子树</span></span><br><span class="line">   inThreadOrder(node.left);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//处理根节点</span></span><br><span class="line">   <span class="keyword">if</span>(node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">   node.left = preNode;</span><br><span class="line">   node.isLeftThread = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(preNode!=<span class="literal">null</span> &amp;&amp; preNode.right==<span class="literal">null</span>) &#123;</span><br><span class="line">   preNode.right = node;</span><br><span class="line">   preNode.isRightThread = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   preNode = node;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//处理右子树</span></span><br><span class="line">   inThreadOrder(node.right);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 中序遍历线索化二叉树，按照后继方式(找到最左节点开始)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">inThreadList</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">   <span class="comment">//找到最左节点</span></span><br><span class="line">   <span class="keyword">while</span>(node!=<span class="literal">null</span> &amp;&amp; !node.isLeftThread)</span><br><span class="line">   node = node.left;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">//遍历根节点</span></span><br><span class="line">   System.out.println(node.data);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//如果右指针是线索，直接切换</span></span><br><span class="line">   <span class="keyword">if</span>(node.isRightThread)</span><br><span class="line">   node = node.right;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//如果右指针不是线索，则找到右子树对应左子树的线索</span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">   node = node.right;</span><br><span class="line">   <span class="keyword">while</span>(node!=<span class="literal">null</span> &amp;&amp; !node.isLeftThread)</span><br><span class="line">   node = node.left;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 中序遍历二叉树，按照前驱方式(找到最右节点开始)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">preThreadList</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">   <span class="comment">//找到最右节点</span></span><br><span class="line">   <span class="keyword">while</span>(node!=<span class="literal">null</span> &amp;&amp; !node.isRightThread)</span><br><span class="line">   node = node.right;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">//遍历根节点</span></span><br><span class="line">   System.out.println(node.data);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//如果左指针是线索</span></span><br><span class="line">   <span class="keyword">if</span>(node.isLeftThread)</span><br><span class="line">   node = node.left;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">   node = node.left;</span><br><span class="line">   <span class="keyword">while</span>(node.right!=<span class="literal">null</span> &amp;&amp; !node.isRightThread)</span><br><span class="line">   node = node.right;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 前序线索化二叉树</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">preThreadOrder</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(node == <span class="literal">null</span>)</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//处理当前根节点</span></span><br><span class="line">   <span class="keyword">if</span>(node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">   node.left = preNode;</span><br><span class="line">   node.isLeftThread = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(preNode.right==<span class="literal">null</span> &amp;&amp; !preNode.isRightThread) &#123;</span><br><span class="line">   preNode.right = node;</span><br><span class="line">   preNode.isRightThread = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   preNode = node;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//处理左子树</span></span><br><span class="line">   <span class="keyword">if</span>(!node.isLeftThread)</span><br><span class="line">   preThreadOrder(node.left);</span><br><span class="line">   <span class="comment">//处理右子树</span></span><br><span class="line">   <span class="keyword">if</span>(!node.isRightThread)</span><br><span class="line">   preThreadOrder(node.right);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在本题中需要我们构建的是一个双向链表，那就相当于只要 preNode 前驱节点不空，都要将它与后继进行双向连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="literal">null</span>,root = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            root = pRootOfTree;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(preNode!=<span class="literal">null</span>)</span><br><span class="line">            preNode.right = pRootOfTree;</span><br><span class="line">        pRootOfTree.left =  preNode;</span><br><span class="line">        preNode = pRootOfTree;</span><br><span class="line">        </span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目总结：-1"><a href="#题目总结：-1" class="headerlink" title="题目总结："></a>题目总结：</h3><p>线索化二叉树一般和 前序遍历&#x2F;中序遍历 结合使用，通过维护一个 preNode 来代表遍历时的前一个结点</p><p>每次移动前都检查当前结点的左子树是否为空，为空就将它的左子树连接到 preNode；相反的我们也需要将 preNode 的右子树连接到当前结点。</p><p>线索化二叉树比较重要，多做多思考。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><img src="/passageImg/牛客offer.assets/image-20210325092048046.png" alt="image-20210325092048046" style="zoom:80%;" /><h2 id="JZ31"><a href="#JZ31" class="headerlink" title="JZ31"></a>JZ31</h2><h3 id="解决方法：-2"><a href="#解决方法：-2" class="headerlink" title="解决方法："></a>解决方法：</h3><p>题目要求求出小于等于n的所有整数中出现 1 的次数，那么进行举例分析。</p><ol><li>假设数字 N 是个x位数，记 N 的第i位 为 Ni，那么可以将 N 写为  NxNx-1Nx-2….N1</li></ol><ul><li>这里称 “Ni” 为当前位，记为 cur；</li><li>将 “Ni-1 Ni-2 Ni-3…N1” 记为低位，记为 low；</li><li>将 “Nx Nx-1 Nx-2… Ni” 记为高位，记为 high:</li><li>将 “10^i” 记为位因子，记为 digit；</li></ul><ol start="2"><li>这里举例计算 数字 2304中十位出现1的次数</li></ol><p>① 当 <code>cur=0</code> 时</p><img src="/passageImg/牛客offer.assets/78e60b6c2ada7434ba69643047758e113fa732815f7c53791271c5e0f123687c-Picture1.png" alt="Picture1.png" style="zoom:67%;" /><p>可以发现此时出现1的次数只与高位有关系， 个数为 <code>high×digit</code></p><p>② 当<code>cur=1</code>时</p><img src="/passageImg/牛客offer.assets/58c7e6472155b49923b48daac10bd438b68e9504690cf45d5e739f3a8cb9cee1-Picture2.png" alt="Picture2.png" style="zoom:67%;" /><p>可以发现此时1的出现与高位和低位都有关系，个数为 <code>high×digit+low+1</code></p><p>③当<code>cur=2,3....9</code>时</p><img src="/passageImg/牛客offer.assets/0e51d37b434ef0ad93882cdcb832f867e18b872833c0c360ad4580eb9ed4aeda-Picture3.png" alt="Picture3.png" style="zoom:67%;" /><p>此时1的出现只与高位有关系，个数为 <code>(high+1)×digit</code></p><p>因此可以总结归纳为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//初始值</span><br><span class="line">high = n/10;</span><br><span class="line">cur = n%10;</span><br><span class="line">low = 0;</span><br><span class="line">digit = 1;</span><br></pre></td></tr></table></figure><p>从低位到高位的递推过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while high!=0 or cur!=0      //这里high和cur不能同时为0，同时为0表示已经结束递推</span><br><span class="line">    low += cur*digit;        //加上cur层的值</span><br><span class="line">    cur = high%10;           //下层cur等于high的最低位</span><br><span class="line">    high = high/10;          //下层high等于high除去最低位</span><br><span class="line">    digit *= 10;             //每次位因子增加10倍</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：   O(logn)，循环内的计算操作使用O(1)时间；循环操作次数是N 的位数，即 log10N；</p><p>空间复杂度： O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n / <span class="number">10</span>, cur = n % <span class="number">10</span>, low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(high != <span class="number">0</span> || cur != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">0</span>) res += high * digit;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="number">1</span>) res += high * digit + low + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> res += (high + <span class="number">1</span>) * digit;</span><br><span class="line">            low += cur * digit;</span><br><span class="line">            cur = high % <span class="number">10</span>;</span><br><span class="line">            high /= <span class="number">10</span>;</span><br><span class="line">            digit *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/">https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/</a></p><h3 id="题目总结：-2"><a href="#题目总结：-2" class="headerlink" title="题目总结："></a>题目总结：</h3><p>找规律</p><h2 id="JZ25"><a href="#JZ25" class="headerlink" title="JZ25"></a>JZ25</h2><img src="/passageImg/牛客offer.assets/image-20210411100048792.png" alt="image-20210411100048792" style="zoom:80%;" /><h3 id="解决方法：-3"><a href="#解决方法：-3" class="headerlink" title="解决方法："></a>解决方法：</h3><p>链表深度拷贝，需要将每个结点重新生成一份而不是简单的复制引用。</p><p>那么可以建立 HashMap哈希表来指明原结点和新结点之间的对应关系。第一次遍历用于创建结点，此时结点间的关系和指向还没有定义，第二次遍历就专门进行关系的定义和指向的说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> RandomListNode <span class="title function_">Clone</span><span class="params">(RandomListNode pHead)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        HashMap&lt;RandomListNode,RandomListNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        RandomListNode h1=pHead,h2=pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(h1!=<span class="literal">null</span>)&#123;</span><br><span class="line">            map.put(h1,<span class="keyword">new</span> <span class="title class_">RandomListNode</span>(h1.label));</span><br><span class="line">            h1=h1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(h2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h2.next != <span class="literal">null</span>)</span><br><span class="line">                map.get(h2).next = map.get(h2.next);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.get(h2).next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(h2.random != <span class="literal">null</span>)</span><br><span class="line">                map.get(h2).random = map.get(h2.random);</span><br><span class="line">            h2 = h2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目总结：-3"><a href="#题目总结：-3" class="headerlink" title="题目总结："></a>题目总结：</h3><p>涉及到深拷贝的问题，如果结点间的关系比较复杂，就可以通过建立 HashTable 来解决。</p><p>第一次遍历用于建立结点；第二次遍历用于定义关系。</p><h2 id="JZ29"><a href="#JZ29" class="headerlink" title="JZ29"></a>JZ29</h2><img src="/passageImg/牛客offer.assets/image-20210411105545609.png" alt="image-20210411105545609" style="zoom:80%;" /><h3 id="解决方法：-4"><a href="#解决方法：-4" class="headerlink" title="解决方法："></a>解决方法：</h3><p>思路很清晰，对数组进行排序即可。但是关键是排序方法的选择。</p><p>快速排序不稳定，时间复杂度最坏可能为 O(n^2)，不考虑；</p><p>归并排序需要用到辅助空间，而且必须达到最底层后才能回溯处理，不考虑；</p><p>堆排序虽然不稳定，但是每一步都能够得出当前的 最大&#x2F;最小值，题目中要求前K 个数，那么不需要对整个数组完全排序，只要取到了前 K个数就退出。因此堆排序最合适。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">GetLeastNumbers_Solution</span><span class="params">(<span class="type">int</span> [] input, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; input.length)</span><br><span class="line">             <span class="keyword">return</span> res;</span><br><span class="line">        HeapSort(input,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 堆排序对堆的调整</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">HeapAdjust</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;=end &amp;&amp; arr[i+<span class="number">1</span>]&lt;arr[i])</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;=tmp)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            arr[start] = arr[i];</span><br><span class="line">            start = i;</span><br><span class="line">            i = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[start] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 堆排序递归交换堆顶和堆尾并重新调整</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            HeapAdjust(arr,i,len-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span> &amp;&amp; k&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            res.add(arr[<span class="number">0</span>]);</span><br><span class="line">            k--;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            HeapAdjust(arr,<span class="number">0</span>,i-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目总结：-4"><a href="#题目总结：-4" class="headerlink" title="题目总结："></a>题目总结：</h3><p>各种排序算法一定要烂熟于心，快排、归并、堆排序尤其重要。</p><p>归并排序在之前的一道题目中出现过，意思是要我们求数组中位于位于前面比它大的数的个数。巧用了归并排序的思想，归并采用分治的思维，在合并的时候是两个有序的数组，而且后面的数组的位置一定是在另一个数组的后面的，那么根据大小关系就能很快求出。</p><p>堆排序在这个题目中体现了它的优势，多刷题多总结。</p><h2 id="JZ33"><a href="#JZ33" class="headerlink" title="JZ33"></a>JZ33</h2><img src="/passageImg/牛客offer.assets/image-20210411210053432.png" alt="image-20210411210053432" style="zoom:80%;" /><h3 id="解决方法：-5"><a href="#解决方法：-5" class="headerlink" title="解决方法："></a>解决方法：</h3><p>题目中定义了丑数的概念，质因子只能是 2、3、5（1除外）。也就是说一个数如果为丑数，那么它就只能通过任意个数的 2、3、5相乘得到。那么我们只需要关注如何将数相乘和如何取值。</p><p><strong>如何将数相乘：</strong><code>丑数*丑数=丑数</code>，每一个丑数都有乘以 2、3、5 的机会，将这些值进行去重剩下的就是新的丑数，那么为了保证每个数都有乘以  2、3、5的机会，需要给 2、3、5各自设置一个指针下标（比如 i、j、k）表示此时乘到哪里了。</p><p><strong>如何取值：</strong>每次加入的丑数都要保证最小，这样才能保证之后的乘法运算不会漏掉值，那么每次三个下标（2、3、5）和当前各自对应的数相乘后取其中的最小值作为当次的结果，并且将当前指针往后移动一位。注意如果当前的结果可以由多个指针对应的数相乘得到，那么各指针都需要往后移动一位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetUglyNumber_Solution</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">int</span> p2=<span class="number">0</span>,p3=<span class="number">0</span>,p5=<span class="number">0</span>;</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.min(list.get(p2)*<span class="number">2</span>, Math.min(list.get(p3)*<span class="number">3</span>, list.get(p5)*<span class="number">5</span>));</span><br><span class="line">    list.add(cur);</span><br><span class="line">    <span class="keyword">if</span>(cur%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    p2++;</span><br><span class="line">    <span class="keyword">if</span>(cur%<span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">    p3++;</span><br><span class="line">    <span class="keyword">if</span>(cur%<span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">    p5++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> list.get(index-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目总结：-5"><a href="#题目总结：-5" class="headerlink" title="题目总结："></a>题目总结：</h3><p>这类数学题型需要仔细分析，分析各个结果的结构规律然后进行求解。</p><h2 id="JZ35"><a href="#JZ35" class="headerlink" title="JZ35"></a>JZ35</h2><img src="/passageImg/牛客offer.assets/image-20210411211418683.png" alt="image-20210411211418683" style="zoom:80%;" /><h3 id="解决方法：-6"><a href="#解决方法：-6" class="headerlink" title="解决方法："></a>解决方法：</h3><p>逆序对的定义：两个数字，前面一个数字大于后面的数字，那么这两个数字组成一个逆序对。逆序对可以看成相对位置间的大小关系的比较。</p><p>这里需要我们联想到归并排序的排序过程，归并排序的思想是分治，分而后治。治的过程就体现了相对位置的排序，因为排序中是两个已经排好序的数组，而且后面一个数组的位置一定是在前一个数组的后面。那么比较的时候，如果前一个数组的某个值大于后面数组当前位置的值，这就是一个逆序对，另外前一个数组是有序递增的，也就是说前一个数组对应位置的后序所有值都比后面数组的当前位置的值要大，这就是很多的逆序对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">InversePairs</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        mergeSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> []array,<span class="type">int</span> start,<span class="type">int</span> mid,<span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> []temp = <span class="keyword">new</span> <span class="title class_">int</span>[end-start+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i=start,j=mid+<span class="number">1</span>,index=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=end) &#123;</span><br><span class="line">    <span class="keyword">if</span>(array[i]&lt;=array[j])</span><br><span class="line">    temp[index++] = array[i++];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    count += (mid-i+<span class="number">1</span>);</span><br><span class="line">                count = count%<span class="number">1000000007</span>;</span><br><span class="line">    temp[index++] = array[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[index++] = array[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=end) temp[index++] = array[j++];</span><br><span class="line">        <span class="keyword">for</span>(index=<span class="number">0</span>;index&lt;temp.length;index++)</span><br><span class="line">        array[start++] = temp[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> []array,<span class="type">int</span> start,<span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> ((end-start)&gt;&gt;<span class="number">1</span>)+start;</span><br><span class="line">    mergeSort(array,start,mid);</span><br><span class="line">    mergeSort(array,mid+<span class="number">1</span>,end);</span><br><span class="line">    merge(array,start,mid,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目总结：-6"><a href="#题目总结：-6" class="headerlink" title="题目总结："></a>题目总结：</h3><p>归并排序的核心用到了分治，分治又是基于保持相对位置的分治；</p><p>堆排序的排序规则则可以用到部分排序中，比如说取一个数组中的前N个最小数等等。</p><h2 id="JZ37"><a href="#JZ37" class="headerlink" title="JZ37"></a>JZ37</h2><img src="/passageImg/牛客offer.assets/image-20210411212546091.png" alt="image-20210411212546091" style="zoom:80%;" /><h3 id="解决方法：-7"><a href="#解决方法：-7" class="headerlink" title="解决方法："></a>解决方法：</h3><p>题目关键词升序数组。一看见有序就立刻联想到二分法。</p><p>二分查找，找到比当前数小一点的值的位置；二分查找，找到比当前数大一点的值；结束</p><p><strong>二分查找如果没有找到完全匹配，那么会返回比当前值稍大一点的值的位置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetNumberOfK</span><span class="params">(<span class="type">int</span> []array,<span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getIndex(array,k+<span class="number">0.5</span>)-getIndex(array,k-<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span> []array,<span class="type">double</span> num)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>,e = array.length-<span class="number">1</span>,mid;</span><br><span class="line"><span class="keyword">while</span>(s &lt;= e) &#123;</span><br><span class="line">mid = (((e-s)&gt;&gt;<span class="number">1</span>)+s);</span><br><span class="line"><span class="keyword">if</span>(array[mid] &gt; num)</span><br><span class="line">e = mid-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; num)</span><br><span class="line">s = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目总结：-7"><a href="#题目总结：-7" class="headerlink" title="题目总结："></a>题目总结：</h3><p>有序数组—–二分法</p><h2 id="JZ39"><a href="#JZ39" class="headerlink" title="JZ39"></a>JZ39</h2><img src="/passageImg/牛客offer.assets/image-20210411213149860.png" alt="image-20210411213149860" style="zoom:80%;" /><h3 id="解决方法：-8"><a href="#解决方法：-8" class="headerlink" title="解决方法："></a>解决方法：</h3><p>既然规定了平衡二叉树的任意结点的左右子树的高度差不能超过1，那么求出来进行比较就可以了。</p><p>要保证当前结点的二叉树是平衡二叉树，需要保证左子树是平衡二叉树、右子树是平衡二叉树、左右子树的深度差不超过1 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> Math.abs(getDepth(root.left)-getDepth(root.right))&lt;=<span class="number">1</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> flag &amp;&amp; IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(getDepth(root.left),getDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目总结：-8"><a href="#题目总结：-8" class="headerlink" title="题目总结："></a>题目总结：</h3><p>比较简单，无</p><h2 id="JZ40"><a href="#JZ40" class="headerlink" title="JZ40"></a>JZ40</h2><img src="/passageImg/牛客offer.assets/image-20210411213606042.png" alt="image-20210411213606042" style="zoom:80%;" /><h3 id="解决方法：-9"><a href="#解决方法：-9" class="headerlink" title="解决方法："></a>解决方法：</h3><p>其它数字都出现了两次，另外两个数字分别出现了1次。</p><p>重复出现去重问题，肯定会联想到哈希表，但是用了就GG了。</p><p>这里介绍另外一种重复去重的方法（异或法，适用于数组全体或大部分重复的情况）。因为异或运算相同为0，不同为1.</p><p><strong>重点！（敲黑板）</strong></p><p>要找出两个数字，需要将数组分组，如果能够保证   ①两个数字分到了不同的组；②相同的数字分到了同一个组；就完成了目的。</p><p>如何分组呢？    这两个数字不同，那么它们的二进制表示法中肯定存在某一位是不同的，如果我们找到这一位，这两个数字按照这一位进行分离。对于其它数字而言，由于存在和它们相同的另外一个数，那么就一定能够分配到同一个数组中。</p><p>最后分别对两个数组进行异或运算求解，由于相同的数字都分配到了同一个组，那么异或后一定为0，因此最后同一组的数据异或的结果一定只剩下单独出现的那个数了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] FindNumsAppearOnce (<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)</span><br><span class="line">        res ^= array[i];</span><br><span class="line">    <span class="keyword">while</span>((res&amp;index)==<span class="number">0</span>)</span><br><span class="line">        index &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num:array)&#123;</span><br><span class="line">        <span class="keyword">if</span>((num&amp;index)==<span class="number">0</span>)</span><br><span class="line">            a ^= num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a,b&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目总结：-9"><a href="#题目总结：-9" class="headerlink" title="题目总结："></a>题目总结：</h3><p>数组去重方法 get —— 异或法</p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（四）、非连续内存分配</title>
      <link href="/2020/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2020/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="非连续内存分配："><a href="#非连续内存分配：" class="headerlink" title="非连续内存分配："></a>非连续内存分配：</h1><h2 id="1-1、为什么需要非连续内存分配："><a href="#1-1、为什么需要非连续内存分配：" class="headerlink" title="1.1、为什么需要非连续内存分配："></a>1.1、为什么需要非连续内存分配：</h2><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200919210923975.png"></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200919210949161.png"></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200919211151381.png"></p><span id="more"></span><h2 id="1-2-分段-Segmentation-："><a href="#1-2-分段-Segmentation-：" class="headerlink" title="1.2 分段(Segmentation)："></a>1.2 分段(Segmentation)：</h2><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200919213307388.png"></p><p>程序的分段地址空间：</p><p>​     <strong>逻辑地址空间是连续的，物理地址是离散的中间需要映射机制来建立联系</strong>。</p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200919211400358.png"></p><p>通过硬件将内存中的不同区域划分，分别分开进行管理。如果用软件来实现就会涉及到拷贝，开销是很大的。</p><p><strong>分段寻址方案：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200919212254391.png"></p><blockquote><p><strong>一个段指一个 “内存块”，是一个逻辑地址空间。</strong>    </p><p>方式一： 采用 段号(s) + 段内偏移(addr)的方式管理，也即是段寄存器+地址寄存器实现方案(x86是典型的例子)；            </p><p>方式二： 是单地址实现方案，此时没有段表寄存器。   在分段管理的过程中，段长<strong>不是固定的</strong>。如果是单地址实现方案则更加简单，没有段表寄存器。<strong>直接拿逻辑地址中的段号</strong>去段表中查，其他步骤和上述一样</p></blockquote><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200921195003487.png"></p><p><strong>硬件实现方案：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200919214314446.png"></p><p>段表中包含  段号(和逻辑地址中的段号相同)、段长(限制段的长度为合理范围)、段的基址(对应物理地址）；</p><p>段表是由操作系统提前建立好的，和硬件有着紧密的联系；</p><h2 id="1-3-分页"><a href="#1-3-分页" class="headerlink" title="1.3 分页"></a>1.3 分页</h2><p><strong>分页和分段的最大区别就是 段的大小是可变的而页的大小是固定的</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200921200352797.png"></p><h3 id="1-3-1-物理地址部分：页帧"><a href="#1-3-1-物理地址部分：页帧" class="headerlink" title="1.3.1 物理地址部分：页帧"></a>1.3.1 物理地址部分：页帧</h3><p><strong>桢(Frame):</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200921201139989.png"></p><blockquote><p>对于一个物理地址，如果已知它的帧号和帧内偏移，就可以根据公式计算得出物理地址</p></blockquote><p><strong>地址计算实例：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200921201917830.png"></p><blockquote><p>每一帧的大小为 512byte，那么总共就由9位来表示帧的大小 S&#x3D;9；</p><p>总共16位，剩余7位就用来表示帧号的大小，F&#x3D;7；</p></blockquote><hr><h3 id="1-3-2-逻辑地址部分：页"><a href="#1-3-2-逻辑地址部分：页" class="headerlink" title="1.3.2 逻辑地址部分：页"></a>1.3.2 逻辑地址部分：页</h3><p><strong>页(page)：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200921204031073.png"></p><blockquote><p>页内偏移大小 &#x3D; 帧内偏移大小</p><p>页号大小 ! &#x3D; 帧号大小</p></blockquote><p><strong>页内寻址方式：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200921205404378.png"></p><blockquote><p>首选虚拟地址包括了页号(p)和页内偏移地址(o)，cpu根据页号去页表中查找对应的内容，页表中存放的是以页号为索引的帧号；查询出帧号后就能根据帧号去计算实际的物理地址了(因为帧的大小是固定的)。</p><p>页表也是由操作系统创建的。</p></blockquote><p><strong>页寻址机制：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200921210013350.png"></p><p><strong>页表结构：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200921210353963.png"></p><blockquote><p>页表项中包含的有标志位(Flags)，用于确定该处的物理物理页帧是否存在；帧号(f)，用于计算对应的物理地址</p></blockquote><p><strong>地址转换实例：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200921211020005.png"></p><blockquote><p>比如页号为4，那么找到页表中对应的为100，这里第二位为贮存位，为0则代表该处的物理页帧不存在，那么此时CPU会发出内存访问异常由操作系统进行处理。</p><p>如果页号为３，对应页表中为011，这里贮存位为1，那么找到对应的页帧号为00100 (4)，则物理地址为(4,1023)。</p></blockquote><hr><h3 id="1-3-3-分页机制的性能问题："><a href="#1-3-3-分页机制的性能问题：" class="headerlink" title="1.3.3 分页机制的性能问题："></a>1.3.3 分页机制的性能问题：</h3><p><strong>分页机制的性能问题：</strong></p><p>&#x3D;&#x3D;1.时间代价：访问一个内存单元需要2次内存访问&#x3D;&#x3D;</p><p>​             一次用于获取页表项；</p><p>​             一次用于访问数据；</p><p>&#x3D;&#x3D;2.空间代价：页表可能非常大&#x3D;&#x3D;</p><blockquote><p>-&gt;访问一个内存单元需要2次内存访问：一次获取页表项；一次是访问数据。<br>-&gt;页表可能会非常大(页表的长度等于2^页号位数)<br>举例，64位机器，如果一页是1024KB，那么页表是多大？<br>假如页号是n位的，那么页表的长度等于2^ n，一页是1024KB，所以页内偏移是10位，一个逻辑地址的长度等于计算机位数，也就是64位，因此剩下的54位是留给页号的；因此页表的长度是2^54，明显CPU装不下。<br>一个程序一个页表，n个程序n个页表，就更大了。<br>CPU装不下，只能装在内存里；如果这样，需要访问2次内存，一次访问页表，一次访问程序。</p></blockquote><p>&#x3D;&#x3D;3.解决方法：&#x3D;&#x3D;</p><pre><code>  * 缓存caching  * 间接访问 indrection</code></pre><p><strong>TLB（缓存）解决访问时间问题：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200921212241380.png"></p><blockquote><p>对于一些经常访问的页表，可以将其对应的页表项存放于TLB快表中，再次访问这些逻辑地址时就会很快，这样就避免了对页表的访问；</p><p>虽然速度快，但是TLB的容量有限，当发生访问缺失时会到页表中进行访问，然后将得到的帧号(f) 返回存储到TLB中；</p><p>TLB实际上是CPU的MMU内存管理单元保存的一段缓存，这段缓存保存的内容是 页表 的一部分，是经常访问到的那部分页表，其余不常用的页表内容保存在内存中。</p><p>TLB未命中，也叫TLB miss，这种情况比较少见，因为一页很大，32位系统一页是4K，如果采用局部性原理，那么访问4k次才会遇到一次TLB miss。对于x86这一类的操作系统，当miss后取表项存入TLB是完全由硬件完成的，操作系统不参与；但是对于MIPS另一类操作系统，是由软件(操作系统)来完成的。</p></blockquote><p><strong>解决访问空间的问题：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200921214623371.png"></p><blockquote><p>p1页表中存放的是p2的页号，p2页表中存放的是帧号；</p><p>逻辑地址中，页号部分分成了2部分，p1和p2。</p><p>p1存放着二级页表的起始地址，p2的作用就是之前的p。</p><p>p1找二级页表，p2找页，o找地址。</p><p>这里体现了二级页表的另一个好处，就是p1对应的位置是flags，假如说resident bit是0，那么整个二级页表都不用在内存中保存，这个是一级页表无法实现的！</p></blockquote><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200922075030514.png"></p><hr><h3 id="1-3-4-反向页表"><a href="#1-3-4-反向页表" class="headerlink" title="1.3.4 反向页表"></a>1.3.4 反向页表</h3><p> <strong>反向页表：</strong></p><p>页表来表示物理地址(页帧)号，而不是之前的逻辑地址(页号)，不是让页表与逻辑地址空间的大小相对应，而是让页表与物理地址空间的大小相对应，能够减少页表尺寸，但是给映射关系的建立带来点困难。</p><p><strong>传统页表的缺点：</strong></p><p>(1)对于大地址空间，前向映射页表变得繁琐(例如64位系统采用5级页表)。</p><p>(2)逻辑地址空间增长速度快于物理地址空间，所以反向页表，也就是index是物理地址，value是逻辑地址，它的大小会小于传统页表。</p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200922081130668.png"></p><p> <strong>基于页寄存器(page registers)的方案：</strong></p><p>(1)每一帧和一个寄存器相关联，该寄存器包括：</p><ul><li>residence bit：此帧是否被占用；</li><li>occupier：对应的页号p；</li><li>protection bit：保护位；</li></ul><p>(2)举个例子：</p><blockquote><p>物理内存大小：4096 * 4096 KB &#x3D; 16 MB<br>页面大小：4064 bytes &#x3D; 4 KB<br>页帧数： 4K<br>页寄存器使用的空间(假设是8 bytes的register)：8 * 4096 &#x3D; 32 KB<br>页寄存器的额外开销：32 KB &#x2F; 16 MB &#x3D; 0.2%<br>虚拟内存的大小：任意<br>可以看出内存开销很小。</p></blockquote><p>（3）页寄存器的优缺点；</p><blockquote><p>优点：</p><p>转换表的大小相对于物理内存来说很小；<br>        转换表的大小跟逻辑地址空间的大小无关；</p><p>缺点：</p><p>需要的信息对调了，如何根据帧号找到页号呢；<br>        需要在反向页表里去找想要的页号。</p></blockquote><p><strong>基于关联内存(associative memory)的方案：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/20200112153301505.png"></p><blockquote><p>如果帧数较少，页寄存器可以被放置在关联内存中；<br>        在关联内存中查找逻辑页号，成功了，帧号就被提取出来；失败了，页错误异常page fault。<br>        限制这种方案的因素包括，大量的关联内存非常昂贵(难以在单个时钟周期内完成；耗电)。</p></blockquote><p><strong>基于哈希(hash)查找的方案：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/20200112153313860.png"></p><blockquote><p>在查找时，将页号(page) + PID(运行程序的ID) 进行组合然后作为 input传入 哈希表，然后算出对应的帧号；</p><p>存在的问题：</p><pre><code>  1. 由于是hash算法，因此一个input可能会对应多个output；     2. 还是需要将整个反向页表放置到内存中，因此整个内存访问还是很大。</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（三）、连续内存分配</title>
      <link href="/2020/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2020/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的内存管理："><a href="#操作系统的内存管理：" class="headerlink" title="操作系统的内存管理："></a>操作系统的内存管理：</h1><h2 id="3-1-计算机体系结构及内存分层体系"><a href="#3-1-计算机体系结构及内存分层体系" class="headerlink" title="3.1 计算机体系结构及内存分层体系"></a>3.1 计算机体系结构及内存分层体系</h2><p><img src="/passageImg/%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/v2-6cbe0ce1ed6a7336de891e9f83ad4269_r.jpg"></p><p><img src="/passageImg/%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200916143445419.png"></p><span id="more"></span><h3 id="操作系统的内存层次："><a href="#操作系统的内存层次：" class="headerlink" title="操作系统的内存层次："></a>操作系统的内存层次：</h3><p><img src="/passageImg/%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200916143731533.png"></p><h3 id="操作系统在内存管理方面需要完成的目标："><a href="#操作系统在内存管理方面需要完成的目标：" class="headerlink" title="操作系统在内存管理方面需要完成的目标："></a>操作系统在内存管理方面需要完成的目标：</h3><ol><li>抽象： 逻辑地址空间</li><li>保护： 独立地址空间(保证多个进程间不会相互干扰)</li><li>共享： 访问共同的地址空间（当多个进程需要操作同一块操作地址时，需要共享地址空间）</li><li>虚拟化： 由于缓存及寄存器的存储空间有限，当存储大量数据时，就需要使用虚拟空间<img src="/passageImg/%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200916144414097.png"></li></ol><h3 id="操作系统管理内存的不同方法："><a href="#操作系统管理内存的不同方法：" class="headerlink" title="操作系统管理内存的不同方法："></a>操作系统管理内存的不同方法：</h3><ul><li>程序重定位</li><li>分段</li><li>分页</li><li>虚拟内存</li><li>按需分页虚拟内存</li></ul><p><strong>操作系统在完成内存管理操作同时还需要高度依赖于硬件</strong></p><ul><li>必须知道内存架构</li><li>MMU（内存管理单元）：硬件组件负责处理CPU的内存访问请求</li></ul><h2 id="3-2-地址空间及地址生成"><a href="#3-2-地址空间及地址生成" class="headerlink" title="3.2 地址空间及地址生成"></a>3.2 地址空间及地址生成</h2><h3 id="①-地址空间的定义："><a href="#①-地址空间的定义：" class="headerlink" title="① 地址空间的定义："></a>① 地址空间的定义：</h3><h4 id="物理地址空间："><a href="#物理地址空间：" class="headerlink" title="物理地址空间："></a>物理地址空间：</h4><p>物理地址空间是指一些硬件支持的地址空间，比如硬盘和内存条、高速缓存…..</p><h4 id="逻辑地址空间："><a href="#逻辑地址空间：" class="headerlink" title="逻辑地址空间："></a>逻辑地址空间：</h4><p>逻辑地址空间是指一个运行程序所拥有的内存范围，它的结构很简单，就是一条线性的地址空间</p><p>&#x3D;&#x3D;但是最终逻辑地址空间还是会指向物理地址空间，操作系统需要协调这二者的关系，通过映射来使得逻辑地址指向物理地址。&#x3D;&#x3D;</p><h3 id="②-逻辑地址的生成："><a href="#②-逻辑地址的生成：" class="headerlink" title="② 逻辑地址的生成："></a>② 逻辑地址的生成：</h3><p><img src="/passageImg/%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200916145911777.png"></p><h3 id="③-物理地址的生成："><a href="#③-物理地址的生成：" class="headerlink" title="③ 物理地址的生成："></a>③ 物理地址的生成：</h3><p>  <strong>&#x3D;&gt;CPU方面</strong></p><p>a. CPU执行指令时，它的ALU部件会需要指令的某个内容，它发出的请求中的参数会携带逻辑地址；</p><p>b. CPU的内存管理单元MMU 寻找逻辑地址的映射表中是否存在物理地址。如果没有找到，那么就会产生一个处理过程，去内存中找。如果最终找着了，那么CPU的控制器从总线发送在物理地址的内存内容的请求；</p><p><strong>&#x3D;&gt;内存方面</strong></p><p>a. 内存发送物理地址内存内容给CPU（CPU开始处理对应的指令）</p><p><strong>&#x3D;&gt;操作系统方面</strong></p><p>a. 建立逻辑地址和物理地址之间的映射关系，该关系可以放在内存中由CPU缓存来加快进程(确保程序不相互干扰)</p><p><img src="/passageImg/%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200916152657429.png"></p><h3 id="④-地址安全检查："><a href="#④-地址安全检查：" class="headerlink" title="④ 地址安全检查："></a>④ 地址安全检查：</h3><p><img src="/passageImg/%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200916152901439.png"></p><h2 id="3-3-连续内存分配：内存碎片与分区的动态分配"><a href="#3-3-连续内存分配：内存碎片与分区的动态分配" class="headerlink" title="3.3 连续内存分配：内存碎片与分区的动态分配"></a>3.3 连续内存分配：内存碎片与分区的动态分配</h2><h3 id="内存碎片问题："><a href="#内存碎片问题：" class="headerlink" title="内存碎片问题："></a>内存碎片问题：</h3><p>碎片是指内存空闲不能被利用，碎片分为内部碎片和外部碎片，外部碎片是指分配单元之间不能被使用；内部碎片是指分配单元中不能被使用。</p><h3 id="简单的内存管理方法："><a href="#简单的内存管理方法：" class="headerlink" title="简单的内存管理方法："></a>简单的内存管理方法：</h3><p>操作系统管理内存的简单方法：当一个程序准许运行在内存中时分配一个连续的空间；分配一个连续的内存空间给运行的程序以访问数据。</p><h3 id="分区的动态分配策略："><a href="#分区的动态分配策略：" class="headerlink" title="分区的动态分配策略："></a>分区的动态分配策略：</h3><h4 id="1、首次适配："><a href="#1、首次适配：" class="headerlink" title="1、首次适配："></a>1、首次适配：</h4><p>概念：现在想要分配n 字节，那么就会从低地址开始查找，当查找到第一个空间大于n字节就结束返回。</p><p>需求：</p><ul><li>存在一个按照地址排序的空闲块列表</li><li>分配需要寻找一个合适的分区</li><li>重分配需要检查，看是否自由分区能够合并于相邻的空闲分区(回收)</li></ul><p>优点：</p><ul><li>简单、易于操作</li><li>便于生成更大的空间块，向着空间地址的结尾(如果在前边找到后就结束，那么不会破坏之后的空间块)</li></ul><p>缺点：</p><ul><li>易于产生外部碎片(前后两个可利用空间块之间的小块不能被使用，会被忽视)</li><li>不确定性</li></ul><h4 id="2、最优适配："><a href="#2、最优适配：" class="headerlink" title="2、最优适配："></a>2、最优适配：</h4><p>概念：会在空闲块间查找最适合的空间块，为了避免分割大的空闲块，同时为了最小化外部碎片产生的尺寸</p><p>需求：</p><ul><li>按照尺寸排列的空闲块列表</li><li>分配需要查找一个合适的分区</li><li>重分配需要搜索合并于相邻的空闲分区</li></ul><p>优点：</p><ul><li>当大部分是小尺寸时非常有效</li><li>比较简单</li></ul><p>缺点：</p><ul><li>会产生外部碎片</li><li>重分配慢</li><li>易于产生很多没用的微小碎片</li></ul><h4 id="3、最差适配："><a href="#3、最差适配：" class="headerlink" title="3、最差适配："></a>3、最差适配：</h4><p>概念：为了分配n字节，使用最大的空闲块，以至块的尺寸比n大</p><p>需求：</p><ul><li>按尺寸排列的空闲块</li><li>分配很快(每次获得最大的分区)</li><li>重分配需要合并于相邻的空闲分区</li></ul><p>优点：对于分配的是中等尺寸效果最好</p><p>缺点：</p><ul><li>重分配慢</li><li>会产生外部碎片</li><li>易于破坏大的空闲块以至于需要分配大分区时无法被分配</li></ul><h2 id="3-4-连续内存分配：压缩式与交换式碎片整理"><a href="#3-4-连续内存分配：压缩式与交换式碎片整理" class="headerlink" title="3.4 连续内存分配：压缩式与交换式碎片整理"></a>3.4 连续内存分配：压缩式与交换式碎片整理</h2><h3 id="1、压缩式碎片整理（紧致）"><a href="#1、压缩式碎片整理（紧致）" class="headerlink" title="1、压缩式碎片整理（紧致）"></a>1、压缩式碎片整理（紧致）</h3><p> <img src="/passageImg/%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200918111237501.png"></p><ul><li>重置程序以合并空洞</li><li>要求所有程序是动态可重置的</li><li>问题：何时重置，开销大</li></ul><p>如图：如果能够将程序占用的内存进行拷贝重分配，那么会产生更多可用的内存空间，但是仅仅靠软件来操作会有很大的开销，对系统的性能会有更大的影响。</p><h3 id="2、交换式碎片整理"><a href="#2、交换式碎片整理" class="headerlink" title="2、交换式碎片整理"></a>2、交换式碎片整理</h3><p><img src="/passageImg/%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20200919205114421.png"></p><p>如果在运行P3时需要更多的内存，而此时P4正在等待，那么就可以将P4的数据拷贝到磁盘(虚拟内存)中，此时P3就获得了足够多的内存可以运行；当P4需要执行时再从磁盘上拷贝回 memory(主存)中即可。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（二）、操作系统基础操作</title>
      <link href="/2020/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="1-操作系统的启动-异常和中断"><a href="#1-操作系统的启动-异常和中断" class="headerlink" title="1.  操作系统的启动 异常和中断"></a>1.  操作系统的启动 异常和中断</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动:"></a>启动:</h3><p>OS的启动加载是通过一步步来执行实现的，主要涉及到 <strong>BIOS(基本I&#x2F;O处理系统,检查外设硬件能否正常工作)、DISK(存放OS)、Bootloader(加载OS，能够让OS从硬盘加载到内存中去)</strong>.</p><ol><li>通电之后BIOS就会从一个特定的地址开始执行(CS:IP &#x3D; 0xf0000:fff0   CS是段寄存器,IP是指令寄存器) ;</li><li>然后接下来会完成一系列操作,包括  加电自检(POST) ,自检是指检查一些硬件外设设备能否正常工作; 在自检完成后就会将bootloader从硬盘上加载进内存中去(bootloader的位置往往位于硬盘的第一个扇区,仅仅只有512个字节);</li><li>接下来CPU的控制权就交给了bootloader, bootloader最主要的一个功能就是将 OS 从硬盘上加载进内存,然后CPU的控制权交给OS , 接下来系统的管理就由OS来控制.</li></ol><p><img src="/passageImg%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9Cmd.assets/image-20200910153923563.png"></p><span id="more"></span><h3 id="系统调用、中断、异常的概念及不同点："><a href="#系统调用、中断、异常的概念及不同点：" class="headerlink" title="系统调用、中断、异常的概念及不同点："></a>系统调用、中断、异常的概念及不同点：</h3><ul><li>系统调用(来源于应用程序)<ul><li>应用程序主动向操作系统发出服务请求</li></ul></li><li>异常(来源于不良的应用程序)<ul><li>非法指令或者其它坏的处理状态(如内存出错)</li></ul></li><li>中断(来源于外设)<ul><li>来自不同的硬件设备的计时器和网络中断</li></ul></li></ul><p>&#x3D;&#x3D;三者的不同点：&#x3D;&#x3D;</p><p><img src="/passageImg%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9Cmd.assets/image-20200910161158456.png"></p><p><img src="/passageImg%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9Cmd.assets/image-20200910161208483.png"></p><p><img src="/passageImg%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9Cmd.assets/image-20200910161258115.png"></p><p>为什么应用程序不能直接访问硬件而是通过操作系统？<br>            -计算机运行时，内核是被信任的第三方。<br>            -只有内核可以执行特权指令。<br>            -为了方便应用程序。</p><h3 id="中断的类型以及用户态和核心态的概念："><a href="#中断的类型以及用户态和核心态的概念：" class="headerlink" title="中断的类型以及用户态和核心态的概念："></a>中断的类型以及用户态和核心态的概念：</h3><ol><li><p>由于早期各个程序间都是串行执行的，引入了中断后便实现了多道程序并行。中断的产生就意味着操作系统的介入，进行了管理；</p></li><li><p><strong>计时部件记录时间</strong>,当<strong>进程1</strong>运行了指定时间后,计时器告诉CPU进程1<strong>运行时间到了</strong><br>这个时候<strong>CPU</strong>知道了(<strong>接收到中断信号</strong>),然后<strong>CPU就切换到核心态</strong>(变身为特工),然后<strong>告诉操作系统</strong>,让操作系统过来管理<br><strong>操作系统</strong>知道了以后(<strong>对中断信号进行处理</strong>),然后<strong>操作系统</strong>就会<strong>进行相应的调度</strong>(比如让进程2再跑一个指定时间)<br>然后<strong>操作系统把CPU的使用权</strong> <strong>给用户的进程</strong>,进程2开始执行<br>(进程执行-&gt;计时器监视进程到时间 -&gt;CPU令牌变色(用户态-&gt;核心态)<br>-&gt;操作系统得到CPU令牌,进行调度后-&gt;令牌褪色(核心态-&gt;用户态)-&gt;归还给进程去执行())<br><img src="https://img-blog.csdnimg.cn/20200103183845655.png" alt="img"><br>需要特权指令 中断 :CPU变色(用户态-&gt;核心态) 找操作系统去处理<br><strong>用户态 - &gt; 核心态是通过中断实现的<br>并且中断是唯一途径</strong></p></li><li><p>中断的分类：</p></li></ol><p><img src="/passageImg%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.assets/20200103184313293.png" alt="img"></p><p><img src="/passageImg%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.assets/20200103184420354.png" alt="img"></p><p><img src="/passageImg%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.assets/20200103184602821.png" alt="img"></p><h3 id="中断和异常处理机制："><a href="#中断和异常处理机制：" class="headerlink" title="中断和异常处理机制："></a>中断和异常处理机制：</h3><p><strong>（1）中断处理</strong>：</p><p><img src="/passageImg%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9Cmd.assets/image-20200910162339623.png"></p><p>分为硬件和软件，硬件方面外设首先会产生一个中断标记，当CPU检测到这个中断标记后会产生一个具体的中断ID，并且将该ID发送给操作系统，操作系统就能够根据具体的ID去操作；</p><p><img src="/passageImg%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9Cmd.assets/image-20200910162558481.png"></p><p>软件方面需要打断当前正在运行的程序，那么就会保存当前的处理状态，然后去处理中断服务程序，处理完毕后清理中断标记，最后恢复之前保存的处理状态；</p><p><strong>（2）异常处理：</strong></p><p>​    异常处理过程和中断不一样，异常处理首先也会产生异常编号告知操作系统，操作系统会保存产生异常的指令的程序现场(比如当前指令的地址和寄存器的内容)，然后进行异常处理，处理结果可能为杀死异常程序或者恢复现场后重新执行异常指令。</p><p><img src="/passageImg%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9Cmd.assets/image-20200910162855451.png"></p><h3 id="系统调用："><a href="#系统调用：" class="headerlink" title="系统调用："></a>系统调用：</h3><p><strong>（1）程序访问主要是通过高层次的API接口而不是直接进行系统调用：</strong></p><p>一条指令会触发一个系统调用；</p><p>-通常情况下，存在与每个系统调用相关的序号，系统调用接口根据这些序号来维护表的索引。<br>        -系统调用接口调用内核态中预期的系统调用，并返回系统调用的状态和其它任何返回值。<br>        -用户不需要知道系统调用是如何实现的，只需要获取API和了解操作新系统将什么作为返回结果。操作系统接口的细节大部分都隐藏在API中，并通过运行程序支持的库来管理。</p><p>-用户态：应用程序在执行的过程中，CPU执行的特权级的状态(很低，不能访问特殊机器指令和IO)。<br>        -内核态：应用程序在执行的过程中，CPU执行的特权级的状态(高，操作系统可以执行CPU任何一条指令)。</p><p>-系统调用时涉及到特权级从用户态到内核态的转换，应用程序和操作系统有各自的堆栈会涉及到堆栈的转变，这两个变化比函数调用的开销更大，但更安全和可靠。(而程序调用是在一个栈空间实现参数的调用和返回)。</p><p><strong>（2）系统调用会涉及到跨越操作系统边界的开销：</strong></p><p>在执行时间上系统调用会超过程序调用，这其中的开销包括 ：①建立中断&#x2F;异常&#x2F;系统调用号与对应服务例程映射关系的初始化开销；②建立内核堆栈(操作系统和应用程序的堆栈不一样)；③验证参数(操作系统不信任应用程序会检查数据)；④内核态映射到用户态的地址空间，更新页面映射权限(内存拷贝开销)；⑤内核态独立地址空间TLB</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）、概述</title>
      <link href="/2020/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%81%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%81%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://blog.csdn.net/iwanderu/article/details/103934127">https://blog.csdn.net/iwanderu/article/details/103934127</a></p></blockquote><h2 id="1-操作系统的功能、概念和目标"><a href="#1-操作系统的功能、概念和目标" class="headerlink" title="1. 操作系统的功能、概念和目标"></a>1. 操作系统的功能、概念和目标</h2><p><img src="/passageImg/%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%81%E6%A6%82%E8%BF%B0.assets/image-20200910143234658.png"></p><span id="more"></span><h2 id="2-操作系统的特征"><a href="#2-操作系统的特征" class="headerlink" title="2. 操作系统的特征"></a>2. 操作系统的特征</h2><p><img src="/passageImg/%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%81%E6%A6%82%E8%BF%B0.assets/image-20200910150351239.png"></p><h2 id="3、各种操作系统的功能"><a href="#3、各种操作系统的功能" class="headerlink" title="3、各种操作系统的功能"></a>3、各种操作系统的功能</h2><h3 id="1-批处理操作系统-Batch"><a href="#1-批处理操作系统-Batch" class="headerlink" title="(1)批处理操作系统  [Batch]"></a>(1)批处理操作系统  [Batch]</h3><blockquote><p>主要特点： 脱机、多道、成批处理</p><p><strong>脱机</strong>是指用户脱机使用计算机，即用户提交作业之后直到获得结果之前几乎不再和计算机打交道。</p><p><strong>多道</strong>是指多道程序运行，即按多道程序设计的调度原则，从一批后备作业中选取多道作业调入内存并组织它们运行；</p><p><strong>成批处理</strong>是指操作员把用户提交的作业组织成一批，由操作系统负责每批作业间的自动调度。<br>　　批处理系统自动化程度比较高，系统吞吐量大，资源利用率高，系统开销小，但各作业周转时间长，不提供用户与系统的交互手段，适合大的成熟的作业。</p></blockquote><h3 id="2-交互式系统-Interactive"><a href="#2-交互式系统-Interactive" class="headerlink" title="(2)交互式系统 [Interactive]"></a>(2)交互式系统 [Interactive]</h3><blockquote><p>主要特点： </p><pre><code> 1. 由许多短交易组成，下一次交易的结果可能不可预知； 2. 需要响应时间短；</code></pre></blockquote><h3 id="3-分时系统-Time-sharing"><a href="#3-分时系统-Time-sharing" class="headerlink" title="(3)分时系统[Time sharing]"></a>(3)分时系统[Time sharing]</h3><blockquote><p>主要特点：多路性、交互性、独占性、及时性</p><ol><li><strong>多路性</strong>是指一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机；</li><li><strong>交互性</strong>是指用户的操作方式是联机方式，即用户通过终端采用人-机会话的方式直接控制程序运行，同程序进行交互；</li><li><strong>独占性</strong>是指由于系统采用时间片轮转的办法使一台计算机同时为许多终端用户服务，因此客观效果是这些用户彼此间都感觉不到别人也在使用这台计算机，好像只有自己独占计算机一样；</li><li><strong>及时性</strong>是指用户请求能在很短时间内获得响应。</li></ol></blockquote><h3 id="4-实时系统-Real-time"><a href="#4-实时系统-Real-time" class="headerlink" title="(4)实时系统[Real time]"></a>(4)实时系统[Real time]</h3><blockquote><p>主要特点：及时性、高可靠性</p><pre><code>1. **及时性**是指系统能及时响应外部事件的请求，并在规定时间内完成对该事件的处理；   2. **高可靠性**是指系统本身要安全可靠，因为像生产过程的实时控制、航空订票等实时事务系统，信息处理的延误或丢失往往会带来不堪设想的后果。</code></pre></blockquote><h3 id="5-网络操作系统-Network"><a href="#5-网络操作系统-Network" class="headerlink" title="(5)网络操作系统[Network]"></a>(5)网络操作系统[Network]</h3><blockquote><p>主要特点：</p><p>​    1. 具有通常操作系统具有的处理机管理、存储管理、设备管理和文件管理的功能；</p><ol start="2"><li>还应具有实现网络中各节点机之间的通信,实现网络中硬、软件资源共享,提供多种网络服务软件,提供网络用户的应用程序接口等功能。</li></ol></blockquote><h3 id="6-分布式操作系统-Distributed"><a href="#6-分布式操作系统-Distributed" class="headerlink" title="(6)分布式操作系统[Distributed]"></a>(6)分布式操作系统[Distributed]</h3><blockquote><p>主要特点： </p><ol><li>联网通信功能；</li><li>提供远程过程调用；</li><li>提供多处理机的统一调度；</li><li>统一的存储管理；</li><li>分布式文件系统；</li></ol></blockquote><h3 id="操作系统提供的多种服务："><a href="#操作系统提供的多种服务：" class="headerlink" title="操作系统提供的多种服务："></a>操作系统提供的多种服务：</h3><ol><li>资源分配；</li><li>程序执行；</li><li>IO操作；</li><li>文件系统的处理加工；</li><li>错误检测；</li><li>通信；</li></ol><h3 id="系统调用的目的："><a href="#系统调用的目的：" class="headerlink" title="系统调用的目的："></a>系统调用的目的：</h3><p>为应用程序提供服务接口。</p><p>程序接口由一组系统调用命令组成。用户通过在程序中使用这些系统调用命令来请求操作系统服务。</p><h3 id="系统程序的目的："><a href="#系统程序的目的：" class="headerlink" title="系统程序的目的："></a>系统程序的目的：</h3><p>为程序开发和运行提供方便的环境，调用操作系统给用户提供基本的公共功能函数，使得用户能够在不用自己写代码的情况下运行程序。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（七）、进程和线程</title>
      <link href="/2020/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程管理："><a href="#进程管理：" class="headerlink" title="进程管理："></a>进程管理：</h1><h2 id="1、进程-PROCESS-管理"><a href="#1、进程-PROCESS-管理" class="headerlink" title="1、进程(PROCESS)管理"></a>1、进程(PROCESS)管理</h2><h3 id="1-1-进程的定义："><a href="#1-1-进程的定义：" class="headerlink" title="1.1 进程的定义："></a>1.1 进程的定义：</h3><blockquote><p>进程：一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。</p></blockquote><span id="more"></span><h3 id="1-2-进程的组成："><a href="#1-2-进程的组成：" class="headerlink" title="1.2 进程的组成："></a>1.2 进程的组成：</h3><blockquote><p>一个进程应该包括：</p><ol><li>程序的代码；</li><li>程序处理的数据；</li><li>程序计数器中的值，指示下一条将要运行的指令；</li><li>一组通用的寄存器的当前值，堆，栈</li><li>一组系统资源（如打开的文件）</li></ol><p>总之，进程包含了正在运行的一个程序的所有状态信息</p></blockquote><h3 id="1-3-进程与程序的联系："><a href="#1-3-进程与程序的联系：" class="headerlink" title="1.3 进程与程序的联系："></a>1.3 进程与程序的联系：</h3><ul><li>程序是产生进程的基础；</li><li>程序的每次运行构成不同的进程；</li><li>进程是程序功能的体现；</li><li>通过多次执行，一个程序可以对应多个进程；通过调用关系，一个进程可以包含多个程序；</li></ul><p><code>程序  =  算法  +  数据结构</code></p><h3 id="1-4-进程与程序的区别："><a href="#1-4-进程与程序的区别：" class="headerlink" title="1.4 进程与程序的区别："></a>1.4 进程与程序的区别：</h3><ul><li>进程是动态的，程序是静止的：程序是有序代码的集合；进程是程序的执行，进程有核心态&#x2F;用户态；</li><li>进程是暂时的，程序是永久的：进程是一个状态变化的过程，程序可以长久保存；</li><li>进程与程序的组成不同：进程的组成包括程序、数据和进程控制块(进程状态信息)；</li></ul><h3 id="1-5-进程与程序的关系实例类比："><a href="#1-5-进程与程序的关系实例类比：" class="headerlink" title="1.5 进程与程序的关系实例类比："></a>1.5 进程与程序的关系实例类比：</h3><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20200926191353003.png" alt="image-20200926191353003"></p><h3 id="1-6-进程的特点："><a href="#1-6-进程的特点：" class="headerlink" title="1.6 进程的特点："></a>1.6 进程的特点：</h3><ul><li>动态性：可以动态地创建，结束进程(进程切换)；</li><li>并发性：进程可以被独立调度并占用处理机运行；并发并行概念区分开；</li><li>独立性：不同进程地工作不相互影响(不会破环进程执行的正确性，参考内存管理的页表结构，不同的程序会被分配不同的页表，让每个进程在不同的页表中运行，一旦超出地址空间的限制就会触发异常)；</li><li>制约性：因访问共享数据&#x2F;资源或进程间同步而产生制约；</li></ul><h3 id="1-7-进程管理-进程控制块-PCB-："><a href="#1-7-进程管理-进程控制块-PCB-：" class="headerlink" title="1.7 进程管理(进程控制块 PCB)："></a>1.7 进程管理(进程控制块 PCB)：</h3><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20200926192224886.png" alt="image-20200926192224886"></p><blockquote><p>什么是进程控制块(PCB)？</p><pre><code> 操作系统管理控制进程运行所用的信息集合。操作系统用PCB来描述进程的基本情况以及运行变化的过程，PCB是进程存在的唯一标识。</code></pre><p>PCB含有以下三大类信息：</p><ul><li><p>进程标识信息。如本进程的标识、本进程的产生着标识（父进程标识）、用户标识；</p></li><li><p>处理机状态信息保存区。保存进程的运行现场信息：</p><pre><code>   * 用户可见寄存器，用户程序可以使用的数据，地址等寄存器。   * 控制和状态寄存器，如程序计数器(PC)，程序状态字(PSW)。   * 栈指针，过程调用/系统调用/中断处理和返回时需要用到它。</code></pre></li><li><p>进程控制信息。 </p><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20200926193829440.png" alt="image-20200926193829440"></p></li></ul></blockquote><blockquote><p>PCB的组织方式： </p><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20200926193944084.png" alt="image-20200926193944084"></p></blockquote><h2 id="2、进程状态（State）"><a href="#2、进程状态（State）" class="headerlink" title="2、进程状态（State）"></a>2、进程状态（State）</h2><h3 id="2-1-进程的生命期管理："><a href="#2-1-进程的生命期管理：" class="headerlink" title="2.1 进程的生命期管理："></a>2.1 进程的生命期管理：</h3><p>​           进程创建 —— 进程运行 —— 进程等待(进程自身发起) —— 进程唤醒(由其它进程或OS唤醒) —— 进程结束</p><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20200926194737789.png" alt="image-20200926194737789"></p><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20200926194844546.png" alt="image-20200926194844546"></p><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20200926194909836.png" alt="image-20200926194909836"></p><h3 id="2-2-进程状态变化模型："><a href="#2-2-进程状态变化模型：" class="headerlink" title="2.2 进程状态变化模型："></a>2.2 进程状态变化模型：</h3><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20200926195051759.png" alt="image-20200926195051759"></p><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20200926195140607.png" alt="image-20200926195140607"></p><blockquote><p>其中进程从 Running —&gt;  Ready：   由于内存中有很多进程等待执行，CPU相对较少，为了让每个进程都有机会执行，设置一个时间片让每一个进程都执行一定的时间，然后等待下次被CPU调度。 </p></blockquote><h3 id="2-3-进程挂起suspend："><a href="#2-3-进程挂起suspend：" class="headerlink" title="2.3 进程挂起suspend："></a>2.3 进程挂起suspend：</h3><blockquote><p>进程挂起是指进程没有占用内存空间，挂起将一个进程从内存转到外存。处在挂起状态的进程映像在硬盘上。</p><p>目的是为了更加合理地运用计算机资源。</p></blockquote><p><strong>(1). 挂起状态：</strong></p><p> 挂起状态包括两类：          阻塞挂起状态(Blocked-suspend)：进程在外存并等待某事件的出现；</p><p>​                                               就绪挂起状态(Ready-suspend)：进程在外存，但只要进入内存，即可运行；</p><p> <strong>(2). 与挂起相关地状态转换：</strong></p><p>&#x3D;&#x3D;挂起【内存  —&gt;  外存】：&#x3D;&#x3D;</p><ul><li>阻塞到阻塞挂起：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程；</li><li>就绪到就绪挂起：当有高优先级阻塞（系统认为很快就绪的）进程和低优先就绪进程时，系统会选择挂起低优先级就绪进程；</li><li>运行到就绪挂起：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态。</li></ul><p>&#x3D;&#x3D;在外存中的状态：&#x3D;&#x3D;</p><ul><li>阻塞挂起到就绪挂起：当有阻塞挂起进程因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程。</li></ul><p>&#x3D;&#x3D;解挂&#x2F;激活(Active)【外存 —–&gt;  内存】：&#x3D;&#x3D;把一个进程从外存转换到内存，可能有以下几种情况：</p><ol><li>就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换；</li><li>阻塞挂起到阻塞：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起(系统认为很快出现所等待的事件)进程转换为阻塞进程；</li></ol><p><strong>(3). 状态队列：</strong></p><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20201004192411152.png" alt="image-20201004192411152"></p><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20201004192422240.png" alt="image-20201004192422240"></p><h2 id="3、线程-THREAD"><a href="#3、线程-THREAD" class="headerlink" title="3、线程(THREAD)"></a>3、线程(THREAD)</h2><h3 id="3-1线程的定义："><a href="#3-1线程的定义：" class="headerlink" title="3.1线程的定义："></a>3.1线程的定义：</h3><ul><li><p>进程当中的一条执行流程。    <code>进程  =  资源管理 + 线程</code></p></li><li><p>从资源组合的角度：进程把一组相关的资源组合起来，构成了一个资源平台(环境)，包括地址空间(代码段，数据段)，打开的文件等各种资源；</p></li><li><p>从运行的角度：代码在这个资源平台上的一条执行流程(线程)，同一个进程的线程共享进程的资源；</p></li></ul><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20201004200914561.png" alt="image-20201004200914561"></p><h3 id="3-2-线程的优缺点："><a href="#3-2-线程的优缺点：" class="headerlink" title="3.2 线程的优缺点："></a>3.2 线程的优缺点：</h3><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20201004201131121.png" alt="image-20201004201131121"></p><h3 id="3-3-线程与进程的比较："><a href="#3-3-线程与进程的比较：" class="headerlink" title="3.3 线程与进程的比较："></a>3.3 线程与进程的比较：</h3><ul><li><p>进程时资源分配单位，线程时CPU调度的单位；</p></li><li><p>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，比如寄存器和栈；</p></li><li><p>线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系。</p></li><li><p>线程能减少并发执行的时间和空间开销：</p><ul><li>线程的创建时间比进程短；</li><li>线程的终止时间比进程短；</li><li>同一进程内的线程切换时间比进程短；</li><li>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信。</li></ul></li></ul><h3 id="3-4-线程的实现："><a href="#3-4-线程的实现：" class="headerlink" title="3.4 线程的实现："></a>3.4 线程的实现：</h3><ul><li>主要有三种线程的实现方式：</li></ul><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20201004202710881.png" alt="image-20201004202710881"></p><blockquote><p>用户线程： 在用户空间实现的线程机制，不依赖于操作系统的内核；</p><p>内核线程：由操作系统滋生来管理的；</p><p>对应的映射关系：   多个用户线程对应一个内核线程、一个用户线程对应一个内核线程、多个用户线程对应多个内核线程。</p></blockquote><ul><li>用户线程的优点：</li></ul><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20201004203337416.png" alt="image-20201004203337416"></p><ul><li><p>用户线程的缺点：</p><pre><code>       1. 阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待；          2. 当一个线程开始运行后，除非它主动地交出CPU的使用权，否则它所在的进程当中的其它线程都将无法运行。(因为用户态的线程库不具有处理中断的能力，当用户线程触发了中断后，它不能处理当前的问题；而操作系统具有处理异常和中断的能力，除非用户线程主动交出CPU的使用权，否则其它线程不能执行。)</code></pre></li><li><p>内核线程：</p></li></ul><ol><li>进程主要负责资源的调度管理，线程负责CPU的调度和程序的执行。</li><li>线程的创建、终止和切换都是通过系统调用来完成的，由内核完成，因此开销比较大；线程控制块TCB由PCB管理控制，当然线程的调度主要还是由TCB来完成的。</li><li>只要发生一次线程的切换、终止、创建就会触发一次系统调用，这就涉及到了用户态和核心态的转变。因此开销比较大。</li></ol><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20201004212207000.png" alt="image-20201004212207000"></p><ul><li>轻量级进程：</li></ul><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20201004212429301.png" alt="image-20201004212429301"></p><h3 id="3-5上下文切换："><a href="#3-5上下文切换：" class="headerlink" title="3.5上下文切换："></a>3.5上下文切换：</h3><p>进程共享CPU资源，在不同时候进程需要切换然后让CPU 执行，而CPU与其寄存器紧密相连（比如程序计数器pc[指明进程执行到了什么地方]、栈指针寄存器[知道调度关系和一些局部变量的位置]）。</p><p><img src="/passageImg/%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20201004212829448.png" alt="image-20201004212829448"></p><blockquote><p>切换的过程：当某一个进程执行时需要进行切换，它会首先将自己的context【各种寄存器信息】保存到PCB中，然后将另一个进程的PCB中的信息恢复到CPU中去，这其中来回的过程就实现了进程的切换。</p></blockquote><h2 id="4、进程间通信-INTER-PROCESS-COMMUNICATION"><a href="#4、进程间通信-INTER-PROCESS-COMMUNICATION" class="headerlink" title="4、进程间通信(INTER-PROCESS COMMUNICATION)"></a>4、进程间通信(INTER-PROCESS COMMUNICATION)</h2><h2 id="5、进程互斥与同步"><a href="#5、进程互斥与同步" class="headerlink" title="5、进程互斥与同步"></a>5、进程互斥与同步</h2><h2 id="6、死锁（DEADLOCK）"><a href="#6、死锁（DEADLOCK）" class="headerlink" title="6、死锁（DEADLOCK）"></a>6、死锁（DEADLOCK）</h2>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（五）、虚拟内存</title>
      <link href="/2020/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
      <url>/2020/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟内存："><a href="#虚拟内存：" class="headerlink" title="虚拟内存："></a>虚拟内存：</h1><h2 id="1-覆盖技术："><a href="#1-覆盖技术：" class="headerlink" title="1. 覆盖技术："></a>1. 覆盖技术：</h2><h3 id="1-1-目标："><a href="#1-1-目标：" class="headerlink" title="1.1 目标："></a>1.1 目标：</h3><pre><code>* 在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用。</code></pre><h3 id="1-2-原理："><a href="#1-2-原理：" class="headerlink" title="1.2 原理："></a>1.2 原理：</h3><ul><li>把程序按照其自身的逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按照时间先后来执行。</li><li>必要部分（常用功能） 的代码和数据常驻内存；</li><li>可选部分（不常用功能）在其他程序模块中实现，平时存放在外存中，在需要用到时才装入内存；</li><li>不存在调用关系的模块不必同时装入内存，从而可以相互覆盖，即这些模块公用一个分区。</li></ul><span id="more"></span><h3 id="1-3-实例："><a href="#1-3-实例：" class="headerlink" title="1.3 实例："></a>1.3 实例：</h3><p><img src="/passageImg/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.assets/image-20200923201026627.png"></p><blockquote><p>覆盖方法一：</p><p>​     由于A会调用B、C、D、E、F，那么A就必须作为常驻内存；</p><p>​     当A调用B的时候不会调用C，此时就可以将C存放在硬盘中，A调用完B后返回去调用C，此时会释放B的内存空间，将C从硬盘调入内存；</p><p>​      同理当C调用E时，D和F不会运行，那么可以将D、F放入硬盘。</p></blockquote><p><img src="/passageImg/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.assets/image-20200923201426445.png"></p><blockquote><p>覆盖方法二：</p><p>​         B、E、F共享一块内存； C、D共享一块内存。</p></blockquote><h3 id="1-4-覆盖技术的缺点："><a href="#1-4-覆盖技术的缺点：" class="headerlink" title="1.4 覆盖技术的缺点："></a>1.4 覆盖技术的缺点：</h3><ul><li>由人来讲一个大的程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，费时费力，增加了编程的复杂度；</li><li>覆盖模块从外存装入内存，实际上是以时间延长来换取空间节省。</li></ul><h2 id="2-交换技术"><a href="#2-交换技术" class="headerlink" title="2. 交换技术"></a>2. 交换技术</h2><h3 id="2-1-目标："><a href="#2-1-目标：" class="headerlink" title="2.1 目标："></a>2.1 目标：</h3><ul><li>多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源。</li></ul><h3 id="2-2-方法："><a href="#2-2-方法：" class="headerlink" title="2.2 方法："></a>2.2 方法：</h3><ul><li>将暂时不能运行的程序送到外存，而从获得空闲内存空间。</li><li>操作系统把一个进程的整个地址空间的内容保存到外存中（换出 swap out），而将外存中的某个进程的地址空间读入到内存中（换入 swap in）。换入换出内容的大小为整个程序的地址空间。导入导出的力度会比较大，通常大于一个页。</li></ul><h3 id="2-3-交换技术实现的几个问题："><a href="#2-3-交换技术实现的几个问题：" class="headerlink" title="2.3 交换技术实现的几个问题："></a>2.3 交换技术实现的几个问题：</h3><p> <img src="/passageImg/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.assets/image-20200923203226069.png" alt="image-20200923203226069"></p><h3 id="2-4-覆盖与交换的比较："><a href="#2-4-覆盖与交换的比较：" class="headerlink" title="2.4 覆盖与交换的比较："></a>2.4 覆盖与交换的比较：</h3><ul><li>覆盖只能发生在那些相互之间没有调用关系的程序模块之间，它发生在一个程序内，需要程序员给出程序内各个模块之间的逻辑覆盖结构。</li><li>交换技术是以在内存中的程序大小为单位来进行，它不需要程序员给出各个模块之间的逻辑覆盖结构。换言之，交换发生在内存中程序与管理程序或操作系统之间，是由操作系统来操作的，而覆盖则发生在运行程序的内部。</li></ul><h2 id="3-虚存技术"><a href="#3-虚存技术" class="headerlink" title="3. 虚存技术"></a>3. 虚存技术</h2><h3 id="3-1-覆盖技术和交换技术的缺点："><a href="#3-1-覆盖技术和交换技术的缺点：" class="headerlink" title="3.1 覆盖技术和交换技术的缺点："></a>3.1 覆盖技术和交换技术的缺点：</h3><p><img src="/passageImg/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.assets/image-20200923204308227.png" alt="image-20200923204308227"></p><h3 id="3-2-虚存技术的目标："><a href="#3-2-虚存技术的目标：" class="headerlink" title="3.2 虚存技术的目标："></a>3.2 虚存技术的目标：</h3><ul><li>像覆盖技术那样，不是把程序的所有内容都放在内存中，因而能够运行比当前的空闲内存还要大的程序。但做的更好，由操作系统自动完成，无须程序员的干涉；</li><li>像交换技术那样，能够实现进程在内存与外存之间的交换，因而能够获得更多的空闲内存空间。但做的更好，只对进程的部分内容在内存和外存之间进行交换。</li></ul><p><img src="/passageImg/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.assets/image-20200923204926982.png" alt="image-20200923204926982"></p><h3 id="3-3-程序的局部性原理—-对虚存技术的支持"><a href="#3-3-程序的局部性原理—-对虚存技术的支持" class="headerlink" title="3.3 程序的局部性原理—-对虚存技术的支持"></a>3.3 程序的局部性原理—-对虚存技术的支持</h3><p><img src="/passageImg/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.assets/image-20200923205148386.png" alt="image-20200923205148386"></p><p><img src="/passageImg/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.assets/image-20200923205812094.png" alt="image-20200923205812094"></p><p><img src="/passageImg/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.assets/image-20200923210006178.png" alt="image-20200923210006178"></p><blockquote><p>程序编写方法一：</p><p>​            由于数组的一行放在一个页面中，而每次只能分配给每个进程一页数据。当开始访问 a(0,0)时由于数据还在磁盘中，需要调到内存中，因此发生了一次缺页异常。</p><p>​             当a(0,0)访问完成后访问a(1,0)，它在另外一页，此时又要到磁盘中调出该页到内存中，又发生了一次缺页异常。</p><p>程序编写方法二：</p><p>​               当访问完a(0,0)后会继续访问a(0,1)，都在同一页面中，因此不会发生缺页中断。总的来说只会发生1024次。</p></blockquote><h3 id="3-4-虚存技术—–基本概念："><a href="#3-4-虚存技术—–基本概念：" class="headerlink" title="3.4 虚存技术—–基本概念："></a>3.4 虚存技术—–基本概念：</h3><p><img src="/passageImg/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.assets/image-20200923211210592.png" alt="image-20200923211210592"></p><h3 id="3-5-虚存技术—–基本特征："><a href="#3-5-虚存技术—–基本特征：" class="headerlink" title="3.5 虚存技术—–基本特征："></a>3.5 虚存技术—–基本特征：</h3><ul><li>大的用户空间：通过把物理内存与外存相结合，提供给用户的虚拟内存空间通常大于实际的物理内存，即实现了这两者的分离。如32位的虚拟地址理论上可以访问4GB，而部分计算机上仅有256M的物理内存，但硬盘容量大于4GB；</li><li>部分交换：与交换技术相比较，虚拟存储的调入和调出是对部分虚拟地址空间进行的；</li><li>不连续性：物理内存分配的不连续，虚拟地址空间使用的不连续性；</li></ul><h3 id="3-6-虚存技术—-虚拟页式内存管理："><a href="#3-6-虚存技术—-虚拟页式内存管理：" class="headerlink" title="3.6 虚存技术—-虚拟页式内存管理："></a>3.6 虚存技术—-虚拟页式内存管理：</h3><p>  <img src="/passageImg/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.assets/image-20200924155939695.png" alt="image-20200924155939695"></p><p><img src="/passageImg/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.assets/image-20200924160619388.png" alt="image-20200924160619388"></p><p><strong>3.6.1 虚拟页式内存管理的实例：</strong></p><p><img src="/passageImg/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.assets/image-20200924161218927.png" alt="image-20200924161218927"></p><blockquote><p>如果，驻留位为X代表没有对应的页X帧，该页还处在外存中；驻留位为其它数字则代表内存中有对应页帧。</p></blockquote><p><strong>3.6.2 缺页中断异常的处理过程：</strong></p><p><img src="/passageImg/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.assets/image-20200924162307430.png" alt="image-20200924162307430"></p><blockquote><ul><li>第一种是：当发生缺页中断异常时，操作系统会检查在内存中是否有空闲的物理页面，然后从外存中将对应的页面调入到物理内存，同时还需要修改该页对应的页表项(包括页帧号、驻留位)。修改好后就会重新执行发生异常的指令。</li><li>第二种是：内存中没有空闲的物理页面，此时就需要根据页面置换算法来选择一个被替换的页帧，此时可能会将处于使用状态的物理页面置于空闲状态，如果该物理页中的数据被修改过，那么要先将数据写回外存中；如果没有被修改过，就直接释放。</li></ul></blockquote><h3 id="3-7-后备存储："><a href="#3-7-后备存储：" class="headerlink" title="3.7 后备存储："></a>3.7 后备存储：</h3><p><img src="/passageImg/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.assets/image-20200924163258434.png" alt="image-20200924163258434"></p><h3 id="3-8-虚存管理性能："><a href="#3-8-虚存管理性能：" class="headerlink" title="3.8 虚存管理性能："></a>3.8 虚存管理性能：</h3><p><img src="/passageImg/%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.assets/image-20200924163621987.png" alt="image-20200924163621987"></p><blockquote><p>当没有发生缺页异常时，操作系统会直接读取内存中的物理页，此时访时：10(1-p)</p><p>当发生了缺页异常时，操作系统需要到外存中去调用相应的物理页进入内存，但是如果内存容量不够就还需要采用页面置换算法进行页面置换，这就关系到当前正在执行页面的数据保存与统一，如果页面中的数据发生了改变就需要写回外存保证数据统一，这就又进行了一次磁盘访问。因此此时的访时：5000000p(1+q)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（六）、页面置换算法</title>
      <link href="/2020/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
      <url>/2020/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="页面置换算法："><a href="#页面置换算法：" class="headerlink" title="页面置换算法："></a>页面置换算法：</h1><h2 id="1、页面置换算法的功能目标"><a href="#1、页面置换算法的功能目标" class="headerlink" title="1、页面置换算法的功能目标:"></a>1、页面置换算法的功能目标:</h2><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200925153915313.png"></p><p><strong>1.1 举例：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200925154148351.png"></p><span id="more"></span><h2 id="2、局部页面置换算法："><a href="#2、局部页面置换算法：" class="headerlink" title="2、局部页面置换算法："></a>2、局部页面置换算法：</h2><h3 id="2-1最优页面置换算法："><a href="#2-1最优页面置换算法：" class="headerlink" title="2.1最优页面置换算法："></a>2.1最优页面置换算法：</h3><ul><li>基本思路：当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需要等待多长时间，从中选择等待时间的最长的那个，作为被置换的页面；</li><li>这只是一种理想情况，实际中无法实现，因为操作系统无法得知每一个页面需要等待多长时间之后才会被再次访问；</li><li>可以用作其它算法的性能评价依据。</li></ul><p><strong>例子:</strong></p><p>​    <img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200925164301327.png"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="2-2先进先出算法-FIFO-："><a href="#2-2先进先出算法-FIFO-：" class="headerlink" title="2.2先进先出算法(FIFO)："></a>2.2先进先出算法(FIFO)：</h3><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200925164445812.png"></p><p><strong>例子：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200925164709099.png"></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="2-3最近最久未使用算法-LRU—Least-Recently-Used-："><a href="#2-3最近最久未使用算法-LRU—Least-Recently-Used-：" class="headerlink" title="2.3最近最久未使用算法(LRU—Least Recently Used)："></a>2.3最近最久未使用算法(LRU—Least Recently Used)：</h3><p><strong>（1）概念：</strong></p><blockquote><p>区别于FIFO算法，FIFO算法替换的是在内存中驻留时间最长的页面，是根据页面驻留时间长短来区分的；</p><p>而最近最久未使用算法对应的是页面的访问，是根据最近页面访问来决定的。</p></blockquote><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200925165111660.png"></p><p><strong>（2）例子：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200925165448038.png"></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200925170932956.png"></p><p><strong>通过栈来实现LRU算法（记录页面的访问次数及顺序）：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200925171549687.png"></p><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="2-4时钟页面置换算法-Clock-："><a href="#2-4时钟页面置换算法-Clock-：" class="headerlink" title="2.4时钟页面置换算法(Clock)："></a>2.4时钟页面置换算法(Clock)：</h3><p><strong>（1） 概念：</strong></p><p> <img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200925172816402.png"></p><blockquote><p>时钟页面置换算法需要用到页表中的访问位，当一个页面被装入内存时，设置为0，一旦被访问就设置为1（置1的操作是由硬件来完成的）；各个页面组织成一个环形链表，指针指向最老的页面，当发生缺页中断时，去看指针指向的最老的页面的访问位，为0则淘汰。</p><p>Clock算法因为只增加了一个used bit(一位)，因此总的来说比LRU算法更节省资源空间。</p></blockquote><p><strong>（2）时钟置换过程：</strong> </p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200925173529793.png"></p><blockquote><p>首先内存中存放了5个页面，每个页面的 第一位为驻留位(判断该页是否存在于内存中)，第二位是访问位(判断该页最近是否被访问过，用于页面置换)，第三位是页帧号(用于查找对应的物理页面)。</p><p>当需要访问Page6时，首先会看内存中是否还有空间，因为没有空间就需要用到页面置换，查看指针指向的最老的页(这里为Page 0)，由于Page 0的访问位为1(表示最近刚刚被访问过)，因此会将Page 0的访问位置0然后接着顺时针继续查找，遇到访问位为1则置0，直到遇到访问位为0的为止。当遇到访问为为0的页面后就会进行替换，<strong>将新的页面的访问位置1然后指针指向下一个页面。</strong></p><p>​    </p><p><strong>！注意：</strong>如果没有发生缺页异常，比如说需要访问Page 4，内存中恰好存在，会由硬件将对应页面的访问位置1，<strong>但是指针不会移动！！！</strong></p></blockquote><p><strong>（3）实例：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200925175539767.png"></p><h3 id="2-5二次机会法-Enhanced-Clock-algorithm-："><a href="#2-5二次机会法-Enhanced-Clock-algorithm-：" class="headerlink" title="2.5二次机会法(Enhanced Clock algorithm)："></a>2.5二次机会法(Enhanced Clock algorithm)：</h3><p><strong>（1）概念：</strong></p><p> <img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200925175935327.png"></p><blockquote><p>修改了Clock算法，新增了一个 drity bit位，该位主要用于记录页面访问过程中是否被修改过。</p><p>对于那些只读的页，它们的dirty bit为0，那么当used bit也为0的时候会直接被替换掉，当used为1时会将used bit 置0；</p><p>对于某些进行了修改的页面，修改过后它们的 dirty bit 会被置1，但是此时即使used bit 为0也仅仅会将used bit 置0，不会将该页给替换掉；而对于used bit 和　dirty bit 都为1 的页面，只会将used bit 置0；</p><p><strong>这种做法保证了某些被修改过的页面不会轻易被替换掉，因为替换的过程是非常耗时的，操作系统需要将该页的数据写回到外存中来保证数据的统一。而对于只读的页面，由于数据始终是统一的，操作系统会将它们直接释放掉。</strong></p></blockquote><p><strong>（2）实例：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200925181603230.png"></p><h3 id="2-6-最不常用算法-LFU-—-Least-Frequently-Used-："><a href="#2-6-最不常用算法-LFU-—-Least-Frequently-Used-：" class="headerlink" title="2.6 最不常用算法(LFU —- Least Frequently Used)："></a>2.6 最不常用算法(LFU —- Least Frequently Used)：</h3><p><strong>（1） 概念：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200925195654474.png"></p><blockquote><p>LFU算法是根据 页面数据访问的频率来决定替换哪个页面的。</p></blockquote><h3 id="2-7Belady现象及原因："><a href="#2-7Belady现象及原因：" class="headerlink" title="2.7Belady现象及原因："></a>2.7Belady现象及原因：</h3><p><strong>(1) Belady现象：</strong></p><p>​       在采用FIFO 算法时，有时会出现分配的物理页面数增加，缺页率反而提高的异常现象；</p><p><strong>(2) Belady现象的原因：</strong></p><p>​       FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标是不一致的(即替换较少使用的页面)，而FIFO算法替换调的是贮存在内存中时间最长的页面，因此，被它置换出去的页面不一定是进程不会访问的。</p><p><strong>(3) Belady现象实例(增加了物理页面数，缺页率反而提高)：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926152811725.png"></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926152947883.png"></p><blockquote><p>FIFO算法只会体现页面存在内存中的时间，不会体现页面何时被访问的时间先后。</p></blockquote><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926153453922.png"></p><blockquote><p>为什么FIFO算法会产生Belady现象，而LRU算法不会产生Belady现象：</p><p>​           解答：因为LRU算法符合栈算法的特点，而FIFO算法不符合栈算法的特点。栈算法的特点是给予的物理页帧越多，所产生的缺页中断次数就越少。</p></blockquote><p><strong>(4) LRU、FIFO和Clock算法的比较：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926153640373.png"></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926154252082.png"></p><h2 id="3、全局页面置换算法："><a href="#3、全局页面置换算法：" class="headerlink" title="3、全局页面置换算法："></a>3、全局页面置换算法：</h2><h3 id="3-1-工作集模型："><a href="#3-1-工作集模型：" class="headerlink" title="3.1 工作集模型："></a>3.1 工作集模型：</h3><p><strong>（1）工作集模型[对程序局部性的分析与体现]:</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926160612981.png"></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926160842222.png"></p><p><strong>（2）例子：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926161208332.png"></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926161310900.png"></p><p><strong>（3）工作集与常驻集的差异：</strong></p><blockquote><p>工作集：一个进程当前正在使用的逻辑页面的集合，该程序在访问过程中需要的页面是哪些，这些页面可以存在于内存中也可以不存在于内存中。可以用一个二元函数 <code>W(t,^)来表示：</code></p><ul><li>t是当前的执行时刻</li><li><code>^</code>称为工作集窗口（working-set window），即一个定长的页面访问的时间窗口（^是不变的）</li><li><code>w(t,^)=</code>在当前的时刻t之前的 <code>^</code>时间窗口当中的所有页面所组成的集合(随着t的变化，该集合也在不断地变化)；</li><li><code>| W(t,^) |</code>,值工作集的大小，集页面的数目；</li></ul><p>常驻集：在当前时刻，进程实际驻留在内存当中的页面集合。</p><ul><li>工作集是进程在运行过程中固有的性质，而常驻集取决于系统分配给进程的物理页面的数目，以及所采用的页面置换算法；</li><li>如果一个进程的整个工作集都在内存当中，即常驻集包含或者等于工作集，那么进程将很顺利地进行，而不会产生太多的缺页中断（直到工作集发生剧烈的变动，从而过渡到另外一个状态）；</li><li>当进程常驻集的大小达到某个数目以后，再给它分配更多的物理页面，缺页率也不会明显的下降。</li></ul></blockquote><h3 id="3-2-两个全局页面置换算法："><a href="#3-2-两个全局页面置换算法：" class="headerlink" title="3.2 两个全局页面置换算法："></a>3.2 两个全局页面置换算法：</h3><p><strong>（1）基于固定窗口的工作集页面置换算法：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926164241701.png"></p><blockquote><p>随着时间的迁移，当前在物理内存中放哪些页完全取决于当前执行时刻和工作集大小，如果某一页超出了工作集窗口的界限，它就会被换出，如果此页被写过，那么会先写回到外存然后再被换出。</p></blockquote><p><strong>（2）基于缺页率的页面置换算法：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926164535645.png"></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926164657462.png"></p><blockquote><p>若运行的程序的缺页率过高，则通过工作集来分配更多的物理页面；若运行的程序的缺页率过小，则通过减少工作集来减少他的物理页面数。力图试运行的每个程序的缺页率保持在一个合理的范围内。</p></blockquote><p>​              <strong>根据缺页率改变工作集大小的做法：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926165133278.png"></p><p>​             <strong>实例：</strong></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926165617716.png"></p><h3 id="3-3-抖动问题-thrashing"><a href="#3-3-抖动问题-thrashing" class="headerlink" title="3.3 抖动问题(thrashing):"></a>3.3 抖动问题(thrashing):</h3><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926165940586.png"></p><p><img src="/passageImg/%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.assets/image-20200926170453250.png"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL、(三) 体系结构与存储引擎</title>
      <link href="/2020/10/21/Mysql%E3%80%81(%E4%B8%89)%20%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2020/10/21/Mysql%E3%80%81(%E4%B8%89)%20%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Mysql体系结构概览"><a href="#一、Mysql体系结构概览" class="headerlink" title="一、Mysql体系结构概览"></a>一、Mysql体系结构概览</h1><p><img src="https://img-blog.csdnimg.cn/20210302212558862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="&lt;font color=#999AAA &gt;示例：pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。"><br>整个 MYSQL Server由以下组成：</p><ul><li>Connection Pool： 连接池组件，接收请求后开启一个线程进行相关的认证授权操作后，再进行相关请求的处理；</li><li>Management Service &amp; Utilities：管理工具和服务组件；主要进行数据的备份与恢复。</li><li>SQL Interface：SQL组件接口；主要进行相关的DML语句、DDL语句、存储过程、视图、触发器等封装。</li><li>Parser：查询分析器组件；主要进行SQL语句的解析。</li><li>Optimizer：优化器组件；主要进行SQL语句的优化处理。</li><li>Caches &amp; Buffers：缓冲池组件；查询缓存中是否有对应的数据，存在的话直接返回即可。</li><li>Pluggable Storage Engines：存储引擎。负责MySQL中数据的存储和提取。</li><li>File System：文件系统 。将数据存储到文件系统之上，并完成与存储引擎的交互。</li></ul><span id="more"></span><p>四层结构：<br><img src="https://img-blog.csdnimg.cn/20210302213914640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>MySQL与其它数据库相比，主要差异体现在它的存储引擎上，插件式的存储引擎架构，将查询处理和其它系统任务以及数据的存储提取和分离。这种架构可以根据实际需要切换存储引擎。</p><h1 id="二、存储引擎概述"><a href="#二、存储引擎概述" class="headerlink" title="二、存储引擎概述"></a>二、存储引擎概述</h1><p>存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式。存储引擎是基于表的，而不是基于库的。所以存储引擎可以被称为表类型。</p><p>查看数据库全部的存储引擎：  <code>show engines;</code><br><img src="https://img-blog.csdnimg.cn/2021030222502410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查看默认的存储引擎：<code>show variables like &#39;%storage_engine&#39;</code>;<br><img src="https://img-blog.csdnimg.cn/20210306204952399.png" alt="在这里插入图片描述"></p><h1 id="三、各种存储引擎特性"><a href="#三、各种存储引擎特性" class="headerlink" title="三、各种存储引擎特性"></a>三、各种存储引擎特性</h1><p><img src="https://img-blog.csdnimg.cn/20210302225110742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210306205205934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>innoDB  支持事务、行锁、外键；</li><li>innoDB是唯一支持外键的存储引擎；</li><li>innoDB 的事务控制：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> `goods_innodb`(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(id)</span><br><span class="line">) engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 开启事务</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods_innodb(id,name)  <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;zhangsan&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-Innodb存储引擎的存储方式"><a href="#1-Innodb存储引擎的存储方式" class="headerlink" title="1. Innodb存储引擎的存储方式"></a>1. Innodb存储引擎的存储方式</h3><p><img src="https://img-blog.csdnimg.cn/20210306191927751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-MyISAM存储引擎的特性"><a href="#2-MyISAM存储引擎的特性" class="headerlink" title="2.MyISAM存储引擎的特性"></a>2.MyISAM存储引擎的特性</h3><ol><li>简介：<br> MyISAM 不支持事务、外键，且为表锁。但是它的优势是访问速度快，对事务的完整性没有要求或者以 SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表。</li><li>两个重要的特点：</li></ol><ul><li>不支持事务</li><li>文件存储模式<br><img src="https://img-blog.csdnimg.cn/20210306192925791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="3-存储引擎的选择"><a href="#3-存储引擎的选择" class="headerlink" title="3. 存储引擎的选择"></a>3. 存储引擎的选择</h3><p><img src="https://img-blog.csdnimg.cn/20210306193128717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对安全性、事务的完整性要求比较高的时候选择 InnoDB；如果多数情况下只是读取和插入操作，很少用到删除和更新操作，那么选择 MyISAM 存储引擎会更快一些；Memory 将数据保存在内存中，通常用于更新频率不太频繁的小表，用于快速得到访问结果；MERGE就是一组MyISAM表的形式，将多个表分布在不同的磁盘上，适合用于数据仓储等情况。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL、(二) 索引</title>
      <link href="/2020/10/20/Mysql%E3%80%81(%E4%BA%8C)%20%E7%B4%A2%E5%BC%95/"/>
      <url>/2020/10/20/Mysql%E3%80%81(%E4%BA%8C)%20%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、索引概述"><a href="#一、索引概述" class="headerlink" title="一、索引概述"></a>一、索引概述</h1><ul><li>索引定义： 索引(index) 是帮助MYSQL高效获取数据的数据结构(有序)，索引目的在于提高查找效率，类比于字典，可以简单理解为排好序的数据结构的快速查找。在数据之外，数据库还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。<br> <img src="https://img-blog.csdnimg.cn/20210301214516281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><span id="more"></span><h1 id="二、索引的优势劣势"><a href="#二、索引的优势劣势" class="headerlink" title="二、索引的优势劣势"></a>二、索引的优势劣势</h1><ol><li>优势</li></ol><ul><li>提高数据检索的效率，降低数据库的IO成本；</li><li>降低数据排序的成本，降低CPU的消耗；</li></ul><ol start="2"><li>劣势<br><img src="https://img-blog.csdnimg.cn/20210301214829891.png" alt="*"></li></ol><h1 id="三、索引结构"><a href="#三、索引结构" class="headerlink" title="三、索引结构"></a>三、索引结构</h1><p><img src="https://img-blog.csdnimg.cn/20210301215009905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210301215104270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="BTREE索引"><a href="#BTREE索引" class="headerlink" title="BTREE索引"></a>BTREE索引</h2><ol><li>BTREE 结构(以m叉为例)：<br><img src="https://img-blog.csdnimg.cn/20210302165046973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>实例：<br><img src="https://img-blog.csdnimg.cn/20210302170341525.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302170352841.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302170409292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302170420312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302170430737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302170441759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302170511167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302170520371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302170636252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt=" "><br>BTREE树 和二叉树相比，查询数据的效率更高，因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度更快。</li></ol><h2 id="B-TREE索引"><a href="#B-TREE索引" class="headerlink" title="B+ TREE索引"></a>B+ TREE索引</h2><h3 id="1-结构介绍"><a href="#1-结构介绍" class="headerlink" title="1.结构介绍"></a>1.结构介绍</h3><p><img src="https://img-blog.csdnimg.cn/20210302171441529.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302171754270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>由于B+ 树的所有信息都保存在叶子节点上，因此查询任何key都要从root 走到叶子，保证了查询的稳定性。</p></blockquote><h3 id="2-Mysql中的B-树"><a href="#2-Mysql中的B-树" class="headerlink" title="2. Mysql中的B+ 树"></a>2. Mysql中的B+ 树</h3><p><img src="https://img-blog.csdnimg.cn/20210302172113233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Mysql在原 B+ Tree的基础上进行了优化，增加了一个指向相邻叶子结点的链表指针。这样当需要访问某个范围内的数据时就能够通过链表提高访问区间访问性能。<br><br></p><h1 id="四、索引分类"><a href="#四、索引分类" class="headerlink" title="四、索引分类"></a>四、索引分类</h1><p>InnoDB存储引擎，B+树索引可以分为聚簇索引(也称聚集索引)和辅助索引(也称二级索引、非聚簇索引)。这两种索引的内部都是B+树，聚簇索引的叶子节点存放着一整行的数据。</p><ul><li>InnoDB中的主键索引是一种聚簇索引，辅助索引包括复合索引、前缀索引、唯一索引。</li><li>InnoDB使用的是聚簇索引，MyISAM使用的是非聚簇索引。</li></ul><h3 id="4-1-InnoDB-聚簇索引"><a href="#4-1-InnoDB-聚簇索引" class="headerlink" title="4.1 InnoDB_聚簇索引"></a>4.1 InnoDB_聚簇索引</h3><p><img src="https://img-blog.csdnimg.cn/20210307191012106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>聚簇索引就是按照每张表的主键构造一棵B+树，同时B+树的叶子节点存放的是整张表的行记录数据，我们也将聚簇索引的叶子节点称为数据页。这个特性决定了索引组织表中的数据也是索引的一部分，<strong>每张表只能有一个聚簇索引</strong>。</p><p>InnoDB通过主键聚集数据，如果没有定义主键，innoDB会选择非空的唯一索引来代替，如果也没有这种索引，那么InnoDB会定义隐藏的主键然后在上聚集。</p><h4 id="聚簇索引的优点："><a href="#聚簇索引的优点：" class="headerlink" title="聚簇索引的优点："></a>聚簇索引的优点：</h4><ul><li>可以将相关的数据保存在一起。比如当实现电子邮箱时，可以按照user_id 进行聚集，这样从磁盘上提取几个页面时能够把某个用户的邮件全部抓取出来。如果没有使用聚簇索引，那么每个邮件都需要访问磁盘。</li><li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快。</li></ul><h4 id="聚簇索引的缺点："><a href="#聚簇索引的缺点：" class="headerlink" title="聚簇索引的缺点："></a>聚簇索引的缺点：</h4><ul><li>插入速度严重依赖于插入顺序。按照主键的顺序插入行是把数据装入 InnoDB表的最快方法。否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</li><li>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</li><li>聚集表可能比全表扫描慢，尤其是表存储的比较稀疏或者因为分页没有顺序存储的时候。</li></ul><h3 id="4-2-InnoDB-辅助索引"><a href="#4-2-InnoDB-辅助索引" class="headerlink" title="4.2 InnoDB_辅助索引"></a>4.2 InnoDB_辅助索引</h3><p><img src="https://img-blog.csdnimg.cn/20210307191019600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。</p><ul><li>Innodb辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，还包含了相应行数据的聚簇索引键。</li><li>辅助索引的存在不影响数据在聚簇索引中的组织，所以<strong>一张表可以有多个辅助索引</strong>。在innodb中有时也称辅助索引为二级索引。</li><li>由于辅助索引的叶子节点包含了主键列，因此它会比预想的要大。所以我们在设计数据库时需要将主键定义的小一点。</li><li>辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</li><li>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id &#x3D; 14”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。</li></ul><h3 id="4-3-MyISAM-主键索引"><a href="#4-3-MyISAM-主键索引" class="headerlink" title="4.3 MyISAM_主键索引"></a>4.3 MyISAM_主键索引</h3><p>MyISAM 索引文件和数据文件是分离的，索引文件仅仅保存数据的地址。<br><img src="https://img-blog.csdnimg.cn/20210307191535299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="4-4-MyISAM-辅助索引"><a href="#4-4-MyISAM-辅助索引" class="headerlink" title="4.4 MyISAM_辅助索引"></a>4.4 MyISAM_辅助索引</h3><p>辅助索引和主键索引在结构上没有什么区别，只是主索引要求key是唯一的，而辅助索引的key是可以重复的。<img src="https://img-blog.csdnimg.cn/20210307191712340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。<br>MyISAM索引方式叫非聚簇索引，主要是为了和InnoDB区分开。</p><h3 id="4-5-聚簇索引和非聚簇索引的区别"><a href="#4-5-聚簇索引和非聚簇索引的区别" class="headerlink" title="4.5 聚簇索引和非聚簇索引的区别"></a>4.5 聚簇索引和非聚簇索引的区别</h3><p><img src="https://img-blog.csdnimg.cn/20210307192105217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>聚簇索引按照主键聚集，叶子结点存储了主键值和数据行；二级索引的叶子结点存放主键值或者指向数据行的指针。<br>非聚簇索引叶子结点存储的是数据行的地址。</p><h3 id="4-6-覆盖索引"><a href="#4-6-覆盖索引" class="headerlink" title="4.6 覆盖索引"></a>4.6 覆盖索引</h3><p>一个索引包含了所有需要查询的字段的值，就称为覆盖索引。覆盖索引可以直接获取列的数据，而不用在读取数据行，所以效率比较高。</p><h4 id="覆盖索引的优点："><a href="#覆盖索引的优点：" class="headerlink" title="覆盖索引的优点："></a>覆盖索引的优点：</h4><ul><li>索引记录通常远小于全行大小。因此如果只读取索引，MySQL就能够极大地减少数据访问量。</li><li>对于IO密集型的负载也有帮助，因为索引比数据小很多，能够更好地装入内存。(这对于MyISAM尤其正确，它能够压缩索引；但是InnoDB不能够压缩索引)。</li><li>索引是按照索引值进行排序的，因此访问速度将会比随机从磁盘上读取快得多。</li><li>覆盖索引对InnoDB表特别有用，因为InnoDB的第二索引在叶子节点中保存了主键值。覆盖了查询的第二索引在主键中避免了另外一次索引查找。</li></ul><h3 id="4-7-哪些情况需要创建索引："><a href="#4-7-哪些情况需要创建索引：" class="headerlink" title="4.7 哪些情况需要创建索引："></a>4.7 哪些情况需要创建索引：</h3><ul><li>主键自动创建唯一索引；</li><li>频繁作为查询关键字的字段应该创建索引；</li><li>查询中与其它表关联的字段，外键关系建立索引；</li><li>频繁更新的字段不适合创建索引，因为每次更新需要重新调整索引；</li><li>Where 条件里用不到的字段不创建索引；</li><li>单键&#x2F;组合索引的选择问题？  高并发下倾向于创建组合索引；</li><li>查询中排序的字段，排序的字段如果通过索引去访问将大大提高速度；(Order by)</li><li>查询中统计或者分组字段； (group by)</li></ul><h3 id="4-8-哪些情况不适合创建索引："><a href="#4-8-哪些情况不适合创建索引：" class="headerlink" title="4.8 哪些情况不适合创建索引："></a>4.8 哪些情况不适合创建索引：</h3><ul><li>表的记录太少；</li><li>频繁增删改字段。因为同时需要去维护更新索引。</li><li>数据重复且平均分布的字段；</li></ul><h1 id="五、索引语法-重点"><a href="#五、索引语法-重点" class="headerlink" title="五、索引语法(重点)"></a>五、索引语法(重点)</h1><ol><li><p>创建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL]  INDEX  index_name [<span class="keyword">USING</span> index_type]  <span class="keyword">ON</span>  tbl_name(column_name);</span><br><span class="line"></span><br><span class="line"># 举例：在city数据表上 的 city_name 字段创建了索引</span><br><span class="line"><span class="keyword">create</span> index idx_city_name <span class="keyword">on</span> city(city_name);</span><br></pre></td></tr></table></figure></li><li><p>查看索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span>  index <span class="keyword">from</span> table_name\G;</span><br></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index index_name <span class="keyword">on</span> tbl_name;</span><br></pre></td></tr></table></figure></li><li><p>alter命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 给该表添加一个主键</span><br><span class="line">   <span class="keyword">alter</span> <span class="keyword">table</span> tbl_name <span class="keyword">add</span> <span class="keyword">primary</span> key(column_list);</span><br><span class="line">   </span><br><span class="line"><span class="number">2</span>) 添加唯一索引(可以出现多个<span class="keyword">null</span>)</span><br><span class="line">   <span class="keyword">alter</span> <span class="keyword">table</span> tbl_name <span class="keyword">add</span> <span class="keyword">unique</span> index_name(column_list);</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) 添加普通索引</span><br><span class="line">   <span class="keyword">alter</span> <span class="keyword">table</span> tbl_name <span class="keyword">add</span> index index_name(column_list);</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>) 指定全文索引</span><br><span class="line">   <span class="keyword">alter</span> <span class="keyword">table</span> tbl_name <span class="keyword">add</span> fulltext index_name(column_list);</span><br></pre></td></tr></table></figure></li></ol><p>参考文章：<br><a href="https://blog.csdn.net/lm1060891265/article/details/81482136">聚簇索引和非聚簇索引</a>：<a href="https://blog.csdn.net/lm1060891265/article/details/81482136">https://blog.csdn.net/lm1060891265/article/details/81482136</a></p><p><a href="https://blog.csdn.net/ruanhao1203/article/details/98061034">聚簇索引、非聚簇索引、覆盖索引 区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM、(三)垃圾回收机制</title>
      <link href="/2020/10/15/JVM%E3%80%81(%E4%B8%89)%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/10/15/JVM%E3%80%81(%E4%B8%89)%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、如何判断对象可以回收"><a href="#一、如何判断对象可以回收" class="headerlink" title="一、如何判断对象可以回收"></a>一、如何判断对象可以回收</h1><p><strong>1. 引用计数法</strong><br>每引用一次，就计数一次，当某个对象的引用计数为0时进行回收。<br>弊端：循环引用的两个对象永远得不到回收。<br><img src="https://img-blog.csdnimg.cn/20210302140852489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><span id="more"></span><p><strong>2. 可达性分析算法</strong><br>扫描堆中的对象，看能否沿着 <code>GC Root</code> 对象为起点的引用链找到该对象，找不到表示可以回收。</p><p><strong>3. 四种引用</strong></p><ul><li>强引用</li><li>软引用</li><li>弱引用</li><li>虚引用</li><li>终结器引用</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL、(一) Linux下的基础操作</title>
      <link href="/2020/10/15/Mysql%E3%80%81(%E4%B8%80)Linux%E4%B8%8BMysql%20%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/10/15/Mysql%E3%80%81(%E4%B8%80)Linux%E4%B8%8BMysql%20%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Linux下安装Mysql"><a href="#一、Linux下安装Mysql" class="headerlink" title="一、Linux下安装Mysql"></a>一、Linux下安装Mysql</h1><p>百度</p><span id="more"></span><h1 id="二、启动Mysql服务"><a href="#二、启动Mysql服务" class="headerlink" title="二、启动Mysql服务"></a>二、启动Mysql服务</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br><span class="line"></span><br><span class="line">service mysql stop</span><br><span class="line"></span><br><span class="line">service mysql status</span><br><span class="line"></span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><h1 id="三、登录Mysql"><a href="#三、登录Mysql" class="headerlink" title="三、登录Mysql"></a>三、登录Mysql</h1><ol><li><p>mysql 安装完成后会有一个随机密码，并保存在一个密码文件中 ：<code>/root/.mysql_secret</code></p></li><li><p>登录后修改密码：</p></li></ol><p>5.7版本： <code>set password = password(&#39;新密码&#39;)</code><br>8.0版本： <code>alter user &#39;root&#39;@&#39;%&#39; identified by &#39;123456&#39;</code><br>3. 远程授权访问： <code>grant all privileges on *.* to &#39;root&#39; @&#39;%&#39; identified by &#39;新密码&#39;;</code><br>4. 记住需要刷新：<code>flush privileges;</code><br>若此时仍然不能连接上，则考虑Linux的防火墙。</p><h1 id="四、用户权限"><a href="#四、用户权限" class="headerlink" title="四、用户权限"></a>四、用户权限</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 授权全部权限，除了给别人授权权限， 库.表</span><br><span class="line">grant all privileges on *.* to 用户名</span><br><span class="line"></span><br><span class="line">-- 查看用户权限</span><br><span class="line">show grant for 用户名</span><br><span class="line"></span><br><span class="line">-- 撤销权限</span><br><span class="line">revoke all privileges on *.* from 用户名</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客剑指offer(1~20题总结)</title>
      <link href="/2020/10/15/%E7%89%9B%E5%AE%A2%E5%89%91%E6%8C%87offer_t1~t20/"/>
      <url>/2020/10/15/%E7%89%9B%E5%AE%A2%E5%89%91%E6%8C%87offer_t1~t20/</url>
      
        <content type="html"><![CDATA[<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p><img src="/passageImg/%E7%89%9B%E5%AE%A2offer.assets/image-20210321231829369.png"></p><ul><li>思路：</li></ul><p>已知前序遍历： 根-左-右             中序遍历：左-根-右    还原二叉树</p><p>首先前序遍历的第一个点一定是当前树的根节点，那么可以根据其值在中序遍历中确定位置 i。这样就将原来树的中序遍历划分为了左子树和右子树的中序遍历。同样可以根据左右子树的长度再去前序遍历中进行左右子树的划分。</p><ul><li>扩展：</li></ul><p>这题如果是已知中序遍历和后序遍历也可以按照类似方法做。</p><span id="more"></span><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p><img src="/passageImg/%E7%89%9B%E5%AE%A2offer.assets/image-20210321232503056.png"></p><ul><li>思路</li></ul><p>这题实际上是要我们确定树B 是否是 树A的子树，而不是子节点。</p><ol><li>根据树B的 root 值到树A中去查询找到值相等的点；然后遍历以该点为根节点树的所有值是否和树B中对应点的值相等；</li><li>如果 步骤1 返回 false，那么继续判断树B 是否是 树A的左子树的子树；</li><li>如果 步骤2 返回 false，那么继续判断树B 是否是 树A的右子树的子树；</li></ol><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p><img src="/passageImg/%E7%89%9B%E5%AE%A2offer.assets/image-20210321232949116.png"></p><p>思路：</p><p>题目要求查找栈中的最小元素，而且要求时间复杂度为 O(1)</p><p>由于时间复杂度为 O(1)，必须是随机查找。这里可以使用双栈法。</p><p>双栈法：生成两个栈，栈2作为辅助栈，每次栈1 插入一个元素 栈2 也进行比较后插入；</p><p><a href="https://blog.nowcoder.net/n/ceb3214b89594af481ef9b794c75a929">https://blog.nowcoder.net/n/ceb3214b89594af481ef9b794c75a929</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM、(二)JVM的内存结构</title>
      <link href="/2020/10/14/JVM%E3%80%81(%E4%BA%8C)JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2020/10/14/JVM%E3%80%81(%E4%BA%8C)JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="一、程序计数器-PC"><a href="#一、程序计数器-PC" class="headerlink" title="一、程序计数器(PC)"></a>一、程序计数器(PC)</h1><h3 id="定义：-Program-counter-Register"><a href="#定义：-Program-counter-Register" class="headerlink" title="定义：  Program counter Register"></a>定义：  Program counter Register</h3><h3 id="作用：记住下一条JVM指令的执行地址。-通过寄存器来实现的"><a href="#作用：记住下一条JVM指令的执行地址。-通过寄存器来实现的" class="headerlink" title="作用：记住下一条JVM指令的执行地址。(通过寄存器来实现的)"></a>作用：记住下一条JVM指令的执行地址。(通过寄存器来实现的)</h3><p> <img src="https://img-blog.csdnimg.cn/20210301110052481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><span id="more"></span><p>二进制字节码通过解释器被解释为机器码，然后机器码才能够交给CPU去执行。<br>当第1条JVM指令被解释翻译执行后 程序计数器会去记录下一条JVM指令的执行地址然后接着执行。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><pre><code>* **线程私有的**。程序运行时会开启多个线程，CPU会对这些线程进行调度，每个线程有着自己的时间片。当时间到但是线程1还未执行完，线程1的程序计数器便会记录此时执行到的指令的位置；然后切换到线程2去执行，同理线程2也有自己的程序计数器。</code></pre><p><img src="https://img-blog.csdnimg.cn/2021030111052214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    * <strong>不会存在内存溢出</strong>。</p><h1 id="二、虚拟机栈-Virtual-Stack"><a href="#二、虚拟机栈-Virtual-Stack" class="headerlink" title="二、虚拟机栈(Virtual Stack)"></a>二、虚拟机栈(Virtual Stack)</h1><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><ol><li>栈 - 线程运行需要的内存空间；由多个栈帧(Frame)组成。</li><li>栈帧 - 每个方法调用时需要的内存；</li><li>栈与栈帧的关系 - 每个线程只能有一个活动栈帧，对应着正在执行的那个方法(位于栈顶部的那个栈帧)；</li><li>一个栈中可能存在多个栈帧。<br>比如说某个方法执行时会需要一些参数、局部变脸、返回地址。这些都被记录在栈帧这个内存空间中。也可能在执行该方法时还调用了其余的方法，此时该栈中就会存储多个栈帧，当方法执行完后栈帧便会出栈，内存自动释放掉。<br><img src="https://img-blog.csdnimg.cn/20210301111739866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="面试问题："><a href="#面试问题：" class="headerlink" title="面试问题："></a>面试问题：</h3></li><li>垃圾回收是否涉及栈内存？<br>不涉及，因为栈内存是随着线程中方法执行的结束而弹出栈自动释放掉的。</li><li>栈内存分配越大越好吗？<br>不是，因为物理内存的大小是一定的。如果栈内存划分大，那么能够执行的线程数就会减少，它只能够方便进行更多次的方法递归调用，不会增大方法运行的效率。<br><img src="https://img-blog.csdnimg.cn/20210301112623779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>方法内的局部变量是否是线程安全的？<br>如果方法内局部变量没有逃离方法的作用范围就是线程安全的；反之不安全，比如局部变量作为方法返回值返回，有可能被其它线程使用。<br>举例：<br><img src="https://img-blog.csdnimg.cn/20210301113800529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>方法1中的 StringBuilder是线程私有的，因为它是作为局部变量出现的；<br>方法2中的不是线程安全的，因为作为引用类型出现它可能还会被其它线程所引用，比如说在main 方法中开启了新线程调用 m2(StringBuilder sb)方法。<br>方法3中的 StringBuilder不是线程安全的，因为它将 StringBuilder作为返回值返回，那么其它线程就有可能拿到这个值去修改 。</li></ol><h3 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h3><ul><li>栈帧过多(递归爆炸)；</li><li>栈帧过大(不太容易出现)；</li><li>实例：<br><img src="https://img-blog.csdnimg.cn/2021030111524247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210301115410241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210301115506978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h3></li></ul><ol><li>CPU占用过多：</li></ol><ul><li>使用 <code>top</code>  定位哪个进程对CPU的占用过高；</li><li><code>ps H -eo pid,tid,%cpu | grep 进程id</code> (使用ps命令进一步定位是哪个线程引起的cpu占用过高)</li><li><code>jstack 进程id</code>  获取指定进程的线程运行情况；可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号。<br><img src="https://img-blog.csdnimg.cn/20210301132132807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是 jstack 打印出的线程编号是 16进制的，需要首先将 十进制的存在问题的线程编号换算为16进制然后去 jstack 打印结果中寻找。</li></ul><ol start="2"><li>程序运行很长时间没有结果</li></ol><ul><li>比如说死锁问题<br><img src="https://img-blog.csdnimg.cn/20210301132915467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h1><ul><li>概念：Java代码调用本地方法时所占用的内存。给本地方法的运行提供内存空间。<br>本地方法举例：<br><img src="https://img-blog.csdnimg.cn/20210301133729544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="四、堆"><a href="#四、堆" class="headerlink" title="四、堆"></a>四、堆</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>概念： 通过 new 关键字创建的对象都会使用到堆内存；</li><li>特点： <ul><li>堆是线程共享的，堆中的对象都需要考虑线程安全问题；</li><li>有垃圾回收机制。</li></ul></li></ul><h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><ul><li>举例：<br><img src="https://img-blog.csdnimg.cn/20210301134606201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>报错：<code> java.lang.OutOfMemoryError:java heap space</code><br>可以通过  <code>-Xmx堆内存大小</code>  来设置程序中堆的内存<br><img src="https://img-blog.csdnimg.cn/20210301134724553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h3></li></ul><ol><li>jps 工具： 查看当前系统中有哪些 java进程；</li><li>jmap 工具：查看堆内存占用情况；</li><li>jconsole 工具：图形界面的，多功能的监测工具，可以连续监测；<br>注意使用时需要保证 项目jdk版本和 idea版本一致。<br>详细参考<a href="https://blog.csdn.net/sugar_cookie/article/details/100575726">jhsdb jmap –heap –pid 进程号** **报错</a><br>   <a href="https://blog.csdn.net/qq_32360995/article/details/91849864">IntelliJ IDEA设置JDK版本</a></li></ol><p>应用实例1：<br><img src="https://img-blog.csdnimg.cn/2021030113573367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210301135801726.png" alt="在这里插入图片描述"><br><code>jps</code>   : 查看系统中的java进程。 如果报错需要切换到 jdk安装目录的bin目录下进行。<br><img src="https://img-blog.csdnimg.cn/20210301135835330.png" alt="在这里插入图片描述"><br><code>jmap -heap  进程id</code>：查看对应进程的堆内存占用情况</p><p><img src="https://img-blog.csdnimg.cn/2021030114002979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>堆分配前：<br><img src="https://img-blog.csdnimg.cn/20210301140045624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>堆分配后：<br><img src="https://img-blog.csdnimg.cn/20210301140148894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>gc回收后：<br><img src="https://img-blog.csdnimg.cn/20210301140210273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>应用案例2：<br> <img src="https://img-blog.csdnimg.cn/20210301141102502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用 <code>jvisualvm</code> 来监控进程的堆内存分配：<br><img src="https://img-blog.csdnimg.cn/2021030114121995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210301141333702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210301141412959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210301141443431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="五、方法区"><a href="#五、方法区" class="headerlink" title="五、方法区"></a>五、方法区</h1><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><ol><li><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p></li><li><p>方法区与堆一样都是各个线程共享的内存区域；</p></li><li><p>方法区在JVM启动的时候被创建，并且它的实际物理内存空间中和Java堆区一样都可以是不连续的；</p></li><li><p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutOfMemoryError:PermGen space </code> 或者 <code>java.lang.OutOfMemoryError:Metaspace</code><br><img src="https://img-blog.csdnimg.cn/20210301163220965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210301163230888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>   <img src="https://img-blog.csdnimg.cn/2021030116220754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol><ul><li>jvm1.6 用了一个永久代(PermGen)作为方法区的实现，永久代中包含了运行时常量池(<code>StringTable</code>)、类加载器(<code>ClassLoader</code>)、类的相关信息(<code>Class</code>)；</li><li>jvm1.8 后用元空间代替了永久代作为方法区的实现。元空间和方法区类似，都是对JVM中方法区的实现，不过元空间与永久代的最大区别在于：元空间不在虚拟机设置的内存中、而是使用本地内存。不过1.8将 StringTable移动到了堆中。这是因为永久代的回收效率很低(需要 FULLGC时才能触发垃圾回收 )这样会占用大量的内存，而StringTable在堆中只需要 Minor GC时便能够触发垃圾回收，能够大大减轻字符串对内存的占用。</li><li>运行时常量池 VS 常量池：<br>方法区中包含了运行时常量池；字节码文件中包含了常量池；一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用。</li><li>为什么需要常量池？<br>一个Java 源文件中的类、接口 编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存储在字节码中，换另一种方式，可以存到常量池中，这个字节码包含了指向常量池的引用。在动态连接的时候回到运行时常量池。</li><li>常量池中有什么？<br>数量值、字符串值、类引用、字段引用、方法引用。</li><li>运行时常量池：<ul><li>运行时常量池是在jvm虚拟机完成类装载操作之后，将class文件中的常量池载入到内存中，并保存在方法区中。</li><li>运行时常量池中包含多种不同的常量，包括编译器期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</li><li>运行时常量池相对于Class文件中的常量池的另一重要特征是：具备动态性。</li></ul></li></ul><h3 id="方法区的内存溢出"><a href="#方法区的内存溢出" class="headerlink" title="方法区的内存溢出"></a>方法区的内存溢出</h3><p><img src="https://img-blog.csdnimg.cn/20210301171455803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过循环20000次来往方法区中加载多个类的信息，使得方法区内存溢出。</p><p><img src="https://img-blog.csdnimg.cn/20210301171440744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是只有在 JVM1.6之前才有可能产生方法区内存溢出，因为它使用的是虚拟机的内存，而JVM1.8以后使用的是本地内存很大不会溢出。但是在修改了虚拟机参数后可以做到内存溢出。 <code>-XX:MaxMetaspaceSize=8m</code><br><img src="https://img-blog.csdnimg.cn/20210301171819834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ul><li>常量池就是一张表，字节码文件中的虚拟机指令根据这张表找到需要执行的类名、方法名、参数类型、字面量等信息。</li><li>字节码文件中包含了 类的基本信息(版本号、字段)，常量池，类方法定义，虚拟机指令。 查看字节码信息： <code>javap -v xxx.class</code></li></ul><p><img src="https://img-blog.csdnimg.cn/20210301173643345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2021030117360181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210301173628887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210301173708375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210301173722937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210301173756330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul><li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入到运行时常量池，并把里面的符号地址变为真实地址。<h4 id="StringTable-面试题："><a href="#StringTable-面试题：" class="headerlink" title="StringTable 面试题："></a>StringTable 面试题：</h4><img src="https://img-blog.csdnimg.cn/20210301205918569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h4 id="StringTable-实例："><a href="#StringTable-实例：" class="headerlink" title="StringTable 实例："></a>StringTable 实例：</h4><ol><li><p>基础的  <code>String str = &quot;xxx&quot;</code><br><img src="https://img-blog.csdnimg.cn/202103011750588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>常量池中的信息，都会被加载到运行时常量池中。开始时 a、b、ab 都是作为常量池中的符号，还没有变为 java字符串对象。等到程序运行到这里时，字节码中的虚拟机指令(<code>ldc</code>)会将该符号变为字符串对象，并且放入到串池(<code>StringTable</code>，是一个 hashtable结构，不能扩容)中。每次都会先到串池中检查是否有对应的字符串，如果不存在再创建然后加入。</p></li><li><p>字符串拼接 <code>String s4 = s1 + s2</code><br><img src="https://img-blog.csdnimg.cn/20210301202156296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210301202249922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210301202317710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因此得到结果为 false</p></li><li><p>字符串拼接 <code>String s4 = &quot;a&quot; + &quot;b&quot;</code><br><img src="https://img-blog.csdnimg.cn/20210301202654467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>底层做法：javac在编译期间的优化，结果已经在编译期间确定为 “ab”；而 <code>String s4 = s1 + s2</code> 中s1与 s2均为变量可能在之后发生变化，因此不能提前确定，必须在运行期间使用 <code>StringBuilder</code> 获取。</p></li><li><p>使用 <code>intern</code> 方法主动将字符串放入串池<br>JDK 1.8下：<br><img src="https://img-blog.csdnimg.cn/20210301204143372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210301205445998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210301204643456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>JDK 1.6下：<br><img src="https://img-blog.csdnimg.cn/20210301205310831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><code>s.intern()</code> ：</p><ul><li>会尝试将字符串s  放入到串池中，如果串池中有则不会放入，如果没有则放入。最终会返回串池中的对象。（1.7、1.8中）；</li><li>会将字符串s 拷贝一份并将该拷贝的那份放入串池中，而原本的字符串s 如果存在于堆中，此时仍然在堆中。最终返回串池中的对象(1.6中)</li></ul><h4 id="StringTable特性："><a href="#StringTable特性：" class="headerlink" title="StringTable特性："></a>StringTable特性：</h4><ol><li>常量池中的字符串仅是符号，第一次用到才变为对象；</li><li>利用串池的机制，来避免重复创建字符串对象；</li><li>字符串变量拼接的原理是 StringBuilder（1.8中）；</li><li>字符串常量拼接的原理是编译期优化；</li><li>可以使用 <code>intern</code> 方法，主动将串池中还没有的字符串对象放入串池。</li></ol><h4 id="StringTable位置："><a href="#StringTable位置：" class="headerlink" title="StringTable位置："></a>StringTable位置：</h4><p>1.8以前 StringTable 位于永久代中，需要满足 FULLGC时才能触发垃圾回收，会造成大量内存空间无法被回收；<br>1.8以后 StringTable 位于堆中，需要满足 MinorGC 时才能触发垃圾回收，因此能够大大减少字符串占用的内存空间，及时回收。</p><ul><li>证明如下：<br><img src="https://img-blog.csdnimg.cn/20210302093721121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>jvm1.6 下循环26000次往 StringTable中放入字符串，同时设置永久代的最大内存空间：<code>-XX:MaxPermSize=10m</code>；<br>此时会报错 <code>OutOfMemoryError ：PermGen space</code>，说明1.6中 StringTable确实位于永久代中。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210302093935796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>jvm1.8下会报错 <code>GC overhead limit exceeded</code>，这是由于垃圾回收的一个限制导致的<code>UseGCOverheadLimit</code>(如果98%的时间花费到垃圾回收上，但是只有2%的堆空间被回收，就会触发该错误)。<br><img src="https://img-blog.csdnimg.cn/20210302094234300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时需要添加相应的虚拟机参数：<code>-Xmx10m -XX:-UseGCOverheadLimit</code><br><img src="https://img-blog.csdnimg.cn/20210302094405474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如图所示，此时报错 <code>Java heap space</code> 堆空间不足，证明1.8中 StringTable位于堆中。<br><br></p><h4 id="StringTable垃圾回收机制："><a href="#StringTable垃圾回收机制：" class="headerlink" title="StringTable垃圾回收机制："></a>StringTable垃圾回收机制：</h4><p> 虚拟机配置： <code>-Xmx10m -XX:+PrintStringTableStatisttics -XX:+PrintGCDetails -verbose:gc</code><br><img src="https://img-blog.csdnimg.cn/20210302095211383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302095257312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302095347265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302095413919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="StringTable性能调优："><a href="#StringTable性能调优：" class="headerlink" title="StringTable性能调优："></a>StringTable性能调优：</h4><ol><li>调整StringTable 中桶的个数：</li></ol><ul><li>命令： <code>-XX:StringTableSize=桶个数(最小1009)</code><br><img src="https://img-blog.csdnimg.cn/20210302102004343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210302102047504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302102127928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302102211523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><ol start="2"><li>考虑将字符串对象是否入池<br><img src="https://img-blog.csdnimg.cn/20210302102759510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302102829319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开 jvisualvm可以发现String、char数组占用了80%的内存；</li></ol><p><img src="https://img-blog.csdnimg.cn/20210302102942140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302103025985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以发现字符串入池后 占用的内存只有30%左右</p><h1 id="六、直接内存"><a href="#六、直接内存" class="headerlink" title="六、直接内存"></a>六、直接内存</h1><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul><li>Direct Memory，直接内存是属于操作系统的内存；</li><li>常见于 NIO操作时，用于数据缓冲区；</li><li>分配回收成本较高，但是读写性能高；</li><li>不受 JVM 内存回收管理；<h3 id="案例对比"><a href="#案例对比" class="headerlink" title="案例对比"></a>案例对比</h3><img src="https://img-blog.csdnimg.cn/2021030210422312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302110142430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302110149677.png" alt="在这里插入图片描述"></li></ul><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="https://img-blog.csdnimg.cn/20210302111801870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>首先Java代码本身不具有读写文件的能力，它需要调用操作系统的方法来进行文件读写。CPU 方面会由用户态切换为内核态；内存方面会在系统内存划分一块系统缓存区，将磁盘文件读取到系统缓冲区然后再将系统缓冲区中的文件数据读取到Java 缓冲区(堆内存分配的)。<br>但是这样依赖就需要开辟两份缓冲区，这样会造成不必要的数据复制，效率不高。</p><br><p><img src="https://img-blog.csdnimg.cn/20210302112134280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用 ByteBuffer 后则会开辟一块Java和系统都能够共享的区域 <code>direct memory</code>（直接内存），这样一来就不用重复复制效率便提高了。</p><h3 id="内存释放原理"><a href="#内存释放原理" class="headerlink" title="内存释放原理"></a>内存释放原理</h3><p><img src="https://img-blog.csdnimg.cn/20210302113400388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302113458711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>使用     <code>Unsafe</code> 对象完成直接内存的分配(<code>allocateMemory</code>)回收(<code>freeMemory</code>)，并且回收需要主动调用     <code>freeMemory</code> 方法。</li><li><code>ByteBuffer</code> 的实现类内部，使用了 <code>Cleaner</code>(虚引用) 来监测<code>ByteBuffer</code> 对象，一旦 <code>ByteBuffer</code> 对象被垃圾回收，那么就会由     <code>ReferenceHandler</code> 线程通过 <code>Cleaner</code> 的clean 方法调用 <code>freeMemory</code> 来释放直接内存。</li></ol><ul><li>源码分析：<br><img src="https://img-blog.csdnimg.cn/20210302113729174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302113748955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021030211414456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302115534270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p><img src="https://img-blog.csdnimg.cn/20210302114019946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="禁用显示回收对直接内存的影响"><a href="#禁用显示回收对直接内存的影响" class="headerlink" title="禁用显示回收对直接内存的影响"></a>禁用显示回收对直接内存的影响</h3><p>一般会禁用 <code>System.gc()</code> 来避免显式的进行垃圾回收。但是显式gc被禁用 ByteBuffer就不能被回收，相应的直接内存就得不到释放。因此一般推荐使用 <code>UnSafe</code> 对象直接 <code>freeMemory</code> 进行释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_1GB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射获取UnSafe 实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            unsafe = (Unsafe) f.get(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配直接内存并且回收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line">        <span class="comment">//分配内存</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> unsafe.allocateMemory(_1GB);</span><br><span class="line">        unsafe.setMemory(base,_1GB,(<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放内存</span></span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<br><a href="https://segmentfault.com/a/1190000014395186">JVM 完整深入解析</a><br><a href="https://zhuanlan.zhihu.com/p/43279292">JVM系列(二) - JVM内存区域详解</a><br><a href="https://blog.csdn.net/weixin_44556968/article/details/109270921">JVM –方法区（超详细）</a><br><a href="https://www.cnblogs.com/lxcmyf/p/7044998.html">Java常量池详解</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM、(一)JVM开篇</title>
      <link href="/2020/10/14/JVM%E3%80%81(%E4%B8%80)JVM%E5%BC%80%E7%AF%87/"/>
      <url>/2020/10/14/JVM%E3%80%81(%E4%B8%80)JVM%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="一、JVM是什么？"><a href="#一、JVM是什么？" class="headerlink" title="一、JVM是什么？"></a>一、JVM是什么？</h1><ul><li>定义：<br>Java Virtual Machine - java程序的运行环境 （Java 二进制字节码的运行环境）<br>比如  Helloworld.java  程序通过javac编译成了 class字节码然后被加载到java虚拟机中运行。</li><li>好处：<ol><li><strong>跨平台实现的基石</strong>。  Java程序一次编译，到处运行，JVM屏蔽了字节码和底层操作系统之间的差异，使得编译后的二进制字节码文件能够运行在不同的操作系统平台上。</li><li><strong>自动内存管理，垃圾回收功能</strong>。</li><li><strong>数组下标越界越界检查</strong>。</li><li><strong>多态</strong>。</li></ol></li></ul><span id="more"></span><ul><li>比较(jre、jdk、jvm)：<br><img src="https://img-blog.csdnimg.cn/20210301103607997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>jre：java runtime environment(Java运行时环境)   jvm结合一些基础类库构成了jre；<br>jdk：java development kit(Java 开发工具包)  jvm+基础类库+编译工具构成 jdk；</li></ul><h1 id="二、常见的JVM"><a href="#二、常见的JVM" class="headerlink" title="二、常见的JVM"></a>二、常见的JVM</h1><p><img src="https://img-blog.csdnimg.cn/20210301104104524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="三、学习路线"><a href="#三、学习路线" class="headerlink" title="三、学习路线"></a>三、学习路线</h1><p><img src="https://img-blog.csdnimg.cn/20210301104635177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>重点：</p><ul><li>JVM主要涉及三大块：  类加载器<code>ClassLoader</code>、JVM内存结构(方法区、堆、虚拟机栈、本地方法栈、程序计数器)、执行引擎(解释器、即时编译器、垃圾回收)</li><li>一个java程序通过编译为二进制字节码文件，但是字节码文件必须通过类加载器<code>ClassLoader</code> 才能成功加载到JVM中去执行。方法区存放是的java类；堆存放的是类实例化的对象；当对象调用方法时会使用到虚拟机栈、本地方法栈、程序计数器；方法执行时是由执行引擎的解释器逐行解释执行的，方法里的热点代码(频繁调用)会被<code>JIT Compiler</code>即时编译器优化后执行；GC会对堆中一些不再引用的对象进行回收。Java还有一些方法需要调用底层操作系统相关方法，通过本地方法接口实行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis(7).集群</title>
      <link href="/2020/10/12/Redis%EF%BC%9A%E4%B8%83%E3%80%81%E9%9B%86%E7%BE%A4/"/>
      <url>/2020/10/12/Redis%EF%BC%9A%E4%B8%83%E3%80%81%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="一、集群是什么？"><a href="#一、集群是什么？" class="headerlink" title="一、集群是什么？"></a>一、集群是什么？</h1><p>集群：集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果。</p><p>集群的作用：</p><ul><li>分散单台服务器的访问压力，实现负载均衡；</li><li>分散单台服务器的存储压力，实现可扩展性；</li><li>降低单台服务器宕机带来的业务灾难。</li></ul><span id="more"></span><h1 id="二、集群的存储结构设计"><a href="#二、集群的存储结构设计" class="headerlink" title="二、集群的存储结构设计"></a>二、集群的存储结构设计</h1><p><img src="https://img-blog.csdnimg.cn/20210228142040114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于输入的一个key，不是直接将其存储到某台服务器中，而是通过算法设计计算出应该存放的位置，之后再存储。</p><p><img src="https://img-blog.csdnimg.cn/20210228142533410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>如果此时集群中加入了新的服务器，那么各个服务器需要需要给出各自的部分空间组成新的存储空间(给出的空间称为槽)。各个机器持有一定的槽，当加机器时分出自己的部分槽给新的机器，减机器时再将这些槽返回给其余机器。<br>不管多少台服务器，槽(<code>slot</code>)的总数不变都是16387，但是随着空间的增大每个槽的内存变大了。从而实现了扩容。</p><p><img src="https://img-blog.csdnimg.cn/20210228143534162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>各个数据库相互通信，每个数据库都持有所有槽的编号数据。<br>当一个key经过两次算法计算得到具体的位置数值，如果此时访问A会去A中查找，如果命中了直接返回。如果一次未命中，则告知具体的位置直接去查找。</p><ul><li>槽用来区分数据的存储空间；</li><li>key 用来加密后确定数据的存储位置；</li><li>一次命中或者两次命中就能够找到我们的数据。</li><li>主机有槽但是从机没有槽，从机需要从主机那里复制过来。</li></ul><h1 id="三、集群的搭建"><a href="#三、集群的搭建" class="headerlink" title="三、集群的搭建"></a>三、集群的搭建</h1><ol><li><p>修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 开启集群</span><br><span class="line">cluster-enabled   yes</span><br><span class="line"></span><br><span class="line"># 集群中单台机器的配置文件(每台机器不同需要区分开)</span><br><span class="line">cluster-config-file  nodes-6379.conf     </span><br><span class="line"></span><br><span class="line"># 机器下线时间(下线多久后得到反馈)</span><br><span class="line">cluster-node-timeout 10000</span><br></pre></td></tr></table></figure></li><li><p>安装 ruby<br>由于 redis 集群需要使用 ruby命令，因此我们需要安装 ruby，步骤如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install ruby  #安装ruby</span><br><span class="line">yum install rubygems  #ruby的包管理器gems，运行gem文件</span><br></pre></td></tr></table></figure></li><li><p>启动六个redis实例(redis-server  xxx.conf)</p></li><li><p>搭建集群(新版本已经不推荐使用ruby脚本的方式来搭建集群了):<br>切换到 redis安装目录下的src目录下，执行里面的 redis-trib.rb ruby脚本文件<br><code>./redis-trib.rb create --replicas 1 主机1ip:port   主机2ip:port ....  从机1ip:port    从机2ip:port  .....</code><br><img src="https://img-blog.csdnimg.cn/20210228145750110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>新版本建议使用：<br><code>redis-cli --cluster create 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 --cluster-replicas 1</code><br><img src="https://img-blog.csdnimg.cn/20210228163537829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">5. 数据存取<br>连接客户端时使用:  <code>redis-cli -c -p xxx</code>  这样能够做到自动路由到数据存储点<br><img src="https://img-blog.csdnimg.cn/20210228164002866.png" alt="在这里插入图片描述"></p></li></ol><h1 id="四、主从下线和主从切换"><a href="#四、主从下线和主从切换" class="headerlink" title="四、主从下线和主从切换"></a>四、主从下线和主从切换</h1><p><strong>1. 主从下线</strong></p><ul><li>如果从机宕机： 从机宕机后不影响主机和其余机器，当从机恢复后重新从主机那里同步数据，恢复slave身份。<br><img src="https://img-blog.csdnimg.cn/20210228165138953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>如果主机宕机： 主机宕机后会从从机中选举出一个服务器作为新主机。这时即使原本的主机恢复，它的身份就变为了从机。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210228165732685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Cluster配置<br><img src="https://img-blog.csdnimg.cn/20210228165859247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>Cluster节点操作命令<br><img src="https://img-blog.csdnimg.cn/20210228170204513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p>参考文章：<br><a href="https://www.cnblogs.com/jingzh/p/14418666.html">Redis集群的简单搭建</a><br><a href="https://www.cnblogs.com/qingdaofu/p/7399670.html">DNS递归查询与迭代查询</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis(8).企业级解决方案</title>
      <link href="/2020/10/12/Redis%EF%BC%9A%E5%85%AB%E3%80%81%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88(%E9%87%8D%E7%82%B9)/"/>
      <url>/2020/10/12/Redis%EF%BC%9A%E5%85%AB%E3%80%81%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88(%E9%87%8D%E7%82%B9)/</url>
      
        <content type="html"><![CDATA[<h1 id="一、缓存预热"><a href="#一、缓存预热" class="headerlink" title="一、缓存预热"></a>一、缓存预热</h1><ul><li><p>概念： 缓存预热就是在系统启动前，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询实现被预热的缓存数据！</p></li><li><p>解决方案：<br><img src="https://img-blog.csdnimg.cn/20210228173013233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><span id="more"></span><h1 id="二、缓存雪崩"><a href="#二、缓存雪崩" class="headerlink" title="二、缓存雪崩"></a>二、缓存雪崩</h1><ul><li>概念：缓存雪崩可以理解为原有缓存失效，新缓存还未到期间(例如：我们设置的缓存过期时间相同，统一时间大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库和CPU和内存产生巨大压力，严重的造成宕机影响。从而造成一连锁的反应，致使整个系统崩溃。</li></ul><p>正常缓存的获取图：<br><img src="https://img-blog.csdnimg.cn/20210228192035990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>缓存失效瞬间：<br><img src="https://img-blog.csdnimg.cn/20210228192057666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>解决方案：<br><img src="https://img-blog.csdnimg.cn/20210228192828691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210228193440205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021022820103977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>加锁方法详解：</p></li></ul><p>(1)一般并发量不是特别高的时候可以通过 <code>加锁排队</code> 的方式来解决高访问量问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">cacheTime</span> <span class="operator">=</span> <span class="number">30</span>;                  <span class="comment">//缓存过期时间</span></span><br><span class="line"><span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">&quot;product&quot;</span>;         <span class="comment">//缓存key</span></span><br><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> cahceKey;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProduct</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">cacheValue</span> <span class="operator">=</span> CacheHelper.get(cacheKey);</span><br><span class="line">     <span class="keyword">if</span>(cacheValue!=<span class="literal">null</span>) </span><br><span class="line">       <span class="keyword">return</span> cacheValue;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(lockKey)&#123;</span><br><span class="line">           cacheValue = CacheHelper.get(cacheKey);</span><br><span class="line">           <span class="keyword">if</span>(cacheValue!=<span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">return</span> cacheValue;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="comment">//从数据库查询数据</span></span><br><span class="line">              cacheValue = GetDataFromDB();</span><br><span class="line">              <span class="comment">//查询出的结果存入缓存</span></span><br><span class="line">              CacheHelper.AddCacheData(cacheKey,cacheValue,cacheTime);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cacheValue;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： </p><ol><li>加锁排队的方法只是为了减轻数据库压力，没有提高系统的访问量。假设此时有1000个用户请求访问但999个请求都被阻塞了，会导致用户请求访问超时。</li><li>加锁排队的解决方式分布式环境的并发问题，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差！因此，在真正的高并发场景下很少使用！</li></ol><p>(2)给每一缓存数据设置缓存标记，用于记录缓存是否失效，如果缓存标记时效则后台开启线程刷新缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">cacheTime</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">&quot;product&quot;</span>;</span><br><span class="line"><span class="comment">//缓存标记</span></span><br><span class="line"><span class="type">String</span> <span class="variable">cacheSign</span> <span class="operator">=</span> cacheKey + <span class="string">&quot;-sign&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProduct</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">signValue</span> <span class="operator">=</span> CacheHelper.get(cacheSign);</span><br><span class="line"><span class="type">String</span> <span class="variable">cacheValue</span> <span class="operator">=</span> CacheHelper.get(cacheKey);</span><br><span class="line"><span class="keyword">if</span>(signValue!=<span class="literal">null</span>)     <span class="comment">//未过期</span></span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    CacheHelper.AddCacheData(cacheSign,<span class="string">&quot;1&quot;</span>,cacheTime);</span><br><span class="line">    ThreadPool.QueueUserWorkItem((arg) -&gt; &#123;</span><br><span class="line">         <span class="comment">//数据查询</span></span><br><span class="line">         cacheValue = GetDataFromDB();</span><br><span class="line">         <span class="comment">//设置数据缓存过期时间为缓存标记过期时间的二倍</span></span><br><span class="line">         CacheHelper.AddCacheData(cacheKey,cacheValue,<span class="number">2</span> * cacheTime);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>缓存标记用于记录缓存数据是否过期，当缓存标记失效时需要触发其余线程到后台更新数据缓存；</li><li>缓存数据过期时间设置为缓存标记的2倍，这样能够保证当标记过期后数据仍然能用，直到线程重新从数据库获取新的缓存值进行更新。</li></ol><h1 id="三、缓存穿透"><a href="#三、缓存穿透" class="headerlink" title="三、缓存穿透"></a>三、缓存穿透</h1><ul><li>概念：缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</li><li>解决方案：<br><img src="https://img-blog.csdnimg.cn/20210228211224170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><ol><li>Bloom filter(布隆过滤器)</li></ol><p>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p><p>我们知道Redis之所以快除了单线程避免了CPU上下文切换,采用了epoll机制,还有一个重要的问题是他的存储结构,时间复杂度是o(1),但是redis的存储空间是很珍贵的,过多的key对于redis来说是一件麻烦的事情,比如你有几亿个key,这种一股脑的丢到Redis,很不合理.Bloom Filter或许就是一种改善的解决方案,极大的减小了存储空间.布隆过滤器是一个位向量或者说是位数组。</p><p>但是对于布隆过滤器的使用一定要谨慎,Bloom过滤器比较鸡肋的地方是它存在一定的概率的误判,我们在学术上称他为假阳性,而且随着元素的增加,这种误判的机率会随着增加,但是误判的概率几乎可以忽略,影响不到,一般key不多的情况,用散列表就可以了,唯一的好处就是节省空间.目前它只支持add和isExist操作,不支持delete操作,这个理解它的原理的很容易明白,因为你删除更新那一位1,正好可能也是别的key的entry.</p><ol start="2"><li>如果一个数据返回为空，我们仍然将这个空值进行缓存，但是将它的过期时间设置很短，这样第二次访问时缓存中就有值了，不会继续访问数据库。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">cacheTime</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">&quot;product&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProduct</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheValue</span> <span class="operator">=</span> CacheHelper.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span>(cacheValue == <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//查询数据库</span></span><br><span class="line">        cacheValue = GetDataFromDB();</span><br><span class="line">        <span class="keyword">if</span>(cacheValue == <span class="literal">null</span>)</span><br><span class="line">            cacheValue = string.Empty;   <span class="comment">//设置为默认值也缓存起来</span></span><br><span class="line">        CacheHelper.AddCacheData(cacheKey,cacheValue,cacheTime);</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、缓存击穿"><a href="#四、缓存击穿" class="headerlink" title="四、缓存击穿"></a>四、缓存击穿</h1></li></ol><ul><li>概念：Redis中某个高热数据过期的瞬间，但是该数据的访问量巨大，多个数据请求压到Redis后均未命中，Redis在短时间内发起大量对数据库中同一数据的访问。</li><li>解决方案：<br><img src="https://img-blog.csdnimg.cn/20210228210527456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="五、性能指标监控"><a href="#五、性能指标监控" class="headerlink" title="五、性能指标监控"></a>五、性能指标监控</h1><ul><li>需要监控的指标<br><img src="https://img-blog.csdnimg.cn/20210228211755339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210228211901971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210228211909335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210228212002997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p><img src="https://img-blog.csdnimg.cn/20210228212130835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>性能指标监控方法：<br><img src="https://img-blog.csdnimg.cn/20210228212352134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p>参考文章：<br><a href="https://www.cnblogs.com/leeSmall/p/8594542.html">Redis系列十：缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级</a></p><p><a href="https://www.cnblogs.com/cjsblog/p/11613708.html">Bitmap简介</a></p><p><a href="https://www.jianshu.com/p/476d2240d191?from=timeline">Redis 四连发:缓存雪崩、穿透、预热、降级</a></p><p><a href="https://www.cnblogs.com/linxiyue/p/10955533.html">Redis中的LFU算法</a></p><p><a href="https://www.cnblogs.com/wyq178/p/9976815.html">LRU算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis(6).哨兵模式</title>
      <link href="/2020/10/12/Redis%EF%BC%9A%E5%85%AD%E3%80%81%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/10/12/Redis%EF%BC%9A%E5%85%AD%E3%80%81%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、哨兵模式简介"><a href="#一、哨兵模式简介" class="headerlink" title="一、哨兵模式简介"></a>一、哨兵模式简介</h1><p>哨兵(Sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制来选举出新的master并将所有的slave连接到新的master。<br>哨兵也是一台redis服务器，只不过不提供数据服务。<br>哨兵通常配置为单数。</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/20210227193039802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="二、哨兵的搭建"><a href="#二、哨兵的搭建" class="headerlink" title="二、哨兵的搭建"></a>二、哨兵的搭建</h1><p><img src="https://img-blog.csdnimg.cn/20210227193334966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>sentinel.conf 配置文件解读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># Example sentinel.conf</span><br><span class="line"></span><br><span class="line"># port &lt;sentinel-port&gt;</span><br><span class="line">port 8001</span><br><span class="line"></span><br><span class="line"># 守护进程模式</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># 指明日志文件名</span><br><span class="line">logfile &quot;./sentinel1.log&quot;</span><br><span class="line"></span><br><span class="line"># 工作路径，sentinel一般指定/tmp比较简单</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"># 哨兵监控这个master，在至少quorum个哨兵实例都认为master down后把master标记为odown</span><br><span class="line"># （objective down客观down；相对应的存在sdown，subjective down，主观down）状态。</span><br><span class="line"># slaves是自动发现，所以你没必要明确指定slaves。</span><br><span class="line"># 通常哨兵数量设置为单数，quorum = 哨兵数量/2 +1</span><br><span class="line">sentinel monitor MyMaster 127.0.0.1 7001 1</span><br><span class="line"></span><br><span class="line"># master或slave连接多长时间（默认30秒）不能使用后标记为s_down状态。</span><br><span class="line">sentinel down-after-milliseconds MyMaster 1500</span><br><span class="line"></span><br><span class="line"># 新master上任后数据同步时一次有多少数据同步，数值越小服务器压力越小但速度越慢</span><br><span class="line">sentinel parallel-syncs mymaster 1  </span><br><span class="line"></span><br><span class="line"># 若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败。</span><br><span class="line">sentinel failover-timeout TestMaster 10000</span><br><span class="line"></span><br><span class="line"># 设置master和slaves验证密码</span><br><span class="line">sentinel auth-pass TestMaster testmaster123</span><br><span class="line"></span><br><span class="line">sentinel config-epoch TestMaster 15</span><br><span class="line">#除了当前哨兵, 还有哪些在监控这个master的哨兵</span><br><span class="line">sentinel known-sentinel TestMaster 127.0.0.1 8002 0aca3a57038e2907c8a07be2b3c0d15171e44da5</span><br><span class="line">sentinel known-sentinel TestMaster 127.0.0.1 8003 ac1ef015411583d4b9f3d81cee830060b2f29862</span><br></pre></td></tr></table></figure></li><li><p>实例搭建<br><img src="https://img-blog.csdnimg.cn/20210228104955759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021022810503182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>显示 6379作为master，它下面还有2个slave，同时有3个哨兵监视着。<br><img src="https://img-blog.csdnimg.cn/20210228105419153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="三、哨兵工作原理"><a href="#三、哨兵工作原理" class="headerlink" title="三、哨兵工作原理"></a>三、哨兵工作原理</h1></li></ul><p><strong>1. 阶段（1）监控阶段：</strong><br><img src="https://img-blog.csdnimg.cn/20210228110044960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>sentinel 会向master要状态信息、向slave要状态信息、向其它sentinel要状态信息。</p><p><strong>2. 阶段（2）通知阶段：</strong><br><img src="https://img-blog.csdnimg.cn/20210228110357768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>sentinel1 会不断向master、slave发送指令来判断连接是否正常，并且将接受到的信息分享给其余sentinel。</p><p><strong>3. 阶段（3）故障转移阶段：</strong><br><img src="https://img-blog.csdnimg.cn/20210228111333816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li><p>sentinel1 会不断发送请求给master，如果在指定时间内接收不到响应则认为master已经下线，并且将master标记为 <code>flags:SRI_S_DOWN</code> (主观下线)。随后sentinel1 会将这一消息分享给其余sentinel，其余sentinel也会不断发送消息给master进行连接测试，如果有半数以上的sentinel都认为master已经下线，则master的状态会被标记为 <code>flags:SRI_O_DOWN</code> (客观下线)。</p></li><li><p>找到需要剔除的master 主机后，接下来需要从众多 sentinel 中选举出一个代表 sentinel 去实行剔除工作。<br><img src="https://img-blog.csdnimg.cn/20210228112317256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>最后就是执行剔除工作并且选举出新的master。会根据以下要求进行选举。<br><img src="https://img-blog.csdnimg.cn/20210228112500429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol><p><strong>哨兵工作原理：</strong><br><img src="https://img-blog.csdnimg.cn/20210228112713539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210228113848674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis(5).主从复制</title>
      <link href="/2020/10/11/Redis%EF%BC%9A%E4%BA%94%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2020/10/11/Redis%EF%BC%9A%E4%BA%94%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、主从复制的概念"><a href="#一、主从复制的概念" class="headerlink" title="一、主从复制的概念"></a>一、主从复制的概念</h1><p>为什么需要主从复制，因为单机Redis会存在以下问题： ①机器故障，那么原本机器中的业务数据会损害造成不可挽回的损失；②容量瓶颈，单继Redis的内存有限，硬件条件拉跨无法存储巨额数据；为了避免这些问题保证数据的安全性和服务器的高可用性出现了主从复制。<br>主从复制是指，主机数据更新后根据配置和策略，自动同步到备机的master&#x2F;slaver 机制，Master以写为主，Slave 以读为主。</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/20210226201122660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="二、主从复制基础用法"><a href="#二、主从复制基础用法" class="headerlink" title="二、主从复制基础用法"></a>二、主从复制基础用法</h1><p><strong>简介：</strong><br><img src="https://img-blog.csdnimg.cn/20210226203013450.png" alt="在这里插入图片描述"></p><h3 id="2-1-工作流程（1）建立连接"><a href="#2-1-工作流程（1）建立连接" class="headerlink" title="2.1  工作流程（1）建立连接"></a>2.1  工作流程（1）建立连接</h3><p><img src="https://img-blog.csdnimg.cn/20210226203639557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>首先由 slave(从服务器)向 master(主服务器) 发送 <code>slaveof ip port</code> 指令申明称为 master的从机。紧接着slave 会保存master的地址(<code>masterhost</code>)和端口(<code>masterport</code>)以保存master的信息，然后根据保存的信息建立起与主机间的<code>socket</code>连接。为了保证连接的不中断同时slave会不断发送<code>ping</code>命令来测试连接是否联通。如果主机设置了密码，此时还需要从机进行身份验证<code>auth password</code>来向主机核验自己的身份，如果验证授权通过从机才可以发送指令<code>replconf listening-port &lt;port-number&gt;</code>来向master发送自己的端口信息。最终主从连接成功。</li><li>最终的状态是master保存了slave的端口信息；slave保存了master的地址和端口；总体二者之间建立了socket连接。</li></ul><p><strong>建立连接的方法：</strong></p><ul><li><p>启动方式1、客户端发送命令：<br><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code><br><img src="https://img-blog.csdnimg.cn/20210226205113739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210226205156210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210226205229470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>启动方式2、启动服务器参数：<br><code>redis-server  xxxxx.conf --slaveof host port</code><br><img src="https://img-blog.csdnimg.cn/2021022620545830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>启动方式3、服务器配置：<br><code>slaveof  &lt;masterip&gt;  &lt;masterport&gt;</code><br><img src="https://img-blog.csdnimg.cn/20210226205925136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>授权访问需要从机提供主机设置好的密码：<br><img src="https://img-blog.csdnimg.cn/20210226210545482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h3 id="2-2-工作流程（2）数据同步"><a href="#2-2-工作流程（2）数据同步" class="headerlink" title="2.2  工作流程（2）数据同步"></a>2.2  工作流程（2）数据同步</h3><p><img src="https://img-blog.csdnimg.cn/20210227155930331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>Redis数据同步可以分为全量复制和增量复制(部分复制)。<br><strong>全量复制：</strong> 由slave发起 psyhc2指令给master，master会执行    <code>bgsave</code> (rdb方式的手动持久化)来生成当前的rdb数据文件。但是在rdb持久化过程中新增的数据也需要记录，因此在第一个slave连接的时候master就创建了一个复制缓冲区来记录这一过程新增的指令。等到master持久化完成就会通过socket将rdb数据文件发送给slave，slave接收到RDB然后清空数据执行RDB文件恢复数据。</p><p><strong>增量复制：</strong> 恢复完成后slave发送命令告知master已经恢复完成，master在这一阶段会发送复制缓冲区中的指令给slave，slave接收到这些指令执行 <code>bgrewriteaof</code>    来恢复数据(这是以aof的方式，因为复制缓冲区中存储的是指令而不是rdb文件类型的数据)。</p><p><strong>需要注意的问题：</strong> </p><ul><li>master方面：</li></ul><ol><li>如果master数据量巨大，数据同步阶段应当避开流量高峰阶段，避免造成master阻塞，影响业务的正常进行；</li><li>复制缓冲区的大小必须设置合理，否则会导致数据溢出。比如全量复制时间太久，进行部分复制时发现数据已经存在丢失的情况，必须进行二次全量复制，可能导致slave陷入死循环。<br>可以通过修改 <code>repl-backlog-size</code> 来修改复制缓冲区大小，默认是1MB</li><li>master单机内存占用主内存的比例不应太大，建议使用 50%~70%的内存，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区。</li></ol><ul><li>slave方面：</li></ul><ol><li>为避免slave进行全量复制、部分复制时服务器响应阻塞或者数据不同步，建议关闭对外服务。<br><code>slave-serve-stale-data yes|no</code> </li><li>数据同步阶段，master会向slave发送ping命令来测试连接。</li><li>多个salve向master请求数据同步，master发送的RDB文件过多，会对带宽造成巨大冲击，造成master的带宽不足。因此数据同步需要错峰进行。</li><li>slave过多时建议调整拓扑结构，由一主多从调整为树状结构，中间的结点既是master，也是上一层的slave。但是需要注意树状结构的深度，如果深度过深，深度高的master和底层的slave之间数据同步延迟较大，数据一致性不高。</li></ol><p><strong>总结：</strong> 全量复制获取的是获取从发指令那一刻开始之前的所有数据；增量复制是获取rdb过程中的所有数据；<br>最终的状态为：slave持有master的全部数据，包含RDB过程中接收的数据；master持有slave当前数据同步的位置。</p><h3 id="2-3-工作流程（3）命令传播"><a href="#2-3-工作流程（3）命令传播" class="headerlink" title="2.3  工作流程（3）命令传播"></a>2.3  工作流程（3）命令传播</h3><p>命令传播阶段就是对全量复制和增量复制的不断重复进行保证数据的实时一致性。<br><img src="https://img-blog.csdnimg.cn/20210227155251564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>服务器的运行 id</strong><br><img src="https://img-blog.csdnimg.cn/20210227160418102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>复制缓冲区</strong><br><img src="https://img-blog.csdnimg.cn/20210227161323492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210227161545189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>工作原理： 当一条命令进来后master会将该命令拆解为单个字节值，复制缓冲区包括偏移量和字节值两部分，被拆解的字节值会分别存储到复制缓冲区中同时标记上偏移量。由于不同的slave之间存在数据传播的差异，因此master和slave都需要记录这个偏移量。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210227163938541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p><strong>复制偏移量</strong><br><img src="https://img-blog.csdnimg.cn/20210227161220452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><strong>数据同步与命令传播阶段工作流程：</strong><br><img src="https://img-blog.csdnimg.cn/20210227165159404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>全量复制详解：<br>首先slave发送 <code>psync2 &lt;runid&gt; &lt;offset&gt;</code> 指令给master(此时slave还不知道master的服务器运行id，因此runid初始为?,offset初始为-1)，接着master进行rdb持久化并协同 <code>+FULLRESYNC runid offset</code> 一起发送给slave。在这期间master可能会接受客户端命令，offset进行移动变化。slave接收到了 <code>+FULLRESYNC</code> 会保存master的runid和offset参数，同时清空全部数据恢复RDB 数据。</li><li>增量复制详解：<br>当slave再次发送 <code>psync2 runid offset</code> 指令给master时，master会核对 runid和offset参数是否匹配。如果runid不满足或者offset溢出就执行全量复制；如果runid满足但是offset不相同(比方说slave突然掉线，而master端仍有命令进入，会造成master端的offset不断增长而slave端不变)，master则会发送 <code>+CONTINUE offset</code> 和复制缓冲区中相差的那段指令数据给slave。 slave接收到 <code>+CONTINUE</code> 指令后保存新的 offset 然后执行 <code>bgrewriteaof</code> 恢复数据。</li></ul></li><li><p><strong>心跳机制：</strong><br>心跳机制是为了保证master和slave之间的连接能够不中断，方便数据稳定传输的。(注意它并没有包含在数据同步阶段中，而是在命令传播阶段)<img src="https://img-blog.csdnimg.cn/20210227174229763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210227174948351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><p>slave 会发送 <code>replconf ack offset</code> 命令给master 来检测offset是否合理，接下来的操作和数据同步阶段相同。<br>为了保证命令传播阶段数据的高一致性，slave会不断发送 <code>replconf ack offset</code> 命令给master，同时master也会不断发送    <code>ping</code> 命令给slave来保证连接。</p><h1 id="三、主从复制实例"><a href="#三、主从复制实例" class="headerlink" title="三、主从复制实例"></a>三、主从复制实例</h1><p><strong>实例：</strong></p><p>   复制三份配置文件，分别占用6379、6380、6381三个端口。<br>   命令：<br>   <code>info  replication  ：查询当前机器的身份状态</code><br>   <code>slaveof  主机ip   主机端口port   ：成为某台机器的从机</code></p><ul><li><p>一主二仆：<br>·info replication：查看当前机器的角色·<br><img src="https://img-blog.csdnimg.cn/20201116144820162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>* 如果主机宕机后，从机的身份不会改变，依旧原地待命。<br>* 如果主机回来后，主机依旧为主机，从机依旧为从机。<br>* 如果从机宕机后回来，从机的身份就变为了master，每次与master断开后，都需要重新连接，除非配置进redis.conf 文件<br>* 只有主机可以进行写，从机只能进行读<br><img src="https://img-blog.csdnimg.cn/20201116145112564.png#pic_center" alt="在这里插入图片描述"></p><br></li><li><p>薪火相传(slave与master是相对的概念)<img src="https://img-blog.csdnimg.cn/20201116150650607.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>反客为主<br> <code>slaveof  no  one ：使当前数据库停止与其它数据库的同步，转换为主数据库</code></p></li><li><p>复制原理：<br><img src="https://img-blog.csdnimg.cn/20201116151252927.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>哨兵模式：<br>能够后台监控主机是否故障，如果故障了根据投票数自动将从库转化为主库。简单地说反客为主的自动版。</p><ol><li>如何配置：首先创建一个<code>sentinel.conf</code> 文件，在该文件里面进行主机宕机后的配置<code>sentinel monitor  被监控的主机数据库名字(自己起)  127.0.0.1  6379 1 </code> 。最后的一个1表示主机宕机后从机谁的票数多谁就成为主机。</li><li>哨兵启动： <code>redis-sentinel   xxx.sentinel.conf</code></li><li>此时如果主机宕机回来后，就自动变为了从机。</li><li>一组sentinel能够同时监控多个Master<br></li></ol></li></ul><h1 id="四、主从复制常见问题"><a href="#四、主从复制常见问题" class="headerlink" title="四、主从复制常见问题"></a>四、主从复制常见问题</h1><ol><li>频繁的全量复制（1）<br><img src="https://img-blog.csdnimg.cn/20210227180648608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>频繁的全量复制（2）<br><img src="https://img-blog.csdnimg.cn/2021022718093055.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>频繁的网络中断（1）<br><img src="https://img-blog.csdnimg.cn/20210227191903167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>频繁的网络中断（2）<br><img src="https://img-blog.csdnimg.cn/2021022719194084.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>数据不一致<br><img src="https://img-blog.csdnimg.cn/20210227192118650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h1 id="五、主从复制的作用"><a href="#五、主从复制的作用" class="headerlink" title="五、主从复制的作用"></a>五、主从复制的作用</h1><ul><li><strong>读写分离</strong>： master写，slave读，提高服务器的读写负载能力；</li><li><strong>负载均衡</strong>： 基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与吞吐量；</li><li><strong>故障恢复</strong>：当master出现问题时，由slave来提供服务实现快速的故障恢复；</li><li><strong>数据冗余</strong>：实现数据热备份，是持久化之外的一种数据冗余方式；</li><li><strong>高可用基石</strong>：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis(4).事务</title>
      <link href="/2020/10/10/Redis%EF%BC%9A%E5%9B%9B%E3%80%81%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/10/10/Redis%EF%BC%9A%E5%9B%9B%E3%80%81%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Redis事务是什么？"><a href="#一、Redis事务是什么？" class="headerlink" title="一、Redis事务是什么？"></a>一、Redis事务是什么？</h1><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul><li>可以一次执行多个命令，本质是一组命令的集合。一个事务中所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不允许阻塞。<br></li></ul><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><p><img src="https://img-blog.csdnimg.cn/20201114214050991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><span id="more"></span><ol><li>事务相关命令：<br>(1) <code>DISCARD</code>   取消事务，放弃执行事务块内地所有命令；<br>(2) <code>EXEC</code>  执行所有事务块内的命令；<br>(3) <code>MULTI</code>  标记一个事务块的开始；<br>(4) <code>UNWATCH</code> 取消WATC命令对所有key的监视；<br>(5) <code>WATCH key [key ....]</code>  监视一个或者多个key，如果在事务执行之前这个key被其它命令所改动，那么事务会被打断；</li><li>事务的正常执行：<br><img src="https://img-blog.csdnimg.cn/2020111421491542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>放弃事务：<br><img src="https://img-blog.csdnimg.cn/2020111611554914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>全体连坐：类似于Java中的异常处理，书写代码时就会报错，但是它不会处理 1&#x2F;0&#x3D;xx 这种错误，这种错误需要在编译时才能被发现。<br><img src="https://img-blog.csdnimg.cn/20201116115815119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>冤头债主：说明了Redis对事务是部分支持<br><img src="https://img-blog.csdnimg.cn/20201116115946323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>watch监控</li></ol><ul><li><p>表锁：将整张表锁住，其它行的任何操作都不行；</p></li><li><p>行锁：仅仅锁住这一行。</p></li><li><p>悲观锁：类似于表锁。数据的正确性是最高的。<br><img src="https://img-blog.csdnimg.cn/20201116120909458.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>乐观锁：类似于行锁。每条记录包括一个Version版本信息，每次有用户修改后Version加1。此时如果有A和B两个用户共同修改一条记录，但是A先提交后将Version+1；然后B再去提交时会报错，因为此时数据库中该条记录的Version已经为2了，就需要B重新从数据库中获取该条记录然后再次修改后提交。这样保证了数据的统一性。<br><img src="https://img-blog.csdnimg.cn/20201116120827437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201116120947566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>watch的应用：<br><img src="https://img-blog.csdnimg.cn/20201116121300936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>watch：watch命令是一个乐观锁，它可以在EXEC命令执行前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话服务器会拒绝执行事务。</p></li><li><p>unwatch命令：放弃对所有key的监控。</p></li><li><p>一旦执行了exec，之前加的所有的监控锁都会被取消掉了。</p></li><li><p>Watch 命令可以被调用多次，一个Watch 命令可以监控多个key。Watch 命令调用即启动监控功能，从Watch 命令开始点到执行EXEC命令终止。一旦EXEC被调用，所有的键都将不被监视，无论所讨论的事务是否被中止。关闭客户端连接也会触发所有的键被取消监视。</p></li><li><p>Redis Watch 命令给事务提供check-and-set (CAS) 机制。被Watch的Key被持续监控，如果key在Exec命令执行前有改变，那么整个事务被取消，Exec返回null表示事务没有成功。<br>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num = GET sampleKey</span><br><span class="line">num = num + 1</span><br><span class="line">SET sampleKey $num</span><br></pre></td></tr></table></figure><p>上面的命令在单用户环境下没有问题。如果多个用户都尝试同时增加值就会出现竞争条件，此时结果为14而不是15.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH sampleKey</span><br><span class="line">num = GET sampleKey</span><br><span class="line">num = num + 1</span><br><span class="line">MULTI</span><br><span class="line">SET sampleKey $num</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><p>使用了WATCH 关键字能够有效保障竞争条件，一个用户修改后另外一个用户就不能操作了。</p></li></ul><br><p><strong>事务总结：</strong><br><img src="https://img-blog.csdnimg.cn/20201116134245521.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201116134329765.png#pic_center" alt="在这里插入图片描述"><br><br></p><h1 id="二、Redis消息发布订阅？"><a href="#二、Redis消息发布订阅？" class="headerlink" title="二、Redis消息发布订阅？"></a>二、Redis消息发布订阅？</h1><p>进程间的一种通信模式，发送者(pub) 发送消息，订阅者(sub) 接收消息。一般使用 rabbitmq来作为消息发布订阅。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//可以一次订阅多个</span><br><span class="line">SUBSCRIBE c1 c2 c3;</span><br><span class="line"></span><br><span class="line">//消息发布</span><br><span class="line">PUBLISH c2  hello-redis</span><br><span class="line"></span><br><span class="line">//订阅多个</span><br><span class="line">PSUBSCRIBE new*</span><br></pre></td></tr></table></figure><br><p>参考：<br>violate特性详解：   <a href="https://www.cnblogs.com/monkeysayhi/p/7654460.html">https://www.cnblogs.com/monkeysayhi/p/7654460.html</a><br>                                <a href="https://blog.csdn.net/jiyiqinlovexx/article/details/50989328">https://blog.csdn.net/jiyiqinlovexx/article/details/50989328</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis(3).持久化操作</title>
      <link href="/2020/10/10/Redis%EF%BC%9A%E4%B8%89%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/10/10/Redis%EF%BC%9A%E4%B8%89%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Redis配置文件解析"><a href="#一、Redis配置文件解析" class="headerlink" title="一、Redis配置文件解析"></a>一、Redis配置文件解析</h1><p><img src="https://img-blog.csdnimg.cn/20201113213952611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><span id="more"></span><h3 id="INCLUDES-包含"><a href="#INCLUDES-包含" class="headerlink" title="INCLUDES 包含"></a>INCLUDES 包含</h3><ul><li>作用：类似于Struct2 配置文件，可以通过 INCLUDES来包含其它配置文件，redis.conf 可以作为总闸。<br><img src="https://img-blog.csdnimg.cn/20201113214257494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br></li></ul><h3 id="GENERAL-通用"><a href="#GENERAL-通用" class="headerlink" title="GENERAL 通用"></a>GENERAL 通用</h3><p><img src="https://img-blog.csdnimg.cn/20201113214519893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>Daemonize：是否作为守护线程运行，如果开启则开机自启</li><li>Pidfile： 进程管道pid文件</li><li>Port：redis运行的端口</li><li>Tcp-backlog：backlog其实是一个连接队列，用来避免慢客户端连接问题。<br><img src="https://img-blog.csdnimg.cn/20201114162005950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>Timeout：在多长的空闲时间后会关闭连接，默认值为0，表示不关闭</li><li>Bind： 绑定的ip地址</li><li>Tcp-Keepalive：用于定时检测连接是否正常，单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置为60</li><li>Loglevel：日志级别，redis默认有4种日志级别  debug、verbose、notice、warning，日志级别由低到高主键上升。<br><img src="https://img-blog.csdnimg.cn/20201114162719671.png#pic_center" alt="在这里插入图片描述"></li><li>logfile：日志保存的路径；默认为标准输出，如果Redis设置为守护进程方式运行，而这里又配置为标准输出，则日志会发送给 &#x2F;dev&#x2F;null</li><li>sys-log-enabled： 是否允许记录系统日志</li><li>databases：redis含有的数据库，使用select xxx 来切换数据库</li></ul><h3 id="SECURITY"><a href="#SECURITY" class="headerlink" title="SECURITY"></a>SECURITY</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">命令行语句：</span><br><span class="line">config get dir   //获取当前的工作目录</span><br><span class="line">conifg  get requirepass   //获取登录密码</span><br><span class="line">config  set  requirepass    //设置登录密码</span><br><span class="line">auth   密码           //使用密码登录 </span><br><span class="line"></span><br><span class="line">配置文件中：</span><br><span class="line">requirepass  xxxxx    //设置登录密码</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201114173100555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="LIMITS-限制"><a href="#LIMITS-限制" class="headerlink" title="LIMITS 限制"></a>LIMITS 限制</h3><ul><li>Maxclients：同一时间最大的用户连接数量，默认1</li><li>Maxmemory：最大的缓存空间</li><li>Maxmemory-samples ：设置样本数量，LRU算法和最小TTL算法都不是精确的算法，而是估算值。redis默认会检查这么多个key并选择其中LRU的那个。</li><li>Maxmemory-policy：清除缓存策略(当数据库存储的数据过多时)<br><img src="https://img-blog.csdnimg.cn/20201114173610463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul><p>Volatile-lru ：最近最少算法移除key，只对设置了过期时间的键<br>Allkeys-lru ：最近最少使用算法移除key<br>Volatile-lfu ：使用频率最少算法移除key，只对设置了过期时间的键<br>Allkeys-lfu ：使用频率最少使用算法移除key<br>Volatile-random ：在过期集合中随机移除key，只对设置了过期时间的<br>Allkeys-random ：随机移除的key<br>Volatile-ttl ：移除最近将要过期的(TTL最小的)<br>Noeviction：永不移除（实际不会使用）</p><br><p><strong><font color=red>常用配置redis.conf 说明：</font></strong><br><img src="https://img-blog.csdnimg.cn/20201114173901915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114174725834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114174802512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114174938967.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114175026168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114175045448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><br></p><h2 id="二、Redis持久化—-RDB方式"><a href="#二、Redis持久化—-RDB方式" class="headerlink" title="二、Redis持久化— RDB方式"></a>二、Redis持久化— RDB方式</h2><h3 id="2-1-RDB-Redis-DataBase"><a href="#2-1-RDB-Redis-DataBase" class="headerlink" title="2.1 RDB(Redis DataBase):"></a>2.1 RDB(Redis DataBase):</h3><ul><li><p>概念：<code>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是Snapshot快照，他恢复时是将快照文件直接读入到内存里。</code></p></li><li><p>执行特点：Redis会单独创建(fork) 一个子进程来进行持久化，会先将数据写入到一个临时文件中(dump.rdb)，等到持久化操作结束后再用这个临时文件去替换上次持久化好的文件。整个过程中主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要进行大规模的数据恢复，且对于数据的完整性要求不高，那么RDB方式要比AOF方式更加的高效，缺点是最后一次持久化后的数据可能会丢失。</p></li><li><p>Fork：作用是复制一个与当前进程一样的进程。新进程的所有数据等和原进程一样，但是是一个全新的进程，并作为原进程的子进程。</p></li><li><p>dump.rdb的恢复策略：</p></li></ul><ol><li>在操作满足对应持久化触发条件或者关闭Redis服务时，都会将内存数据写入磁盘(dump.rdb文件)，最后替换上一次的持久化好的文件。<font color=red> 注意当关闭redis时会最后进行一次RDB持久化操作</font></li><li>最好的策略是主机和备份机分为2台机器，这样可以保障数据的安全，采用冷拷贝后重新使用的方式[<code>cp dump.rdb dump_new rdb</code>]</li><li>save和bgsave都是主动对数据进行备份。 Save时只管保存，其它不管，全部阻塞；BGSAVE时Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间。</li><li>Redis适合于大规模数据的恢复，对于数据一致性要求不高；</li><li>Fork的时候，内存中数据被克隆了一份，大致2被的膨胀性需要考虑；</li></ol><p><img src="https://img-blog.csdnimg.cn/20201114195020841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><br><h3 id="2-2-配置文件解读-SNAPSHOTTING-快照："><a href="#2-2-配置文件解读-SNAPSHOTTING-快照：" class="headerlink" title="2.2 配置文件解读 (SNAPSHOTTING) 快照："></a>2.2 配置文件解读 (SNAPSHOTTING) 快照：</h3><ul><li><p>dir：指定本地数据库的存放目录</p></li><li><p>save <seconds>  <changes>   &#x2F;&#x2F;触发持久化的条件<br><img src="https://img-blog.csdnimg.cn/20201114181529428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210208180036422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>Stop-writes-on-bgsave-error：出现异常后立刻停止存储数据。如果配置成no，表示你不在乎数据不一致或者有其它的手段发现和控制。</p></li><li><p>rdbcompression xxx ：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭次功能。</p></li><li><p>rdbchecksum：在存储快照后，还可以让redis使用CRC64算法来进行数据校验。    </p></li><li><p>dbfilename： RDB持久化后生成的持久化文件名</p></li><li><p>rdb文件异常恢复操作：  <code>Redis-check-rdb --fix   rdb文件名</code></p></li><li><p>dir：指定本地数据库存放的目录</p></li></ul><br><h3 id="2-3-save指令、bgsave指令、save配置："><a href="#2-3-save指令、bgsave指令、save配置：" class="headerlink" title="2.3 save指令、bgsave指令、save配置："></a>2.3 save指令、bgsave指令、save配置：</h3><ul><li><p>save指令工作原理：<br><img src="https://img-blog.csdnimg.cn/20210208180442258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当同时有多个客户端向服务器发送请求时，由于Redis是单线程的，因此不同指令到达Redis内部是有一个执行顺序的，假设如下。<br><img src="https://img-blog.csdnimg.cn/20210208180623475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>save指令的执行会阻塞当前的Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用。</p><br></li><li><p>bgsave指令工作原理：<br><img src="https://img-blog.csdnimg.cn/20210208222957681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于客户端发送的请求，服务器端不直接进行处理，而是通过Linux的fork函数来生成一个子进程来创建rdb文件同时返回消息。<br>bgsave命令是针对save阻塞问题做的优化。Redis内部所涉及到的RDB操作都采用bgsave方式，save命令可以放弃使用。</p><br></li><li><p>save配置：<br><img src="https://img-blog.csdnimg.cn/20210208225244375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>save配置后台其实走的还是 bgsave指令的方式。</p></li><li><p>三种方式对比比较：<br><img src="https://img-blog.csdnimg.cn/20210208225431821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h3 id="2-4-RDB总结："><a href="#2-4-RDB总结：" class="headerlink" title="2.4 RDB总结："></a>2.4 RDB总结：</h3><p><img src="https://img-blog.csdnimg.cn/20210208225625918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201114200718359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h5 id="（1）RDB优点："><a href="#（1）RDB优点：" class="headerlink" title="（1）RDB优点："></a>（1）RDB优点：</h5><ul><li>RDB是一个紧凑压缩的二进制文件，存储效率较高；</li><li>RDB内部存储的是redis在某个时间点的数据快照(全部数据)，非常适合用于数据备份，全量复制等场景；</li><li>RDB恢复数据的速度比AOF快很多；</li><li>应用：服务器中每X小时执行bgsave备份，并将RDB 文件拷贝到远程机器中，用于灾难恢复；<h5 id="（2）RDB缺点："><a href="#（2）RDB缺点：" class="headerlink" title="（2）RDB缺点："></a>（2）RDB缺点：</h5></li><li>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大可能性丢失数据；</li><li>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能；</li><li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象；</li></ul><br><br><h2 id="三、Redis持久化—-AOF方式"><a href="#三、Redis持久化—-AOF方式" class="headerlink" title="三、Redis持久化— AOF方式"></a>三、Redis持久化— AOF方式</h2><p>鉴于RDB方式的弊端如下：</p><ul><li>存储数据量较大，效率较低：基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低；</li><li>大数据量下IO性能较低；</li><li>基于fork创建子进程，内存产生额外消耗；</li><li>宕机带来的数据丢失风险；</li></ul><br><p>解决思路：</p><ul><li>不写全部数据，仅记录部分数据；</li><li>改记录数据为记录操作过程；</li><li>对所有操作均进行记录，排除丢失数据的风险；<h3 id="3-1-AOF-Append-Only-File"><a href="#3-1-AOF-Append-Only-File" class="headerlink" title="3.1 AOF(Append Only File):"></a>3.1 AOF(Append Only File):</h3></li><li>概念：<code>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件内容将所有写指令从前到后执行一次来完成数据的恢复操作。</code></li><li>执行特点：</li></ul><ol><li>当AOF和RDB两种持久化方式都存在时优先执行AOF持久化方式，恢复数据也是一样的。</li><li>AOF会记录所有的写操作，这也包括FLUSHDB、FLUSHALL等操作。</li><li><code>redis-check-aof  --fix  xxxx.aof</code> 命令会对xxxx.aof文件进行修复操作。</li><li>AOF和RDB两种持久化操作可以同时执行，没有问题。</li></ol><ul><li>Fork：作用是复制一个与当前进程一样的进程。新进程的所有数据等和原进程一样，但是是一个全新的进程，并作为原进程的子进程。</li><li>AOF 写数据的三种策略：<br><img src="https://img-blog.csdnimg.cn/20210215093041871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="3-2-配置文件解读-APPEND-ONLY-MODE-："><a href="#3-2-配置文件解读-APPEND-ONLY-MODE-：" class="headerlink" title="3.2 配置文件解读 (APPEND ONLY MODE) ："></a>3.2 配置文件解读 (APPEND ONLY MODE) ：</h3><p><img src="https://img-blog.csdnimg.cn/2021021509371354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201114203537260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>appendonly ： 是否开启AOF持久化</li><li>appendfilename ： 持久化后的文件名</li><li>Appendsync ：持久化的频率，包括 Always：同步持久化，每次发生数据变更会立刻被记录到磁盘上，性能较差但是数据完整性较好；Everysec：出厂默认推荐，异步操作，每秒记录，如果一秒宕机有数据丢失。no：不同步，性能最好，但是持久化没有保证。<br><img src="https://img-blog.csdnimg.cn/20201114203934523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>AOF异常恢复命令：     <code>Redis-check-aof  --fix  aof文件名</code>    </li><li>Rewrite：命令：<code>redis-cli -h ip  -p port  bgrewriteaof</code>      AOF采用文件追加方式，文件会越来越大为了避免此种情况，新增了重写机制，在当前的快照保存工作结束后，fork一个子进程，将AOF文件进行重写，合并set命令等操作到一个临时文件，达到缩小文件大小的目的。重写结束后后将临时文件替换为新的AOF文件（重写过程中如果有新的redis操作命令，会提交到缓存中，重写结束后追加到AOF文件内）。</li><li>Rewrite触发机制：Redis会记录上一次重写的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。<br><img src="https://img-blog.csdnimg.cn/20201114212703795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li><code>auto-aof-rewrite-pericentage  xxx</code>：当目前的AOF文件大小超过上一次重写文件大小的百分之几时进行重写，如果没有重启过，则以启动时的AOF文件大小为依据</li><li><code>auto-aof-rewrite-min-size</code> ：允许重写的最小AOF文件大小</li><li><code>No-appendsync-on-rewrite</code> ：重写时是否可以运用 Appendsync，用默认no即可。保证数据的完整性。</li></ul><h3 id="3-3-AOF重写："><a href="#3-3-AOF重写：" class="headerlink" title="3.3 AOF重写："></a>3.3 AOF重写：</h3><ul><li><p>AOF重写的作用及介绍：<br><img src="https://img-blog.csdnimg.cn/20210215093939991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>AOF重写的规则：<br><img src="https://img-blog.csdnimg.cn/20210215094045900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>AOF的重写方式：<br>手动重写  ————————   <code>bgrewriteaof</code><br>自动重写  ————————   <code>auto-aof-rewrite-min-size   size</code><br>                                          <code>auto-aof-rewrite-percentage  percentage</code>   </p></li><li><p>AOF手动重写原理：</p><blockquote><p>当输入bgrewriteaof指令时会直接触发AOF重写<br><img src="https://img-blog.csdnimg.cn/20210215094826601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote></li><li><p>AOF自动重写原理：</p><blockquote><p>自动重写需要满足两个触发条件之一<br><img src="https://img-blog.csdnimg.cn/20210215095131758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote></li><li><p>AOF重写流程：<br><img src="https://img-blog.csdnimg.cn/20210215095947260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210215100449865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><blockquote><ol><li>always是直接fork一个子进程进行aof文件的写入；</li><li>everysec 在 always的基础上使用了aof缓存区，使用fork出一个子进程将数据缓存到aof缓存区然后对于满足条件的数据写入到aof文件；</li><li>everysec开启重写操作后会同时将数据缓存到 aof缓存区和aof重写缓存区，如果此时执行了 bgrewriteaof则会从该重写缓存区中拿数据然后fork出子进程进行重写。</li><li>如果是通过配置激活aof重写，那么bgrewriteaof指令的执行是通过配置的方式触发而不是手动触发的。</li></ol></blockquote><h3 id="3-4-AOF总结："><a href="#3-4-AOF总结：" class="headerlink" title="3.4 AOF总结："></a>3.4 AOF总结：</h3><p><img src="https://img-blog.csdnimg.cn/20201114211834800.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114212747941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><br><br><h2 id="四、AOF与RDB性能建议："><a href="#四、AOF与RDB性能建议：" class="headerlink" title="四、AOF与RDB性能建议："></a>四、AOF与RDB性能建议：</h2><p><img src="https://img-blog.csdnimg.cn/20201114213009195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201114213234707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>参考：<a href="https://blog.csdn.net/weixin_42683679/article/details/81092985">https://blog.csdn.net/weixin_42683679/article/details/81092985</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis(2).jedis线程池</title>
      <link href="/2020/10/07/Redis%EF%BC%9A%E4%BA%8C%E3%80%81jedis%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2020/10/07/Redis%EF%BC%9A%E4%BA%8C%E3%80%81jedis%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是jedis"><a href="#一、什么是jedis" class="headerlink" title="一、什么是jedis"></a>一、什么是jedis</h1><ul><li>jedis是 Java语言 连接 redis服务的一个工具，常用的包括 Jedis、SpringData Redis、Lettuce</li><li>java-jedis 操作redis 和 redis自身的命令完全一致。</li></ul><span id="more"></span><h1 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h1><h2 id="1-Jedis-读写redis数据-案例"><a href="#1-Jedis-读写redis数据-案例" class="headerlink" title="1.Jedis 读写redis数据(案例)"></a>1.Jedis 读写redis数据(案例)</h2><p><img src="https://img-blog.csdnimg.cn/20210208153814493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210208153954922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-编码"><a href="#2-编码" class="headerlink" title="2. 编码"></a>2. 编码</h2><h5 id="2-1-设定业务方法："><a href="#2-1-设定业务方法：" class="headerlink" title="2.1 设定业务方法："></a>2.1 设定业务方法：</h5><p><img src="https://img-blog.csdnimg.cn/20210208165606684.png" alt="在这里插入图片描述"></p><h5 id="2-2-设定线程类，模拟用户调用："><a href="#2-2-设定线程类，模拟用户调用：" class="headerlink" title="2.2 设定线程类，模拟用户调用："></a>2.2 设定线程类，模拟用户调用：</h5><p><img src="https://img-blog.csdnimg.cn/20210208165635446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="2-3-设计redis控制方案："><a href="#2-3-设计redis控制方案：" class="headerlink" title="2.3 设计redis控制方案："></a>2.3 设计redis控制方案：</h5><p><img src="https://img-blog.csdnimg.cn/20210208165655454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="2-4-设计启动主程序"><a href="#2-4-设计启动主程序" class="headerlink" title="2.4 设计启动主程序:"></a>2.4 设计启动主程序:</h5><p><img src="https://img-blog.csdnimg.cn/20210208165724783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-Jedis-工具类配置"><a href="#3-Jedis-工具类配置" class="headerlink" title="3. Jedis 工具类配置"></a>3. Jedis 工具类配置</h2><p>如果每次使用redis 都通过创建一个连接然后关闭的方式来进行会导致效率非常低。因此往往采用 jedis连接池的方式进行操作。</p><h5 id="3-1-配置文件"><a href="#3-1-配置文件" class="headerlink" title="3.1 配置文件"></a>3.1 配置文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 最大可用连接数</span><br><span class="line">redis.maxTotal=<span class="number">1000</span></span><br><span class="line"># 最大空闲连接数</span><br><span class="line">redis.maxIdle=<span class="number">100</span></span><br><span class="line"># 最小空闲连接数</span><br><span class="line">redis.minIdle=<span class="number">50</span></span><br><span class="line"># 当池内没有返回对象时，最大等待时间</span><br><span class="line">redis.maxWaitMillis=<span class="number">10000</span></span><br><span class="line"># 当调用borrow Object方法时，是否进行有效性检查</span><br><span class="line">redis.testOnBorrow=<span class="literal">true</span></span><br><span class="line"># 当调用<span class="keyword">return</span> Object方法时，是否进行有效性检查</span><br><span class="line">redis.testOnReturn=<span class="literal">true</span></span><br><span class="line"># 空闲连接检测线程，检测的周期，毫秒数。如果为负值，则表示不运行”检测线程“，默认为-<span class="number">1</span></span><br><span class="line">redis.timeBetweenEvictionRunsMills=<span class="number">30000</span></span><br><span class="line"># 向调用者输出”连接“对象时，是否检测它的空闲超时</span><br><span class="line">redis.testWhileIdle=<span class="literal">true</span></span><br><span class="line"># 对于”空闲连接“检测线程而言，每次检测的连接资源的个数，默认为<span class="number">3</span></span><br><span class="line">redis.numTestsPerEvictionRun=<span class="number">50</span></span><br><span class="line"># 服务器IP</span><br><span class="line">redis.ip=xxxx</span><br><span class="line"># 服务器端口</span><br><span class="line">redis.port=xxxx</span><br></pre></td></tr></table></figure><h5 id="3-2-代码编写"><a href="#3-2-代码编写" class="headerlink" title="3.2 代码编写"></a>3.2 代码编写</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisPool jp;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String host;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer port;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer maxTotal;     <span class="comment">//最大连接数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer maxIdle;      <span class="comment">//最大空闲连接数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="comment">//获取xxx.properties文件内容</span></span><br><span class="line">    <span class="type">ResourceBundle</span> <span class="variable">rb</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;redis&quot;</span>);</span><br><span class="line">    host = rb.getString(<span class="string">&quot;redis.host&quot;</span>);</span><br><span class="line">    port = Integer.parseInt(rb.getString(<span class="string">&quot;redis.port&quot;</span>));</span><br><span class="line">    maxTotal = Integer.parseInt(rb.getString(<span class="string">&quot;redis.maxTotal&quot;</span>));</span><br><span class="line">    maxIdle = Integer.parseInt(rb.getString(<span class="string">&quot;redis.maxIdle&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成jedis连接池配置</span></span><br><span class="line">    <span class="type">JedisPoolConfig</span> <span class="variable">jpc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">    jpc.setMaxTotal(maxTotal);</span><br><span class="line">    jpc.setMaxIdle(maxIdle);</span><br><span class="line">    jp = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jpc,host,port);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 获取 redis连接</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jp.getResource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>ResourceBundle</code> 类是用来专门获取  xxx.properties类型的配置文件内容的工具类。</p><p>ResourceBundle类是java自带的类，类路径：java.util.ResourceBundle，用来读取项目中后缀为properties的配置文件。</p><p>下面简单举例说明一下用法：</p><ol><li>数据准备</li></ol><p>1）配置文件名称：application.properties（可将文件存放在工程的resource目录下，或者lib目录下）</p><p>2）配置文件内容：</p><pre><code> dataBaseIp=127.0.0.1 user.name=root user.password=123456</code></pre><ol start="2"><li>ResourceBundle类实现读取application.properties中key对应的value的步骤：</li></ol><p>　　1）获取配置文件的名称，使用getBundle()方法</p><p>ResourceBundle resourceBundle &#x3D; ResourceBundle.getBundle(“application”);&#x2F;&#x2F;不需要写后缀名<br>2）获取资源文件中的信息：使用getString()方法<br>String dataBaseIp &#x3D; resourceBundle.getString(“dataBaseIp”);&#x2F;&#x2F;获取资源application中的dataBaseIp字段的值——127.0.0.1</p><p>String userName &#x3D; resourceBundle.getString(“user.name”);&#x2F;&#x2F;获取资源application中的user.name字段的值——root</p><ol start="3"><li>在工程中调用步骤2中读取到的值即可，不赘述。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis(1).基础必备知识</title>
      <link href="/2020/10/07/Redis%EF%BC%9A%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/10/07/Redis%EF%BC%9A%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是NoSQL"><a href="#一、什么是NoSQL" class="headerlink" title="一、什么是NoSQL?"></a>一、什么是NoSQL?</h1><p>时代演进，网页开发可以概述为以下过程：</p><h3 id="1、单机Mysql的引进："><a href="#1、单机Mysql的引进：" class="headerlink" title="1、单机Mysql的引进："></a>1、单机Mysql的引进：</h3><p>初始时都是三层访问方式：   (DAL数据库访问层)</p><p>这种情况下，整个网站的瓶颈存在：<br>(1)、数据量太大，一个机器放不下；<br>(2)、访问量太多—-读写混合，一个服务器受不了；<br>(3)、数据的索引—-B+ Tree，一个机器放不了；<br><img src="https://img-blog.csdnimg.cn/2020111310532315.png#pic_center" alt="在这里插入图片描述"></p><h3 id="2、Memcached-缓存-Mysql-垂直拆分"><a href="#2、Memcached-缓存-Mysql-垂直拆分" class="headerlink" title="2、Memcached(缓存)+Mysql+垂直拆分:"></a>2、Memcached(缓存)+Mysql+垂直拆分:</h3><p><img src="https://img-blog.csdnimg.cn/2020111312283523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>网站80%的时间都是在读数据，那么每次都去查询数据就很麻烦，因此使用缓存将每次读的数据存起来就可以减少服务器的压力！————-解决了大数据时代的读操作</p><span id="more"></span><h3 id="3、Mysql主从复制、读写分离："><a href="#3、Mysql主从复制、读写分离：" class="headerlink" title="3、Mysql主从复制、读写分离："></a>3、Mysql主从复制、读写分离：</h3><p><img src="https://img-blog.csdnimg.cn/20201113123021428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="4、分库分表、水平拆分、mysql集群："><a href="#4、分库分表、水平拆分、mysql集群：" class="headerlink" title="4、分库分表、水平拆分、mysql集群："></a>4、分库分表、水平拆分、mysql集群：</h3><p>在Memcached的高速缓存，MySQL的主从复制、读写分离的基础上，由于MySQL主库的写压力开始出现了瓶颈，而数据量的猛增但是MyISAM使用表锁，在高并发下就会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM，它采用的是行锁，增加了并发性。<br><img src="https://img-blog.csdnimg.cn/20201113123536618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>根据数据的使用频率或者其它条件来对数据进行数据库划分。比如电商中用户的不常修改的个人信息单独存放在一个数据库。每个数据库又划分为多张表，这样查询起来就更快了。</p><h3 id="为什么使用NoSQL"><a href="#为什么使用NoSQL" class="headerlink" title="为什么使用NoSQL?"></a>为什么使用NoSQL?</h3><p>NoSQL是指非关系型数据库。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。NoSQL数据库种类繁多，但是一个共同的特点就是去除掉了数据库的关系性。数据之间无关系，这样就非常容易扩展。也无形之间在架构的层面上带来了可扩展的能力。<br><img src="https://img-blog.csdnimg.cn/20201113123844437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="RDBMS-与-NoSQL对比"><a href="#RDBMS-与-NoSQL对比" class="headerlink" title="RDBMS 与 NoSQL对比"></a>RDBMS 与 NoSQL对比</h3><p>RDBMS:  </p><ul><li>高度组织化结构数据</li><li>结构化查询语言（SQL）</li><li>数据和关系都存储在单独的表中</li><li>数据操纵语言（DML），数据定义语言（DDL）</li><li>严格的一致性</li><li>基础事务</li></ul><p>NoSQL:</p><ul><li>不仅仅是SQL</li><li>没有声明性查询语言</li><li>没有预定义的模式</li><li>键值对存储，列存储，文档存储，图形数据库</li><li>最终一致性，非ACID属性</li><li>包括(Reids、MongDB文档类、Memcache)<br><img src="https://img-blog.csdnimg.cn/20201113125224940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul><h1 id="二、NoSQL数据模型简介"><a href="#二、NoSQL数据模型简介" class="headerlink" title="二、NoSQL数据模型简介?"></a>二、NoSQL数据模型简介?</h1><p>聚合模型：</p><ul><li>KV键值   【memcache + redis】</li><li>文档型数据库(bson格式比较多)  【MongoDB】</li><li>列存储数据库(分布式文件系统)</li><li>图形关系数据库(不是放图片的，放的是关系：比如朋友圈社交网络、广告推送系统)<br><img src="https://img-blog.csdnimg.cn/20201113132600604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><h1 id="三、NoSQL数据库CAP原理CAP-BASE"><a href="#三、NoSQL数据库CAP原理CAP-BASE" class="headerlink" title="三、NoSQL数据库CAP原理CAP+BASE?"></a>三、NoSQL数据库CAP原理CAP+BASE?</h1></li></ul><ul><li>传统关系型数据库的ACID属性：<br><img src="https://img-blog.csdnimg.cn/20201113133011243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul><br><ul><li>NoSQL的CAP：<br>C：Consistency【强一致性】<br>A：Availablity【可用性】<br>P：Partition tolerance【分区容错性】</li></ul><br><ul><li><p>CAP的三进二原则：<br><img src="https://img-blog.csdnimg.cn/20201113133451466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201113133528679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/202011131631311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><br></li><li><p>CAP原则组合的应用场景：<br><img src="https://img-blog.csdnimg.cn/20201113163501864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><br></li><li><p>BASE 原则理论:<br><img src="https://img-blog.csdnimg.cn/20201113163644775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>分布式与集群的关联和区别:<br><img src="https://img-blog.csdnimg.cn/20201113163902422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><br></li></ul><h1 id="四、-Redis入门"><a href="#四、-Redis入门" class="headerlink" title="四、    Redis入门"></a>四、    Redis入门</h1><p>下载安装好redis后将redis中的 <code>redis.conf</code>  配置文件拷贝一份到 <code>/usr/local/redis/etc</code>文件夹下,在修改重要配置文件前先进行拷贝!!!!!<br>同时在这里我将一些重要的可执行指令也移动到了 <code>/usr/local/redis/bin</code>  目录下,这些文件与Redis的启动 , 关闭 等息息相关.</p><h3 id="4-1-修改Redis-配置文件使得后台自启动"><a href="#4-1-修改Redis-配置文件使得后台自启动" class="headerlink" title="4.1 修改Redis 配置文件使得后台自启动"></a>4.1 修改Redis 配置文件使得后台自启动</h3><p>找到 <code>redis.conf</code> 配置文件中 <code>daemonize no</code> 这部分,它的意思是Redis默认不会作为守护进程在后台自启动,如果需要改为 true即可.<br><img src="https://img-blog.csdnimg.cn/202011131651335.png#pic_center" alt="在这里插入图片描述"></p><h3 id="4-2-Redis启动-关闭-重启"><a href="#4-2-Redis启动-关闭-重启" class="headerlink" title="4.2 Redis启动,关闭,重启"></a>4.2 Redis启动,关闭,重启</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server  自定义配置文件xxx//启动服务端</span><br><span class="line">redis-cli  -p 6379//启动客户端</span><br><span class="line">ping                                //测试连接</span><br><span class="line">shutdown                                             //关闭   </span><br><span class="line">ps -ef | grep redis                                //判断redis是否成功启动</span><br><span class="line">lsof -i : 6379                                        //判断redis是否成功启动</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201113165752369.png#pic_center" alt="在这里插入图片描述"><br>Redis是单进程开始执行的,它是通过 epoll函数的包装来做到的.<br><img src="https://img-blog.csdnimg.cn/2020111317062375.png#pic_center" alt="在这里插入图片描述"><br>Redis默认有 16个数据库,可以通过 <code>select  数据库编号</code> 来调整使用数据库.<br><img src="https://img-blog.csdnimg.cn/20201113170833508.png#pic_center" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20201113171229415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FLUSHDB     //清空当前库数据</span><br><span class="line">FLUSHALL    //清空所有数据 </span><br></pre></td></tr></table></figure></p><h3 id="4-3-Redis-常用数据类型及操作"><a href="#4-3-Redis-常用数据类型及操作" class="headerlink" title="4.3 Redis 常用数据类型及操作"></a>4.3 Redis 常用数据类型及操作</h3><p><img src="https://img-blog.csdnimg.cn/20201113171609400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><a href="http://redisdoc.com/">Redis命令总和</a></p><p><strong>(1) String 字符串数据类型</strong><br><img src="https://img-blog.csdnimg.cn/20201113171754416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">exists key的名字              //判断某个key是否存在</span><br><span class="line">move key  db                 //当前库就没有了，被移除了</span><br><span class="line">expire key秒钟               //给指定的key设置过期时间，已经过期的key就不会存在了，不是不能访问</span><br><span class="line">ttl  key                    //看看还有多少秒过期  -1表示永不过期、-2表示已经过期</span><br><span class="line">type  key                   //查看key是什么类型</span><br><span class="line">set、get、del、append、strlen    //设置、获取、删除、追加、求长度</span><br><span class="line">incr、decr、incrby、decrby       //数字加或者减</span><br><span class="line">setrange、getrange             //范围设值、范围取值</span><br><span class="line">setex(set with expire)    键   过期时间(秒)   值 </span><br><span class="line">setnx(set  if  not  exist)         //不存在就设置值</span><br><span class="line">mset、mget、msetnx          //多值设置、多值获取；注意多值操作有一个操作后续都会失效</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p><strong>(2) Hash 键值对组合</strong><br><img src="https://img-blog.csdnimg.cn/202011131719089.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hset  key1  name  zhangsan                 //一个key对应的是一个键值对</span><br><span class="line">hget  key1   name                                 //获取对应key的某个值</span><br><span class="line">hmset  key1   name zhangsan  age 2  .....      //一个key对应的是一个Map集合</span><br><span class="line">hgetall  key1                                         //获取对应key的所有值</span><br><span class="line">hdel   key1    name                              //删除key1 对应的name这个键值对</span><br><span class="line">hlen    key1                                          //获取key1 对应的长度</span><br><span class="line">hexists   key1                                       //在Key里面是否存在某个key</span><br><span class="line">hkeys/kvals                                          //获取所有的键值对中 所有键/所有值</span><br><span class="line">hincrby/hincrbyfloat    键     值             //给对应的键增加一定的值</span><br><span class="line">hsetnx  ...........                                     //不存在就设置值</span><br></pre></td></tr></table></figure><p><strong>(3) List 列表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lpush 键   [列表值]          //从左边往右边插入</span><br><span class="line">rpush 键   [列表值]          //从右边往左边插入</span><br><span class="line">lpop  键    //从最左边弹出一个</span><br><span class="line">rpop  键    //从最右边弹出一个</span><br><span class="line">lindex/rindex   键   下标   //从左边(右边)数获取指定下标的值</span><br><span class="line">llen   键      //获取列表的长度</span><br><span class="line">lrem  键   n个value   //从左边起删除n个value</span><br><span class="line">ltrim  键  开始index   结束index    //截取指定键的某个范围的值然后赋给自身</span><br><span class="line">lpoprpush  键1    键2    //将1中左侧移到2的右侧</span><br><span class="line">lset  键  下标   值      //给指定位置赋值</span><br><span class="line">linsert  键  before/after  值1  值2     //在值1后面(前面)插入值2</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201113200218877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>(4) Set 无序不可重列表</strong></p><p><img src="https://img-blog.csdnimg.cn/20201113200230116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sadd  键   [值列表]            //添加值列表</span><br><span class="line">smembers  键                   //获取键对应的值列表</span><br><span class="line">scard  键                           //获取键中对应集合元素的个数</span><br><span class="line">srem   键   值                    //删除某个值</span><br><span class="line">srandmember  key  某个整数        //随机获取几个值</span><br><span class="line">spop  key                          //随即出栈</span><br><span class="line">smove key1  key2   key1中的某个值          //将key1 里的某个值赋值给 key2</span><br><span class="line">sdiff   set1   set2               //输出仅仅在set1中出现的值</span><br><span class="line">sinter  set1  set2               //输出同时在set1 、 set2中出现的值</span><br><span class="line">sunion   set1   set2           //求set1、set2 的并集</span><br></pre></td></tr></table></figure><p><strong>(5) Zset 有序集合</strong><br><img src="https://img-blog.csdnimg.cn/20201113172150632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zadd  key1   60 v1 70 v2 80 v3 90 v4 ....      //给key1设置键和值</span><br><span class="line">zrange   key1   0   -1                                    //类似于 lrange获取所有的键</span><br><span class="line">zrange   key1   0   -1   withscores                //获取所有的键+score</span><br><span class="line">zrevrange  key1  0  -1                                  //倒序获取所有值(不包括score)</span><br><span class="line">zrevrange   key1   0   -1   withscores                //倒序获取所有的键+score</span><br><span class="line">zrangebyscore  key1   开始score  结束score    limit  xx   xx  //按照score排序，limit开始下标、多少步</span><br><span class="line">zrem    key1   某个value                               //删除某个socre对应的value</span><br><span class="line">zcard   key1                                                  //获取值的个数</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201113205002686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201113210254646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjg0OTg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201113212652950.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17.打印从1到最大的n位数</title>
      <link href="/2020/10/02/%E5%8A%9B%E6%89%A3%E5%89%91%E6%8C%87offer_17/"/>
      <url>/2020/10/02/%E5%8A%9B%E6%89%A3%E5%89%91%E6%8C%87offer_17/</url>
      
        <content type="html"><![CDATA[<p><img src="/passageImg/leetcode.assets/image-20210205212113049.png"></p><h2 id="问题扩展："><a href="#问题扩展：" class="headerlink" title="问题扩展："></a>问题扩展：</h2><p>本题应当考察的是大数问题，当 n较大时，end会超出 int32 整型的范围，超出取值范围的数字无法正常存储。</p><p>大数问题的解决需要考虑三个方面的重点：</p><ul><li>1 . 表示大数的变量类型</li></ul><p>  无论是 short &#x2F; int &#x2F; long … 任意变量类型，数字的取值范围都是有限的。因此，大数的表示应用字符串 String 类型。</p><ul><li>2 .数字进位</li></ul><p>​        比如说从 9进一位到10 ，从99进1位到100.需要考虑如何操作。</p><ul><li>3 .递归的全排列</li></ul><p>​        基于分治的思想，当 n&#x3D;2时可以分为各位和十位。先固定个位，然后十位依次从 0到9设置。</p><span id="more"></span><h2 id="过程重点："><a href="#过程重点：" class="headerlink" title="过程重点："></a>过程重点：</h2><ul><li><p>设置一个char 类型的数组来存储递归过程中某一位的数字，当当前待设置的位置等于题目给出的位数时说明所有位置的数字已经排列完毕，那么生成字符串凭借在结果后面。</p></li><li><p>对于数字0的处理，开始没有考虑这一点，结果中会出现 01 、001 、0001 这种情况，这不符合题意。那么如何去除多余的0。举例可以发现，当 n&#x3D;2时，当 结果为 01 时我们需要 String.subString(1)；当结果为 001 时我们需要 subString(2)。而从 9进一位到 10时截取的位置发生了改变，从1变化为了 0 ，可以得出  如果等式  nine + start &#x3D; n 成立时(start 为截取的位置、 nine 为9的个数)，需要将 start–</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 大数问题打印----输出 从1到最大n位数的所有数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">  <span class="type">int</span> n,nine,start;</span><br><span class="line">  <span class="type">char</span> []num,loop= &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">printNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.n=n;</span><br><span class="line">  start = n-<span class="number">1</span>;</span><br><span class="line">  nine = <span class="number">0</span>;</span><br><span class="line">  num = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  System.out.println(res.toString());</span><br><span class="line">  <span class="keyword">return</span> res.toString();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(x == n) &#123;</span><br><span class="line">  <span class="comment">//最后遍历完了所有的位数</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(num).substring(start);</span><br><span class="line">  res.append(s).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(start+nine==n)</span><br><span class="line">  start--;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//没有遍历完就存储当前位到num数组中</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">char</span> ch:loop) &#123;</span><br><span class="line">  <span class="keyword">if</span>(ch==<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">  nine++;</span><br><span class="line">  num[x] = ch;</span><br><span class="line">  dfs(x+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  nine--;   <span class="comment">//注意这里的nine 为9的个数，每次递归完成后必须减1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">结果打印：  <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23.</span>...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 16.数值的整数次方</title>
      <link href="/2020/10/01/%E5%8A%9B%E6%89%A3%E5%89%91%E6%8C%87offer_16/"/>
      <url>/2020/10/01/%E5%8A%9B%E6%89%A3%E5%89%91%E6%8C%87offer_16/</url>
      
        <content type="html"><![CDATA[<p><img src="/passageImg/leetcode.assets/image-20210205194904762.png"></p><h2 id="扩展算法："><a href="#扩展算法：" class="headerlink" title="扩展算法："></a>扩展算法：</h2><blockquote><p>快速幂算法： </p><p>快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法之所以时间复杂度非常高（为O(指数n)），就是因为当指数n非常大的时候，需要执行的循环操作次数也非常大。所以我们快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。</p></blockquote><h3 id="算法讲解："><a href="#算法讲解：" class="headerlink" title="算法讲解："></a>算法讲解：</h3><p>比如说一道ACM算法题：  求 A^B的最后三位数表示的整数</p><ul><li>解法一：  很简单啊，先求出该数然后对1000求余就得到了结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通的求幂函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> base 底数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> power  指数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  求幂结果的最后3位数表示的整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">normalPower</span><span class="params">(<span class="type">long</span> base,<span class="type">long</span> power)</span>&#123;</span><br><span class="line">     <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=power;i++)&#123;</span><br><span class="line">         result = result*base;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result%<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来没有问题，但是输入测试用例(2 ,100) ，发现结果为0。为什么呢？</p><p>首先Java 中的数据表示是有一定的范围的，比如说int(-2147483648,+2147483648)，long 的范围相应更大。但是题目中2^100它的数值已经远远大于了long表示的范围。如果一个数已经无法表示，那么相应它与1000的余数就更不用说求出来了。</p><span id="more"></span><ul><li>解法二： 在计算过程中进行求余运算</li></ul><p>“取模”运算的规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(a + b) % p = (a % p + b % p) % p （1）</span><br><span class="line"></span><br><span class="line">(a - b) % p = (a % p - b % p ) % p （2）</span><br><span class="line"></span><br><span class="line">(a * b) % p = (a % p * b % p) % p （3）</span><br></pre></td></tr></table></figure><p>第三条，两个数乘积的取模 &#x3D;  各个因子分别取模然后乘起来综合取模。 相应的代码变换成这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通的求幂函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> base 底数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> power  指数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  求幂结果的最后3位数表示的整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">normalPower</span><span class="params">(<span class="type">long</span> base,<span class="type">long</span> power)</span>&#123;</span><br><span class="line">     <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=power;i++)&#123;</span><br><span class="line">         result = result*base;</span><br><span class="line">         result = result%<span class="number">1000</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result%<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>解法三：解法二已经能够解决问题，但是速度太慢，如果我要求 2^10000000000，那么循环就需要执行10000000000次，这显然不合理。因此考虑降低计算循环的次数。</p><p>快速幂法入门：快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法之所以时间复杂度非常高（为O(指数n)），就是因为当指数n非常大的时候，需要执行的循环操作次数也非常大。所以我们快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3^10=(3*3)*(3*3)*(3*3)*(3*3)*(3*3)   //循环10次</span><br><span class="line"> </span><br><span class="line">3^10=(3*3)^5                         //循环5次</span><br><span class="line"></span><br><span class="line">3^10=9^5                             //循环1次</span><br></pre></td></tr></table></figure><p>可以看出，通过对指数进行折半，底数翻倍 的操作能够很大程度上降低循环的次数。如果说指数不是一个偶数，那么可以将它转化为偶数次幂乘以本身，将单独的一个提取出来先进行和结果的乘法操作。代码可以修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通的求幂函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> base 底数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> power  指数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  求幂结果的最后3位数表示的整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">normalPower</span><span class="params">(<span class="type">long</span> base,<span class="type">long</span> power)</span>&#123;</span><br><span class="line">     <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span>(power&gt;<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(power%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="comment">//指数为偶数</span></span><br><span class="line">             power=power/<span class="number">2</span>;</span><br><span class="line">             base=base*base%<span class="number">1000</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="comment">//指数为奇数</span></span><br><span class="line">             result=result*base%<span class="number">1000</span>;</span><br><span class="line">             power=power-<span class="number">1</span>;</span><br><span class="line">             power=power/<span class="number">2</span>;</span><br><span class="line">             base=base*base%<span class="number">1000</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result%<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解法四： 上面的解法三已经有了快速幂算法的味道了，接下来我们需要对代码中的重复部分进行提取优化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通的求幂函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> base 底数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> power  指数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  求幂结果的最后3位数表示的整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">normalPower</span><span class="params">(<span class="type">long</span> base,<span class="type">long</span> power)</span>&#123;</span><br><span class="line">     <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span>(power&gt;<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(power%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="comment">//指数为奇数，先进行乘法操作将其转化为偶数</span></span><br><span class="line">             result=result*base%<span class="number">1000</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         power=power/<span class="number">2</span>;</span><br><span class="line">         base=base*base%<span class="number">1000</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result%<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解法五：终极优化  power%2&#x3D;&#x3D;1 的求余运算可以用位运算来代替。例如：power&amp;1。因为如果power为偶数，则其二进制表示的最后一位一定是0；如果power是奇数，则其二进制表示的最后一位一定是1。将他们分别与1的二进制做“与”运算，得到的就是power二进制最后一位的数字了，是0则为偶数，是1则为奇数。例如5是奇数，则5&amp;1&#x3D;1；而6是偶数，则6&amp;1&#x3D;0；因此奇偶数的判断就可以用“位运算”来替换了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 普通的求幂函数</span><br><span class="line"> * @param base 底数</span><br><span class="line"> * @param power  指数</span><br><span class="line"> * @return  求幂结果的最后3位数表示的整数</span><br><span class="line"> */</span><br><span class="line">public long normalPower(long base,long power)&#123;</span><br><span class="line">     long result = 1;</span><br><span class="line">     while(power&gt;0)&#123;</span><br><span class="line">         if((power&amp;1)==0)&#123;</span><br><span class="line">         //指数为奇数，先进行乘法操作将其转化为偶数</span><br><span class="line">             result=result*base%1000;</span><br><span class="line">         &#125;</span><br><span class="line">         power=power/2;</span><br><span class="line">         base=base*base%1000;</span><br><span class="line">     &#125;</span><br><span class="line">     return result%1000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到这一题，直接通过快速幂算法进行求解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           x=<span class="number">1</span>/x;</span><br><span class="line">           b=-b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((b&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                res = res*x;</span><br><span class="line">            &#125;</span><br><span class="line">            x= x*x;</span><br><span class="line">            b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer 15.二进制中1的个数</title>
      <link href="/2020/10/01/%E5%8A%9B%E6%89%A3%E5%89%91%E6%8C%87offer_15/"/>
      <url>/2020/10/01/%E5%8A%9B%E6%89%A3%E5%89%91%E6%8C%87offer_15/</url>
      
        <content type="html"><![CDATA[<p><img src="/passageImg/%E5%89%91%E6%8C%87offer.assets/image-20210205193604111.png"></p><h2 id="扩展知识："><a href="#扩展知识：" class="headerlink" title="扩展知识："></a>扩展知识：</h2><p>该题重点考察的是如何将一个十进制整数转化为它的二进制数形式。有以下三种方法：</p><ul><li>方法一(除基倒取余法)：</li></ul><p>类似于数学求二进制的过程，将原数n 不断除以2求出余数然后把商作为下一次的待除数，直到商为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binaryToDecimal</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">     <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">         str = n%<span class="number">2</span>+str;</span><br><span class="line">         n = n/<span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">         System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>方法二(移位操作)：</li></ul><p>可以利用移位操作对一个十进制数进行移位。将最高位的数移动至最低为(移31位)，然后将最低位的其余位置都清零，使用 &amp; 操作，可以使用和 1 相与来获得该位置对应的二进制位数值；再次移动高位，做出相同的操作，直到最后一位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binaryToDecimal2</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>;i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">         System.out.print(n &gt;&gt;&gt; i &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法三(调用API函数):</li></ul><p>使用包装类Integer 的  toBinaryString()  方法将一个int型整数转化为 二进制字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function1</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Integer.toBinaryString(n);</span><br><span class="line">      <span class="comment">//int r = Integer.parseInt(result);</span></span><br><span class="line">      <span class="comment">//System.out.println(r);</span></span><br><span class="line">      System.out.println(result);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>之后该题都很简单了</p>]]></content>
      
      
      <categories>
          
          <category> 力扣剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.减绳子</title>
      <link href="/2020/10/01/%E5%8A%9B%E6%89%A3%E5%89%91%E6%8C%87offer_14_II/"/>
      <url>/2020/10/01/%E5%8A%9B%E6%89%A3%E5%89%91%E6%8C%87offer_14_II/</url>
      
        <content type="html"><![CDATA[<p><img src="/passageImg/%E5%89%91%E6%8C%87offer.assets/image-20210201112350177.png"></p><h4 id="1-DP-求解"><a href="#1-DP-求解" class="headerlink" title="1. DP 求解"></a>1. DP 求解</h4><p>假设 res[n] 代表长度为 n 的绳子的最大乘积，那么  res[n] &#x3D; max(res[n-i] * res[i])，其中(1&lt;&#x3D;i&lt;n)</p><p>特别的有一些特殊值：  </p><p>​       res[0] &#x3D; 0;   &#x2F;&#x2F;不存在</p><p>​       res[1] &#x3D; 1;  </p><p>​       res[2] &#x3D; 2;   &#x2F;&#x2F;在长度为2时该绳子就不应该被分割了，分割会更小</p><p>​       res[3] &#x3D; 3;   &#x2F;&#x2F;在长度为3时不应该被分割，分割会更小</p><span id="more"></span><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">// res 数组代表长度为i 的绳子的最大乘积</span></span><br><span class="line"><span class="comment">// 注意res[2]此时为2不为1，因为绳子长度此时大于3，那么如果划分到了长度为2的一段就不应该被切割，保持原绳子长度即可</span></span><br><span class="line"><span class="type">int</span> []res = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">res[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">res[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">res[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">res[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">tempMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i/<span class="number">2</span>;j++) &#123;</span><br><span class="line">tempMax = Math.max(tempMax,res[j]*res[i-j]);</span><br><span class="line">&#125;</span><br><span class="line">res[i] = tempMax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-贪心法"><a href="#2-贪心法" class="headerlink" title="2. 贪心法"></a>2. 贪心法</h4><p>可以通过数学方法证明如下推论：</p><ul><li>推论一：合理的切分方案可以带来更大的乘积</li></ul><p>设一根绳子长度为n（n&gt;1），切分为两段 n &#x3D; n1+n2，切分为三段 n &#x3D; n1+n2+n3。根据经验推测，三段的乘积往往更大，即往往有 n1n2n3 &gt; n1n2。</p><p>当然也存在反例，比如两段 6 &#x3D;3+3 和三段 6 &#x3D;2+2+2，则有 3×3 &gt; 2×2×2</p><ul><li>推论二：若切分方案合理，绳子切分越多，乘积越大</li></ul><p>总体上看，貌似长绳子切分为越多，但其实到某个长度分界点后，乘积到达最大值就不再切分了。</p><ul><li>推论三：为使乘积最大，只有长度为2和3的绳子不应再切分，切3比2更优</li></ul><p><img src="/passageImg/%E5%89%91%E6%8C%87offer.assets/image-20210201114428581.png"></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> Math.floor(n/<span class="number">3</span>);   <span class="comment">//计算能够划分为长度为3的绳子段数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> n%<span class="number">3</span>;   <span class="comment">//计算余数</span></span><br><span class="line"><span class="keyword">if</span>(left == <span class="number">0</span>) <span class="keyword">return</span> Math.pow(<span class="number">3</span>,count);     <span class="comment">//长度是3的整倍数</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="number">1</span>) <span class="keyword">return</span> Math.pow(<span class="number">3</span>,count-<span class="number">1</span>)*<span class="number">4</span>;  <span class="comment">//长度按3划分后还剩余一段1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> Math.pow(<span class="number">3</span>,count)*<span class="number">2</span>;    <span class="comment">//长度按3划分后还剩余一段2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/passageImg/%E5%89%91%E6%8C%87offer.assets/image-20210201112221941.png"></p><h4 id="1-DP的缺陷-不可用"><a href="#1-DP的缺陷-不可用" class="headerlink" title="1.DP的缺陷(不可用)"></a>1.DP的缺陷(不可用)</h4><p>这个题和剪绳子I一样的描述，就是数据范围变大了。剪绳子可以用动态规划或者贪心做，这道题对于使用DP难度就增大了一些，因为数据范围变得比较大时，long已经不足以去存储中间结果的状态，但是由于DP做法是枚举各种剪的情况然后取最大值，因此只能通过使用BigInteger的方法去做，这点评论区已经有人给出了解答。</p><p>那么这个题范围变大的本意是想让我们使用贪心算法能更好的求解(毕竟BigInteger使用起来麻烦，贪心没有数据溢出的问题，它是找当下的最优解，不需要比较，中间结果可以直接取模)。</p><h4 id="2-贪心法-可用"><a href="#2-贪心法-可用" class="headerlink" title="2. 贪心法(可用)"></a>2. 贪心法(可用)</h4><p>我们首先考虑对于一段长n的绳子，我们可以切出的结果包含什么？</p><p>1 会包含吗？ 不会，因为1 * (k - 1) &lt; k, 只要把1和任何一个其他的片段组合在一起就有个更大的值<br>        2 可以<br>        3 可以<br>        4 可以吗？ 它拆成两个2的效果和本身一样，因此也不考虑<br>        5 以上可以吗？ 不可以，这些绳子必须拆，因为总有一种拆法比不拆更优，比如拆成 k &#x2F; 2 和 k - k &#x2F; 2</p><p>综上, 最后的结果只包含2和3(当然当总长度为2和3时单独处理), 那么很显然n &gt;&#x3D; 5时， 3*(n - 3) &gt;&#x3D; 2 * (n - 2) ，因此我们优先拆成3，最后剩余的拆成2。最后的结果一定是由若干个3和1或2个2组成.</p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            res *= <span class="number">3</span>;</span><br><span class="line">            res %= mod;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(res * n % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-快速幂解-基于贪心法"><a href="#3-快速幂解-基于贪心法" class="headerlink" title="3.快速幂解(基于贪心法)"></a>3.快速幂解(基于贪心法)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt3</span> <span class="operator">=</span> n / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)pow(<span class="number">3</span>, cnt3);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)((pow(<span class="number">3</span>, cnt3 - <span class="number">1</span>) * <span class="number">4</span>) % mod);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)((pow(<span class="number">3</span>, cnt3) * <span class="number">2</span>) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">pow</span><span class="params">(<span class="type">long</span> base, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((num &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            res *= base;</span><br><span class="line">            res %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        base *= base;</span><br><span class="line">        base %= mod;</span><br><span class="line">        num &gt;&gt;= ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速幂算法：<a href="https://blog.csdn.net/qq_19782019/article/details/85621386">https://blog.csdn.net/qq_19782019/article/details/85621386</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序_喵喵交友（二）</title>
      <link href="/2020/09/14/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B(%E4%BA%8C)/"/>
      <url>/2020/09/14/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="Social-Contact"><a href="#Social-Contact" class="headerlink" title="Social Contact"></a>Social Contact</h2><h3 id="一、Social-Contact介绍："><a href="#一、Social-Contact介绍：" class="headerlink" title="一、Social Contact介绍："></a>一、Social Contact介绍：</h3><h4 id="1-1-小程序介绍："><a href="#1-1-小程序介绍：" class="headerlink" title="1.1 小程序介绍："></a>1.1 小程序介绍：</h4><p>Social Contact是一款用于社交交友的小程序，它能够根据用户的登录情况来展示不同的界面特性，其中包含了给心仪用户点赞、获取附近用户的信息进行社交、主动添加对方为好友、查看自己的消息邮箱、好友列表、自己以及好友的信息等等功能。</p><span id="more"></span><h4 id="1-2-目标用户："><a href="#1-2-目标用户：" class="headerlink" title="1.2 目标用户："></a>1.2 目标用户：</h4><p>面向各个年龄段、各种职业的用户，希望通过app来找到趣味相投的人，同时结交更多的朋友。</p><h4 id="1-3-应用场景："><a href="#1-3-应用场景：" class="headerlink" title="1.3 应用场景："></a>1.3 应用场景：</h4><p>利用微信小程序这个平台，方便快捷地搭建起日常生活中人与人之间的社交网络，丰富人们的生活。</p><h3 id="二、小程序架构思路："><a href="#二、小程序架构思路：" class="headerlink" title="二、小程序架构思路："></a>二、小程序架构思路：</h3><blockquote><p><strong>就整体而言，小程序主要分为首页+附近的人+消息+我的 四个主要模块来进行构造</strong></p></blockquote><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200920000900672.png"></p><h3 id="三、小程序的实现及效果图："><a href="#三、小程序的实现及效果图：" class="headerlink" title="三、小程序的实现及效果图："></a>三、小程序的实现及效果图：</h3><h4 id="3-1-效果截图："><a href="#3-1-效果截图：" class="headerlink" title="3.1 效果截图："></a>3.1 效果截图：</h4><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/5EC3E7436061F7B5D0BEF426528587B8.png"></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/C0E170BF0FC00652C09A3C57CCDCB7DF.png"></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/D17FC5D09EA413E83D62B837FD2C2990.png"></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/830FA5AFCB5E83AA24CC4E5BA7313136.png"></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/30CBF684FC2794BDE6976E49288E0A36.png"></p><h4 id="3-2-部分功能代码："><a href="#3-2-部分功能代码：" class="headerlink" title="3.2 部分功能代码："></a>3.2 部分功能代码：</h4><blockquote><p>自动登录：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 自动登录</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="title function_">autoLogin</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">getUserLocation</span>();</span><br><span class="line">   <span class="comment">//用户自动登录功能的实现----调用云函数 login</span></span><br><span class="line">   wx.<span class="property">cloud</span>.<span class="title function_">callFunction</span>(&#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">     <span class="attr">data</span>:&#123;&#125;</span><br><span class="line">   &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">//此时会返回登录用户的openid，根据这个id去数据库中查询用户进行数据渲染,注意通过where查询出的data是数组</span></span><br><span class="line">      db.<span class="title function_">collection</span>(<span class="string">&#x27;users&#x27;</span>).<span class="title function_">where</span>(&#123;</span><br><span class="line">        <span class="attr">_openid</span>: res.<span class="property">result</span>.<span class="property">openid</span></span><br><span class="line">      &#125;).<span class="title function_">get</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">one</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//如果查询出没有数据，则需要先登录,并且此时按钮可用</span></span><br><span class="line">        <span class="keyword">if</span>(one.<span class="property">data</span>.<span class="property">length</span>)&#123;</span><br><span class="line">          app.<span class="property">userInfo</span>=<span class="title class_">Object</span>.<span class="title function_">assign</span>(app.<span class="property">userInfo</span>,one.<span class="property">data</span>[<span class="number">0</span>]);</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">userName</span>:app.<span class="property">userInfo</span>.<span class="property">userName</span>,</span><br><span class="line">            <span class="attr">userPhoto</span>:app.<span class="property">userInfo</span>.<span class="property">userPhoto</span>,</span><br><span class="line">            <span class="attr">isLogin</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="attr">disabled</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="attr">_id</span>:app.<span class="property">userInfo</span>.<span class="property">_id</span></span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="comment">//监听用户数据变化</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">watchDbChange</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">disabled</span>:<span class="literal">false</span></span><br><span class="line">           &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><blockquote><p>通过好友申请与消息列表的处理和清空：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//删除申请消息</span></span><br><span class="line">  <span class="title function_">removeMessage</span>(<span class="params"></span>)&#123;</span><br><span class="line">     wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">       <span class="attr">title</span>:<span class="string">&#x27;提示&#x27;</span>,</span><br><span class="line">       <span class="attr">content</span>:<span class="string">&#x27;删除消息&#x27;</span>,</span><br><span class="line">       <span class="attr">confirmText</span>:<span class="string">&#x27;删除&#x27;</span>,</span><br><span class="line">       <span class="attr">success</span>:<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">         <span class="comment">//删除消息-----数据库查找集合删除，同时更新message中的数据</span></span><br><span class="line">           <span class="keyword">if</span>(res.<span class="property">confirm</span>)&#123;</span><br><span class="line">               <span class="variable language_">this</span>.<span class="title function_">deleteAndUpdate</span>();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(res.<span class="property">cancel</span>)&#123;</span><br><span class="line">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;取消&#x27;</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除指定用户请求并更新数据库(方法提炼)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">deleteAndUpdate</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始前清数据了&quot;</span>);</span><br><span class="line">      <span class="comment">//先查找后更新---不能直接更新</span></span><br><span class="line">      db.<span class="title function_">collection</span>(<span class="string">&#x27;message&#x27;</span>).<span class="title function_">where</span>(&#123;</span><br><span class="line">        <span class="attr">userId</span>:app.<span class="property">userInfo</span>.<span class="property">_id</span></span><br><span class="line">      &#125;).<span class="title function_">get</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">        <span class="keyword">var</span> list=res.<span class="property">data</span>[<span class="number">0</span>].<span class="property">list</span>;</span><br><span class="line">        <span class="comment">//过滤list数组，将对应的_id过滤掉</span></span><br><span class="line">        list=list.<span class="title function_">filter</span>(<span class="function">(<span class="params">val,i</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> val != <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">messageId</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//重新赋值----更新数据库</span></span><br><span class="line">        wx.<span class="property">cloud</span>.<span class="title function_">callFunction</span>(&#123;</span><br><span class="line">          <span class="attr">name</span>:<span class="string">&#x27;update&#x27;</span>,</span><br><span class="line">          <span class="attr">data</span>:&#123;</span><br><span class="line">            <span class="attr">collection</span>:<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">            <span class="attr">where</span>:&#123;</span><br><span class="line">              <span class="attr">userId</span>:app.<span class="property">userInfo</span>.<span class="property">_id</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">data</span>:&#123;</span><br><span class="line">              list</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="comment">//更新成功，由子组件removeList向父组件 message发送消息</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;myevent&#x27;</span>,list);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//同意添加好友</span></span><br><span class="line">  <span class="title function_">addFriend</span>(<span class="params"></span>)&#123;</span><br><span class="line">    wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>:<span class="string">&#x27;通知消息&#x27;</span>,</span><br><span class="line">      <span class="attr">content</span>:<span class="string">&#x27;是否添加?&#x27;</span>,</span><br><span class="line">      <span class="attr">confirmText</span>:<span class="string">&#x27;同意&#x27;</span>,</span><br><span class="line">      <span class="attr">cancelText</span>:<span class="string">&#x27;拒绝&#x27;</span>,</span><br><span class="line">      <span class="attr">success</span>:<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//同意添加-----清楚消息、更新自己数据库、更新朋友的数据库(只能用云函数)</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">confirm</span>)&#123;</span><br><span class="line">             <span class="comment">//1.更新自己数据库</span></span><br><span class="line">             db.<span class="title function_">collection</span>(<span class="string">&#x27;users&#x27;</span>).<span class="title function_">doc</span>(app.<span class="property">userInfo</span>.<span class="property">_id</span>).<span class="title function_">update</span>(&#123;</span><br><span class="line">               <span class="attr">data</span>:&#123;</span><br><span class="line">                 <span class="attr">friendList</span>: _.<span class="title function_">unshift</span>(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">messageId</span>)</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;自己添加&quot;</span>+res);</span><br><span class="line">             &#125;);</span><br><span class="line">             <span class="comment">//2.更新朋友数据库</span></span><br><span class="line">             wx.<span class="property">cloud</span>.<span class="title function_">callFunction</span>(&#123;</span><br><span class="line">               <span class="attr">name</span>:<span class="string">&#x27;update&#x27;</span>,</span><br><span class="line">               <span class="attr">data</span>:&#123;</span><br><span class="line">                 <span class="attr">collection</span>:<span class="string">&#x27;users&#x27;</span>,</span><br><span class="line">                 <span class="attr">doc</span>:<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">messageId</span>,</span><br><span class="line">                 <span class="attr">data</span>:<span class="string">`&#123;friendList: _.unshift(&#x27;<span class="subst">$&#123;app.userInfo._id&#125;</span>&#x27;)&#125;`</span></span><br><span class="line">               &#125;</span><br><span class="line">             &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;朋友添加&quot;</span>+res);</span><br><span class="line">             &#125;);</span><br><span class="line">             <span class="comment">//3.向父组件发送请求清除消息</span></span><br><span class="line">               <span class="variable language_">this</span>.<span class="title function_">deleteAndUpdate</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>地图模块获取周围用户的信息</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取登录用户附近的用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">getNearLocation</span>(<span class="params"></span>)&#123;</span><br><span class="line">  db.<span class="title function_">collection</span>(<span class="string">&#x27;users&#x27;</span>).<span class="title function_">where</span>(&#123;</span><br><span class="line">    <span class="attr">location</span>: _.<span class="title function_">geoNear</span>(&#123;</span><br><span class="line">      <span class="attr">geometry</span>: db.<span class="property">Geo</span>.<span class="title class_">Point</span>(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">logitude</span>,<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">altitude</span>),</span><br><span class="line">      <span class="attr">minDistance</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">maxDistance</span>: <span class="number">5000</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="attr">isLocation</span>:<span class="literal">true</span>           <span class="comment">//允许共享的才能查询</span></span><br><span class="line">  &#125;).<span class="title function_">field</span>(&#123;</span><br><span class="line">    <span class="attr">userPhoto</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">userName</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">_id</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">logitude</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">altitude</span>:<span class="literal">true</span></span><br><span class="line">  &#125;).<span class="title function_">get</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">//获取成功，过滤掉用户的图片，全部更改为真实URL</span></span><br><span class="line">      <span class="keyword">let</span> array=[];</span><br><span class="line">      <span class="keyword">let</span> mdata=res.<span class="property">data</span>;</span><br><span class="line">      <span class="keyword">if</span>(mdata.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;mdata.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//  //开始过滤</span></span><br><span class="line">             <span class="keyword">if</span>(mdata[i].<span class="property">userPhoto</span>.<span class="title function_">includes</span>(<span class="string">&#x27;cloud://&#x27;</span>))</span><br><span class="line">             &#123;</span><br><span class="line">                 wx.<span class="property">cloud</span>.<span class="title function_">getTempFileURL</span>(&#123;</span><br><span class="line">                   <span class="attr">fileList</span>: [ mdata[i].<span class="property">userPhoto</span> ],</span><br><span class="line">                   <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">                        array.<span class="title function_">push</span>(&#123;</span><br><span class="line">                          <span class="attr">iconPath</span>: res.<span class="property">fileList</span>[<span class="number">0</span>].<span class="property">tempFileURL</span>,</span><br><span class="line">                          <span class="attr">id</span>: mdata[i].<span class="property">_id</span>,</span><br><span class="line">                          <span class="attr">latitude</span>: mdata[i].<span class="property">altitude</span>,</span><br><span class="line">                          <span class="attr">longitude</span>: mdata[i].<span class="property">logitude</span>,</span><br><span class="line">                          <span class="attr">width</span>: <span class="number">30</span>,</span><br><span class="line">                          <span class="attr">height</span>: <span class="number">30</span></span><br><span class="line">                      &#125;);</span><br><span class="line">                      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;           <span class="comment">//此处需要渲染，不然最后还是打印不出来</span></span><br><span class="line">                        <span class="attr">marks</span>:array</span><br><span class="line">                      &#125;)</span><br><span class="line">                   &#125;</span><br><span class="line">                 &#125;)</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//不需要过滤直接添加</span></span><br><span class="line">             <span class="keyword">else</span>&#123;</span><br><span class="line">               array.<span class="title function_">push</span>(&#123;</span><br><span class="line">                  <span class="attr">iconPath</span>: mdata[i].<span class="property">userPhoto</span>,</span><br><span class="line">                  <span class="attr">id</span>: mdata[i].<span class="property">_id</span>,</span><br><span class="line">                  <span class="attr">latitude</span>: mdata[i].<span class="property">altitude</span>,</span><br><span class="line">                  <span class="attr">longitude</span>: mdata[i].<span class="property">logitude</span>,</span><br><span class="line">                  <span class="attr">width</span>: <span class="number">40</span>,</span><br><span class="line">                  <span class="attr">height</span>: <span class="number">40</span></span><br><span class="line">               &#125;)</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">marks</span>:array</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="四、预览使用"><a href="#四、预览使用" class="headerlink" title="四、预览使用"></a>四、预览使用</h3><p>体验二维码：</p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/orN3s4lDPJrro_mgZ7za4J2wuuEk.jpg"></p><h3 id="五、开发者"><a href="#五、开发者" class="headerlink" title="五、开发者"></a>五、开发者</h3><p><strong>iStitches   Github个人主页：  <a href="https://github.com/iStitches">https://github.com/iStitches</a></strong></p><p><strong>wulidurant  Github个人主页：<a href="https://github.com/wulidurant">https://github.com/wulidurant</a></strong></p><h3 id="六、完整代码"><a href="#六、完整代码" class="headerlink" title="六、完整代码"></a>六、完整代码</h3><p><a href="https://github.com/iStitches/Social-Contact">https://github.com/iStitches/Social-Contact</a></p><p><strong>欢迎大爷们 star !</strong></p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序_喵喵交友（一）</title>
      <link href="/2020/09/05/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B(%E4%B8%80)/"/>
      <url>/2020/09/05/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-前言叙述："><a href="#1-1-前言叙述：" class="headerlink" title="1.1 前言叙述："></a>1.1 前言叙述：</h2><h4 id="（1）小程序没有DOM对象，一切基于组件化"><a href="#（1）小程序没有DOM对象，一切基于组件化" class="headerlink" title="（1）小程序没有DOM对象，一切基于组件化"></a>（1）小程序没有DOM对象，一切基于组件化</h4><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200904194142073.png"></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200904203952615.png"></p><span id="more"></span><h4 id="（2）微信小程序的四个基本文件："><a href="#（2）微信小程序的四个基本文件：" class="headerlink" title="（2）微信小程序的四个基本文件："></a>（2）微信小程序的四个基本文件：</h4><p>​      a.  *.js</p><p>​      b.  *.wxml —–&gt; view结构  ——&gt; html</p><p>​      c.  *.wxss   —–&gt; view 样式——-&gt; css</p><p>​      d.  *.json  ——&gt; view 数据 ——&gt; json文件</p><h4 id="（3）flex布局解析："><a href="#（3）flex布局解析：" class="headerlink" title="（3）flex布局解析："></a>（3）flex布局解析：</h4><blockquote><p><a href="https://www.cnblogs.com/echolun/p/11299460.html">https://www.cnblogs.com/echolun/p/11299460.html</a></p></blockquote><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200904191610287.png"></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200904191619550.png"></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200904191658158.png"></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200904191717596.png"></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200904191734690.png"></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200904191806017.png"></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200904191951198.png"></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200904192103991.png"></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200904192114401.png"></p><h4 id="（4）移动端适配："><a href="#（4）移动端适配：" class="headerlink" title="（4）移动端适配："></a>（4）移动端适配：</h4><p><strong>1.物理像素</strong></p><p>​    屏幕的分辨率；设备显示控制的最小单元，可以把物理像素看成对应的像素点。</p><p><strong>2.设备独立像素&#x2F;css像素</strong><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200904193041079.png"></p><p><strong>3.dpr比 &amp; DPI &amp; PPI</strong></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200904193419868.png"></p><h4 id="（5）小程序的页面配置："><a href="#（5）小程序的页面配置：" class="headerlink" title="（5）小程序的页面配置："></a>（5）小程序的页面配置：</h4><blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar">https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar</a></p></blockquote><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200904210319102.png"></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200904210836036.png"></p><p><strong>tabBar 的第一项必须是所有页面的主页，pages中单个页面的优先级高于主页面</strong></p><h4 id="（6）小程序的双线程模型："><a href="#（6）小程序的双线程模型：" class="headerlink" title="（6）小程序的双线程模型："></a>（6）小程序的双线程模型：</h4><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200905080353582.png"></p><p><strong>界面渲染过程</strong></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200905081002345.png"></p><p><strong>界面渲染的整体流程</strong></p><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200905081401567.png"></p><h4 id="（7）微信小程序的启动流程："><a href="#（7）微信小程序的启动流程：" class="headerlink" title="（7）微信小程序的启动流程："></a>（7）微信小程序的启动流程：</h4><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200905082457233.png"></p><p>首先会加载解析 app.json文件，然后解析app.js文件并注册App()并执行App的生命周期函数；然后会加载注册自定义组件，最后会加载解析首页的page.json文件，由渲染层加载渲染page.wxml文件然后再解析page.js文件，注册Page()并执行Page的生命周期。</p><h4 id="（8）微信小程序的生命周期函数："><a href="#（8）微信小程序的生命周期函数：" class="headerlink" title="（8）微信小程序的生命周期函数："></a>（8）微信小程序的生命周期函数：</h4><p><strong>App对象常用的生命周期函数：</strong></p><p>onLaunch：小程序初始化完成时会触发的函数，一般会先获取用户的相关身份信息[wx.getUserInfo(res)]。(onLaunch仅仅会执行一次)；</p><p>onShow：小程序初始化完毕后触发的函数，可以通过自带的options参数来判断小程序的进入场景。(onShow可能会执行多次)；</p><p>onHide：小程序关闭后触发的函数</p><p>onError：小程序发生错误时触发</p><p><strong>获取用户信息的方式：</strong></p><ol><li>wx.getUserInfo()  ——–即将废弃的接口；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wx.getUserInfo(&#123;</span><br><span class="line">  success(res)&#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>button组件 ——-将open-type修改为getUserInfo，并且绑定bindgetuserInfo事件去获取；这种情况下只有用户去点击小程序才会获取用户的信息进行授权；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button size=&quot;mini&quot; open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUser&quot;&gt;获取用户信息&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">  getUser(res)&#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用open-data 组件来展示用户信息；</li></ol><blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/open-data.html">https://developers.weixin.qq.com/miniprogram/dev/component/open-data.html</a></p></blockquote><p><strong>注册App时我们一般会做如下事情：</strong></p><ol><li><p>判断小程序的进入场景———onShow方法的自带参数res中的scene</p></li><li><p>监听生命周期函数，在生命周期中执行对应的业务逻辑，比如在某个生命周期函数中获取到用户的身份信息；</p></li><li><p>因为App()实例只有一个，并且是全局共享的(单例对象)，所以我们可以将一些共享数据放在App()中，然后在其它页面通过以下方式获取到数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const app=getApp()   //获取App产生的实例对象</span><br><span class="line">console.log(app.UserList);</span><br></pre></td></tr></table></figure></li></ol><hr><p><strong>Page对象常用的生命周期函数：</strong></p><ol><li>onLoad()  ——-&gt;  页面被加载出来时触发(发送网络请求获取数据、通过setData动态地设置变量的值)</li></ol><p><img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200905094729943.png"></p><ol start="2"><li><p>onShow() ——–&gt;  页面显示出来时(当页面被关闭后重新打开时会重新调用)</p></li><li><p>onReady()  ——-&gt; 页面初次渲染完成时</p></li><li><p>onHide() ——–&gt; 页面被隐藏起来时会触发</p></li><li><p>onUnload() —–&gt;页面卸载</p></li></ol><p><strong>注册Page时我们一般会做如下事情：</strong></p><ol><li>初始化数据 ——- data；</li><li>监听页面的生命周期函数 ——onLoad、onShow、onReady、onHide；</li><li>监听wxml中的事件 —–绑定对应的事件函数；</li><li>监听页面的其它事件，如下：<img src="/passageImg/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F_%E5%96%B5%E5%96%B5%E4%BA%A4%E5%8F%8B.assets/image-20200905100417490.png"></li></ol><blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html">https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣 303.区域和检索</title>
      <link href="/2019/10/14/leetcode_304/"/>
      <url>/2019/10/14/leetcode_304/</url>
      
        <content type="html"><![CDATA[<h2 id="303-区域和检索-数组不变"><a href="#303-区域和检索-数组不变" class="headerlink" title="303. 区域和检索 - 数组不变"></a>303. 区域和检索 - 数组不变</h2><p><img src="/passageImg/leetcode.assets/image-20210303085257337.png"></p><h3 id="想法："><a href="#想法：" class="headerlink" title="想法："></a>想法：</h3><ol><li>直接循环计算从i 到 j 两个区域中的所有数值和。但是由于每次检索都需要计算一遍，这样会造成多次计算已有的数值。</li><li>注意到当 i≤j 时，sumRange(i,j) 可以写为如下形式：  sumRange(i,j) &#x3D; 到下标j所有数值和 - 到i-1下标所有数值和。  假设数组 nums 的长度为 n，创建长度为 n+1 的前缀和数组 sums，对于 0≤i&lt;n 都有 sums[i+1] &#x3D; sums[i]+nums[i]，则当 0&lt;i≤n时，sums[i] 表示数组nums 从下标 0到下标 i-1 的前缀和。</li></ol><p>​          因此可以得出：  <code> sumRange(i,j) = sums[j+1] - sums[i]</code></p><span id="more"></span><h3 id="编码："><a href="#编码：" class="headerlink" title="编码："></a>编码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sums;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        sums.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j + <span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：初始化需要计算nums 的前缀和，因此时间复杂度为 O(n)</p><p>空间复杂度：需要创建一个大小为 n+1 的前缀和数组 sums，因此空间复杂度为 O(n)</p><h2 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304. 二维区域和检索 - 矩阵不可变"></a>304. 二维区域和检索 - 矩阵不可变</h2><p><img src="/passageImg/leetcode.assets/image-20210303090428208.png"></p><h3 id="想法：-1"><a href="#想法：-1" class="headerlink" title="想法："></a>想法：</h3><ol><li><p>此题将数组扩展到了二维，如果采用一位前缀和的方式。假设 f(i,j) 为从<code>matrix[0][0]</code>到<code>matrix[i][j]</code>的所有数值和。可以将 sumRegion 看成多个一维数组(每一行当成一个一维数组)，采用一维数组的前缀和计算方式计算区域和。</p></li><li><p>还可以考虑使用二维数组前缀和计算方式。</p><p>计算前缀和：</p></li></ol><p>​          <code>f(i,j) = f(i-1,j) + f(i,j-1) - f(i-1,j-1) + matrix[i][j]</code></p><p><img src="/passageImg/leetcode.assets/1.png"></p><p>​          </p><p>​             计算区域和：</p><p><img src="/passageImg/leetcode.assets/2.png"></p><p><img src="/passageImg/leetcode.assets/3.png"></p><p><img src="/passageImg/leetcode.assets/4.png"></p><p><img src="/passageImg/leetcode.assets/5.png"></p><h3 id="编码：-1"><a href="#编码：-1" class="headerlink" title="编码："></a>编码：</h3><ul><li>一维前缀和解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sums;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">            sums.<span class="built_in">resize</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    sums[i][j + <span class="number">1</span>] = sums[i][j] + matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row1; i &lt;= row2; i++) &#123;</span><br><span class="line">            sum += sums[i][col2 + <span class="number">1</span>] - sums[i][col1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>二维前缀和解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sums;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">            sums.<span class="built_in">resize</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    sums[i + <span class="number">1</span>][j + <span class="number">1</span>] = sums[i][j + <span class="number">1</span>] + sums[i + <span class="number">1</span>][j] - sums[i][j] + matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - sums[row1][col2 + <span class="number">1</span>] - sums[row2 + <span class="number">1</span>][col1] + sums[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/er-wei-qu-yu-he-jian-suo-ju-zhen-bu-ke-b-2z5n/">https://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/er-wei-qu-yu-he-jian-suo-ju-zhen-bu-ke-b-2z5n/</a></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
