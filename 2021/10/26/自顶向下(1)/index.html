<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>计算机网络 自顶向下方法(应用层) | iStitches</title><meta name="keywords" content="读书笔记"><meta name="author" content="XjX-zc"><meta name="copyright" content="XjX-zc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="WireShark 抓包指南：   https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;82498482  协议分层协议规定了发送者、接收者和所有中间设备为了高效通信需要遵守的规则。 协议分层允许我们将一个复杂的任务分解成几个较小的、简单的任务。 协议分层的好处：  第一，它允许我们将服务从实现中分离出来。一层需要能够接收较低一层的一系列服务，同时向较高层提供服务，而我们不需要关心这一层">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络 自顶向下方法(应用层)">
<meta property="og:url" content="http://example.com/2021/10/26/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B(1)/index.html">
<meta property="og:site_name" content="iStitches">
<meta property="og:description" content="WireShark 抓包指南：   https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;82498482  协议分层协议规定了发送者、接收者和所有中间设备为了高效通信需要遵守的规则。 协议分层允许我们将一个复杂的任务分解成几个较小的、简单的任务。 协议分层的好处：  第一，它允许我们将服务从实现中分离出来。一层需要能够接收较低一层的一系列服务，同时向较高层提供服务，而我们不需要关心这一层">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/loserii/blogimg/blob/master/img/202204021422918.jpg">
<meta property="article:published_time" content="2021-10-26T08:47:02.000Z">
<meta property="article:modified_time" content="2022-04-06T01:39:58.550Z">
<meta property="article:author" content="XjX-zc">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/loserii/blogimg/blob/master/img/202204021422918.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/10/26/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B(1)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络 自顶向下方法(应用层)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-06 09:39:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/mybkcss.css"><link rel="stylesheet" href="/css/myfootercss.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_3294417_y9wnoregopg.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/myfont.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="iStitches" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/loserii/blogimg/blob/master/img/202204021422918.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">iStitches</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络 自顶向下方法(应用层)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-26T08:47:02.000Z" title="发表于 2021-10-26 16:47:02">2021-10-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-06T01:39:58.550Z" title="更新于 2022-04-06 09:39:58">2022-04-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/">计算机网络 自顶向下方法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络 自顶向下方法(应用层)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p> WireShark 抓包指南：   <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82498482">https://zhuanlan.zhihu.com/p/82498482</a></p>
</blockquote>
<h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>协议规定了发送者、接收者和所有中间设备为了高效通信需要遵守的规则。</p>
<p>协议分层允许我们将一个复杂的任务分解成几个较小的、简单的任务。</p>
<p><strong>协议分层的好处：</strong></p>
<ul>
<li>第一，它允许我们将服务从实现中分离出来。一层需要能够接收较低一层的一系列服务，同时向较高层提供服务，而我们不需要关心这一层是如何实现的。</li>
<li>第二，在通信过程中中间系统只需要一些层次而不是所有的层次，如果不使用协议分层，形成的中间系统就不得不像端系统一样复杂，这样会提高整个系统的造价。</li>
</ul>
<span id="more"></span>

<h2 id="TCP-x2F-IP-各层描述"><a href="#TCP-x2F-IP-各层描述" class="headerlink" title="TCP&#x2F;IP 各层描述"></a>TCP&#x2F;IP 各层描述</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层通信处于两个进程之间，是端到端的一种通信方式。常见的涉及到的协议包括： 超文本传输协议(HTTP，是访问万维网的载体)；简单邮件传输协议(SMTP，是电子邮件服务的主要协议)；文件传输协议(FTP)；远程登陆(TELNET)；安全外壳(SSH，用于访问远端的站点)；简单的网络管理协议(SNMP)；域名系统(DNS)；因特网组管理协议(IGMP，用于管理一个组的成员资格)；</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层也是端到端的，主要负责从运行于应用层的程序得到信息，并将它投递到目的主机相应的应用程序。常见的协议包括：传输控制协议(TCP) 是面向连接的，提供流量控制(匹配源主机的发送速率与目的主机的接收速率，以防止目的主机溢出)、差错控制(保证数据段无差错到达目的地和重新发送受损的数据段)、拥塞控制(减少由于网络拥塞造成的数据段丢失)；用户数据报协议(UDP)，无连接但是是比较简单的协议，不提供流量控制、差错控制或者拥塞控制；流控制传输协议(SCTP)，结合了TCP与UDP的优点。</p>
<p>UDP协议：</p>
<ul>
<li>UDP提供了无连接的、不可靠的数据包服务。无连接意味着两个交换报文的终端之间没有逻辑连接。每个报文都是独立的实体，它被封装在一个称为数据报的分组中。</li>
<li>UDP常用在邮件发送、视频通信、多媒体应用等场景。</li>
</ul>
<p>TCP协议：</p>
<ul>
<li>TCP提供面向连接的可靠字节流传输，TCP要求两个终端首先通过交换一些连接建立分组来建立一个逻辑连接，这个阶段设置了两个终端的某些参数，包括分组大小、用于保存数据直到整个报文全部到达缓冲区的大小等等。</li>
</ul>
<p>SCTP协议：</p>
<ul>
<li>SCTP协议提供了两个协议组合的功能。类似于TCP，SCTP提供了面向连接的可靠服务，但是它不是面向字节流，它是像UDP一样面向报文的。除此之外，SCTP可以通过多媒体网络层连接提供多媒体流服务。</li>
<li>SCTP协议通常适用于那些不但需要可靠性，而且即使网络层连接发生错误也需保持连接不断开的应用。</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层也是端到端的，主要负责指挥分组选择合适的路由器并通过。这一层不能取消，因为路由器不需要应用层和传输层，分割任务允许我们在路由器上加载较少的协议。常见的协议包括：因特网协议(IP)，IP负责从源主机把一个分组路由到目的主机，IP是一个无连接的协议，不提供流量控制、差错控制和拥塞控制服务。网络层也包括单播(一对一) 和多播 (一对多)路由协议，虽然这些协议不参与路由，但是它为路由器创建转发路由表，为转发处理提供帮助。</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层是基于点到点的传输。它负责选择从主机到目的地之间最好的一条线路进行数据传输。这条链路可以是一个具有链路层交换机的有线局域网、一个无线局域网、一个有线广域网或者一个无线广域网。</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>物理层位于最底层，传输帧中单独的比特。</p>
<h3 id="封装与解封装"><a href="#封装与解封装" class="headerlink" title="封装与解封装"></a>封装与解封装</h3><p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010104358387.png" alt="image-20211010104358387"></p>
<p>源主机的封装：</p>
<ul>
<li>应用层的消息不包含任何头部和尾部，消息直接传输到传输层；</li>
<li>传输层把这个消息作为有效载荷，在次基础上添加上传输层头部，比如负责进行流量控制、差错控制和拥塞控制所需要的信息。该分组在TCP中称为段，在UDP中称为用户数据报，然后传递分组到网络层；</li>
<li>网络层把分组作为有效载荷，并且在此基础上添加自己的头部，头部包含了源主机和目的主机的地址，以及用于头部检查、分片等其他信息。</li>
<li>数据链路层把网络分组作为有效载荷，并在此基础上添加上了自己的头部。该头部包含主机或者下一跳步的链路层地址，结果为一个称为帧的链路层分组。</li>
</ul>
<p>路由器的解封装与封装：</p>
<ul>
<li>路由器会解封装来自源主机的帧，获取齐总的数据报将他投递到网络层。</li>
<li>网络层检查数据报头部的源地址和目的地址，查阅它的转发表以寻找该数据报将被投递到的下一跳步，除非数据报太大以至于不能通过下一链路时需要对其进行分片，数据报的内容不应该被网络层改变，然后数据报被传递到下一链路的数据链路层；</li>
<li>下一链路的数据链路层将数据报封装成一个帧，将其传递到物理层进行传输。</li>
</ul>
<h2 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h2><blockquote>
<p> 客户端进程是怎么和服务器进程通信的？</p>
</blockquote>
<h3 id="应用程序接口"><a href="#应用程序接口" class="headerlink" title="应用程序接口"></a>应用程序接口</h3><p>计算机语言有一个数学操作指令集、一个字符串处理指令集、一个输入&#x2F;输出访问指令集。如果我们想要一个进程与另一个进程通信，那么我们就需要一个新的指令集告知 TCP&#x2F;IP 协议族的低四层打开连接，发送数据，从另一个终端接收数据以及关闭连接，这样的指令集通常称为<strong>应用程序接口</strong>。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010111808985.png" alt="image-20211010111808985"></p>
<p>其中很常见的三个接口：套接字接口、传输层接口、STREAM。最常见的是套接字接口，套接字接口是提供应用层和操作系统间通信的指令集，是一个可以被某进程用来与另一个进程进行通信的指令集。</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>就应用层而言，客户进程和服务器进程间的通信是两个套接字间的通信，如果我们创建两个套接字，一端创建一个，并正确定义源端和目的端地址，那么我们就可以使用指令去发送和接收数据了，其余就是操作系统以及嵌入的 TCP&#x2F;IP 协议的工作了。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010112041132.png" alt="image-20211010112041132"></p>
<p>套接字的地址是由 32位的IP地址 + 16位的端口号组成。</p>
<h4 id="套接字地址"><a href="#套接字地址" class="headerlink" title="套接字地址"></a>套接字地址</h4><p>服务器站点：</p>
<ul>
<li>本地套接字地址，操作系统知道运行着服务器进程的计算机的IP地址。然而服务器进程的端口号需要被分配，如果这个服务器进程是因特网管理结构定义的标准进程，那么端口号就已经分配好了，比如超文本传输控制协议(80端口)；非标准进程会由设计者在规定范围内选择一个端口号。</li>
<li>远程套接字地址，对服务器来说，远程套接字地址是建立连接的客户套接字地址。会随着连接变动而发生改变；</li>
</ul>
<p>客户端站点：</p>
<ul>
<li>本地套接字地址，本地套接字地址由操作系统提供，操作系统知道本机IP地址，端口号是每次客户进程开始通信时分配给客户进程的一个临时16位整数。</li>
<li>远程套接字地址，当一个客户进程开启时，它会知道自己想要连接的服务器地址。</li>
</ul>
<h3 id="超文本传输协议（HTTP）"><a href="#超文本传输协议（HTTP）" class="headerlink" title="超文本传输协议（HTTP）"></a>超文本传输协议（HTTP）</h3><blockquote>
<p> 超文本传输协议是一种用来定义客户服务器程序如何编写和使用从万维网获取网页的协议。在HTTP1.1 版本之前是一种非持续链接，HTTP1.1 版本之后默认使用持续链接，持续连接避免了非持续链接带来的高额开销问题，每个站点只需要为连接设定一组缓冲区和变量，同时节省了连接建立和终止的往返时间。</p>
</blockquote>
<p><strong>HTTP 与 TCP&#x2F;IP 的区别？</strong></p>
<p>TCP&#x2F;IP 协议是传输层协议，主要用来解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据，WEB使用 HTTP协议作为应用层协议，以封装HTTP文本信息，然后使用 TCP&#x2F;IP 做传输层协议将它发到网络上。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211019155139824.png" alt="image-20211019155139824"></p>
<p><strong>请求报文和响应报文的组成格式：</strong></p>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010170910090.png" alt="image-20211010170910090"></p>
<p><strong>请求报文：</strong></p>
<ul>
<li>请求行：包括请求方法(GET、HEAD、PUT、POST、TRACE、CONNECT、DELETE、OPTIONS)；请求URL；协议版本；</li>
</ul>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010171232619.png" alt="image-20211010171232619"></p>
<ul>
<li>请求头：从客户端向服务器发送的额外信息，比如 <code>User-agent</code>、<code>Accept</code>、<code>Authorization</code>、<code>Cookie</code>；</li>
</ul>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010171244120.png" alt="image-20211010171244120"></p>
<ul>
<li>请求空行；</li>
<li>请求体：请求的具体内容。</li>
</ul>
<p>响应报文：</p>
<ul>
<li>状态行：包括协议版本、状态码、短语。100范围内的状态码只代表一个报告、200范围内代码表示这是一个成功的请求、300范围内代码表示把客户端重定向到另一个URL、400范围内代码表示在客户端发生错误、500范围内代码表示错误发生在服务器端。</li>
<li>响应头：服务器端的一些需要返回给客户端的信息。</li>
</ul>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010171532514.png" alt="image-20211010171532514"></p>
<p>HTTP 支持代理服务器，代理服务器是一台计算机，能够保存最近请求的响应的副本。代理服务器降低了原服务器的负载，减少了通信量并降低了延迟。</p>
<p>代理服务器通常使用在：1) 客户计算机作为小容量代理服务器，存储着与客户经常调用的请求的响应；2)   公司内部的代理服务器安装在计算机LAN中来减少进出LAN的负载； 3) 带有很多客户的ISP可以安装一台代理服务器来减少进出ISP网络的负载。</p>
<p>HTTP本质上并不安全，但是可以在安全套接层(SSL) 上运行，在这种情况下 HTTP称为 HTTPS，HTTPS提供保密性、客户和服务器鉴别，以及数据完整性。</p>
<h3 id="安全应用层协议-HTTPS"><a href="#安全应用层协议-HTTPS" class="headerlink" title="安全应用层协议 HTTPS"></a>安全应用层协议 HTTPS</h3><p>HTTPS 在 HTTP 基础上加入了 SSL协议，SSL协议依靠证书来验证服务器的身份，并为服务器和浏览器之间的通信加密。加密过程如下：</p>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211019155538005.png" alt="image-20211019155538005"></p>
<ol>
<li>客户端发起 HTTPS 请求；</li>
<li>HTTPS协议的服务端拥有一套数字证书，可以是自己制作或者CA证书。区别在于CA证书能够直接使用，而自己制作的证书需要客户端验证通过才可以继续访问。总的来说该证书实际上看作一对公钥和私钥，公钥给别人加密使用，私钥给自己解密使用；</li>
<li>服务端传送证书给客户端；</li>
<li>客户端解析证书，比如证书的颁发机构、过期时间等，如果发现异常会进行提示。如果通过检查，就生成一个随机值，并利用证书对该随机值进行加密；</li>
<li>客户端传送加密后的随机值，目的在于让服务端接收该随机值并在之后的通信过程中利用该随机值进行加密解密；</li>
<li>服务端利用证书对加密后的随机值进行解密，得到客户端传送过来的随机值(该值作为之后传输过程中的私钥使用)。然后利用随机值对发送内容进行对称加密，正好客户端和服务端都知道这个私钥(客户端传输的随机值)，所以只有两者能够对消息进行解密；</li>
<li>传输加密后的信息；</li>
<li>客户端利用生成的私钥对信息进行解密，获得解密后的内容。</li>
</ol>
<p>整个过程中即使信息泄露，外部也会因为不知道私钥而无法解密信息，所以是安全的。</p>
<p><strong>HTTP 和 HTTPS 的区别：</strong></p>
<ol>
<li>https 协议需要到 ca 申请证书或者自制证书；</li>
<li>http 信息是明文传输，https 信息则是具有安全性的 ssl 加密；</li>
<li>http 直接与 tcp 进行数据传输，而 https 还需要经过一层 SSL，用的端口也不一样，前者是80端口，后者是443端口；</li>
<li>http 的连接很简单，是无状态的；https 协议是由 SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比 HTTP协议安全；</li>
</ol>
<p><strong>HTTPS 协议的数据加密是在传输层进行，无论是 HTTPS 的header域还是 body域都会被加密处理。</strong></p>
<h3 id="文件传输协议（FTP）"><a href="#文件传输协议（FTP）" class="headerlink" title="文件传输协议（FTP）"></a>文件传输协议（FTP）</h3><p>文件传输协议FTP 是TCP&#x2F;IP  提供的标准机制，用于将文件从一个主机复制到另一个主机。FTP结构上由客户端和服务器端组成，客户端包括用户接口、控制进程、数据传输进程三个组件；服务器端包括控制进程、数据传输进程组成。</p>
<p>FTP中两种连接有不同的寿命，在整个FTP会话期间，控制连接始终处于连接状态。数据连接则在每次完成传输文件时开启然后关闭。数据连接通过20端口进行操作，控制连接通过21端口。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010172358300.png" alt="image-20211010172358300"></p>
<h4 id="控制连接"><a href="#控制连接" class="headerlink" title="控制连接"></a>控制连接</h4><p>对于控制通信，FTP使用与TELNET相同的方法。它与TELNET一样使用NVT ASCII 字符集。在控制连接期间，命令从客户端发送到服务器并且响应从服务器发送到客户端。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010172920386.png" alt="image-20211010172920386"></p>
<p>每个FTP命令至少产生一个响应，一个响应由两部分组成：文本 + 一个三位数字，数字部分定义了编码。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010173026071.png" alt="image-20211010173026071"></p>
<h4 id="数据连接"><a href="#数据连接" class="headerlink" title="数据连接"></a>数据连接</h4><p>数据连接使用 20端口，数据连接的创建步骤如下：</p>
<ol>
<li>客户使用临时端口发起一个被动打开，必须由客户完成，因为是客户发出命令要求传输文件的；</li>
<li>客户使用 PORT 命令发送这个端口号到服务器；</li>
<li>服务器接收到端口号，使用熟知端口20发出主动打开并且接收临时端口号。</li>
</ol>
<p>数据连接建立后不能立刻通信，还需要定义传输文件的类型、数据结构、传输模式，因此通过建立控制连接来完成：</p>
<ol>
<li>规定传输数据的数据结构：FTP可以使用下列数据结构中的一种在数据连接上传送文件：文件结构、记录结构、页面结构。其中文件结构是默认使用，它是连续的字节流；记录结构把文件划分成了一个个记录，只能用于文本文件；页面结构把文件划分成页面，每一个页面有一个页面号和一个页面头部，页面可以随机地或者顺序地存储或访问。</li>
<li>规定传输数据地文件类型：FTP可以在数据连接上传输下列文件的一种：ASCII文件、EBCDIC文件、图像文件；</li>
<li>规定传输数据的传输方式：三种方式，流方式、块方式、压缩方式。块方式中在文件前加上了一个3字节的文件头，其中第一个字节称为块描述，后面两个字节定义块大小。</li>
</ol>
<p>完成控制连接后就可以开始进行数据传输了。</p>
<h3 id="简单电子邮件传输协议（SMTP）"><a href="#简单电子邮件传输协议（SMTP）" class="headerlink" title="简单电子邮件传输协议（SMTP）"></a>简单电子邮件传输协议（SMTP）</h3><h4 id="电子邮件传输模式架构"><a href="#电子邮件传输模式架构" class="headerlink" title="电子邮件传输模式架构"></a>电子邮件传输模式架构</h4><p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211010174056115.png" alt="image-20211010174056115"></p>
<p>邮件传输通过代理服务器完成，包括三种不同的代理，用户代理(UA)、报文传输代理(MTA)、报文访问代理(MAA)。</p>
<h4 id="报文传输代理-SMTP"><a href="#报文传输代理-SMTP" class="headerlink" title="报文传输代理 SMTP"></a>报文传输代理 SMTP</h4><p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015091054800.png" alt="image-20211015091054800"></p>
<p>报文首先从客户经过MTA报文传输代理发送到客户端的邮件服务器，然后再从客户端邮件服务器经过MTA报文传输代理发送到服务端邮件服务器，服务端邮件服务器再通过MAA报文访问代理发送给具体的用户。</p>
<p>MTA客户机和服务器常用的协议称为**简单邮件传输协议(SMTP)**，SMTP只定义了如何来回发送命令和响应，因此在邮件服务器和接收器之间还需要另一个协议。</p>
<p>SMTP协议涉及到的邮件传输阶段分为三个：连接建立、邮件传输、连接终止。</p>
<p>SMTP协议是一个推协议，他将报文从客户推入服务器，但是第三阶段需要一个拉协议，客户机必须从服务器拉出报文，大量数据的方向是从服务器到客户，因此第三阶段使用报文访问代理协议。目前的MAA协议主要有邮局协议版本3（POP3）、因特网邮件访问协议版本4（IMAP4）。</p>
<h4 id="基于Web的邮件"><a href="#基于Web的邮件" class="headerlink" title="基于Web的邮件"></a>基于Web的邮件</h4><p>以上是传统邮件传输服务的架构组织，现在出现了另一种架构模式。报文从发送邮件服务器到接收邮件服务器的传输仍然是通过SMTP来完成的，但是从接收服务器到浏览器是通过HTTP来完成的。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015092820624.png" alt="image-20211015092820624"></p>
<h3 id="远程登陆-TELNET、SSH"><a href="#远程登陆-TELNET、SSH" class="headerlink" title="远程登陆 TELNET、SSH"></a>远程登陆 TELNET、SSH</h3><h4 id="TELNET"><a href="#TELNET" class="headerlink" title="TELNET"></a>TELNET</h4><p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015101718786.png" alt="image-20211015101718786"></p>
<p>远程登陆协议之一是<code>TELNET</code>。在输入命令进行远程登陆时，用户将击键发送给终端驱动程序，同时本地操作系统接收这些字符，但并不解释它们。这些字符被发送到TELNET客户机，它将这些字符转换为网络虚拟终端（Network Virtual Terminal，NVT）字符的通用字符集，然后将其传送给本地 TCP&#x2F;IP 协议栈。</p>
<p>采用网络虚拟终端NVT 形式的命令或文本通过因特网传送到远程的TCP&#x2F;IP 协议栈，在那里传递给操作系统，操作系统再移交给TELNET服务器，TELNET服务器将这些字符转换为远程计算机可以理解的字符。但是这些字符不能直接传递给操作系统，因为操作系统不能处理来自TELNET服务器的字符，它只能接收来自终端驱动程序的字符。所以还需要在远程端增加一个伪终端驱动程序的软件块。</p>
<h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015102535907.png" alt="image-20211015102535907"></p>
<p>TELNET虽然能够进行远程登陆和消息传递，但是并不安全。更加安全的协议是SSH（Secure Shell），它是一个可以用于远程登陆和文件传输的多用途安全应用协议，SSH是一个有三个组件的应用层协议。</p>
<p>三个组件包括：SSH-TRANS（SSH应用层协议）、SSH-AUTH（SSH认证协议）、SSH-CONN（SSH连接协议）。</p>
<p><strong>SSH-TRANS：</strong>是一个独立协议，当执行这个协议的程序被调用时，客户和服务器首先通过TCP建立一个不安全的连接，然后交换它们的几个参数在TCP顶部建立安全信道。</p>
<p><strong>SSH-AUTH：</strong>在客户与服务器之间的安全信道建立以及客户端认证服务器之后，SSH可以调用另外一个流程，它为服务器对客户进行认证。</p>
<p><strong>SSH-CONN：</strong>在安全信道建立和服务器相互认证之后，SSH可以调用一个执行第三个协议的软件，那就是SSH-CONN。SSH-CONN 协议提供的一个服务是复用。SSH-CONN 采用前两层协议创建安全信道并允许客户在其上创建多个逻辑信道，每个逻辑信道可以用于不同目的，比如文件传输、远程登陆等。</p>
<p><strong>端口转发：</strong>SSH提供一个特殊的服务端口转发，我们可以使用SSH中可用的安全信道来访问一个不提供安全服务的应用程序。比如TELNET和简单邮件传输协议(SMTP) 这类应用。SSH端口转发机制创建了一个隧道，属于其它协议的报文可以穿过这个隧道。</p>
<h3 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h3><p>举个栗子：网络上常见的文件传输，就用到了DNS域名解析功能。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015104304714.png" alt="image-20211015104304714"></p>
<h4 id="域名系统结构"><a href="#域名系统结构" class="headerlink" title="域名系统结构"></a>域名系统结构</h4><p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015104422412.png" alt="image-20211015104422412">y</p>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015105210722.png" alt="image-20211015105210722"></p>
<p>域名空间的结构是一棵多叉树，这棵树总共有128级，0级（根结点）至127级。</p>
<p><strong>标签：</strong>树上面的每一个结点都有一个标签，标签是一个最多63个字符的字符串，根节点符号是空串，DNS要求每一个结点的子结点有不同的标签，这样保证了域名的唯一性。</p>
<p><strong>域名：</strong>树上的每一个节点都有一个域名，域名是通过 . 分隔开的标签序列。</p>
<p><strong>域：</strong>域是域命名空间的子树，域的名称是子树顶端结点的名称。</p>
<p><strong>区域：</strong>树的部分区域，服务器内有一个数据库，称为区域文件，它保存着这个域里所有的结点信息。</p>
<p><strong>根服务器：</strong>根服务器通常不保存关于域的任何信息，只是将其委托给其它服务器，并保持与这些服务器的参照关系。</p>
<p><strong>主服务器和辅助服务器：</strong>主服务器是指存储了授权区域有关文件的服务器。它负责创建、维护、更新区域文件，并将区域文件存储在本地磁盘中。辅助服务器则是负责从另一个服务器传输一个区域的全部信息，并将文件存储在它的本地磁盘中，辅助服务器不负责更新区域文件，如果需要更新只能由主服务器完成，然后再发给辅服务器。</p>
<h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><ul>
<li>递归解析：本地服务器通常不能一次获取到目标域名的IP地址，所以需要经过多个域名服务器的转发来识别。递归解析特点就在于每次转发获取到下一跳DNS服务器的IP地址后就由当前DNS服务器继续向下转发，而不是返还给初始本地DNS服务器来访问。</li>
</ul>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015110310942.png" alt="image-20211015110310942"></p>
<ul>
<li>迭代解析：每次获取到下一跳DNS 域名服务器的IP地址后，返还给初始本地DNS域名服务器进行访问。</li>
</ul>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015110401537.png" alt="image-20211015110401537"></p>
<h4 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h4><p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015110449162.png" alt="image-20211015110449162"></p>
<p>DNS报文分为查询报文和响应报文，两种报文都有相同的格式。</p>
<ul>
<li>标识：用来匹配对查询的响应。</li>
<li>标记：定义了报文是响应报文还是查询报文。</li>
</ul>
<p>DNS可以只使用UDP或者TCP报文，在这两种情况下使用的是53端口，当响应报文的长度小于512字节就需要使用UDP，如果报文长度大于512字节就需要使用TCP。</p>
<h3 id="对等模式-（P2P）"><a href="#对等模式-（P2P）" class="headerlink" title="对等模式 （P2P）"></a>对等模式 （P2P）</h3><p>客户服务器模式，总体上分为两类：集中式和分散式。</p>
<ul>
<li><p>集中式网络：在集中式P2P网络中，目录系统列出了对等节点以及它们提供的内容。一个寻找特定文件的对等结点向中心服务器发送一个查询，服务器搜索其目录，将含有所需文件副本的多个结点的IP地址作为响应返回对等结点。对等结点与其中一个结点连接并下载文件，当有结点加入或者离开时，目录立即进行更新。</p>
<p>集中式网络缺点在于当流量巨大时会导致系统速度降低。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211015115102234.png" alt="image-20211015115102234"></p>
</li>
<li><p>分散式网络：分散式网络并不依赖于中心化目录系统。而是依照覆盖网的结构进行设计。包括两种网络：结构化网络、非结构化网络。</p>
<p>非结构化网络的效率比较低，因为结点随机连接，结点的搜索效率不高，因为对一个文件的查询必须通过网络进行泛洪，这将造成极大的通信量。</p>
<p>结构化网络采用一组预先确定的规则来连接结点，有效并高效地解决查询，最常用的技术是分布式散列表（Distributed Hash Table）。</p>
</li>
</ul>
<h4 id="分布式散列表-Distributed-Hash-Table，-DHT"><a href="#分布式散列表-Distributed-Hash-Table，-DHT" class="headerlink" title="分布式散列表 (Distributed Hash Table， DHT)"></a>分布式散列表 (Distributed Hash Table， DHT)</h4><blockquote>
<p>分布式散列表根据预先定义的规则将数据分发到一组结点上。对于基于DHT的网络，每一个对等节点负责一系列数据项。为了避免我们在非结构化P2P网络中讨论的洪泛开销，基于DHT的网络允许每个对等结点对整个网络做部分了解。</p>
<p>DHT的主要功能是将一个查询路由到负责存储这个对象引用的结点上，每个结点必须对整个环有部分了解，从而将查询路由到与负责结点最接近的一个结点上。</p>
<p>通俗来说就是将网络中的计算机结点哈希映射到圆形哈希表上的不同位置，同时将这些主机上的文件也经过哈希映射到哈希表上。文件对象保存在相应的计算节点上，但是文件对象的引用存储在另一个结点上(该结点的ID最接近关键字)。</p>
</blockquote>
<p>在基于DHT的网络中，每个数据项被映射到了大小为 2^m 的地址上，绝大多数DHT使用的 m&#x3D;160。</p>
<p><strong>散列对等结点标识符</strong>：创建DHT的第一步是将所有对等结点放入地址空间环中，通过散列函数：<code>结点ID = hash(对等结点IP地址)</code> 来计算。</p>
<p><strong>散列对象标识符</strong>：被共享的文件的名称的散列结果称为关键字，通过函数 <code>关键字 = hash(对象名)</code> 来计算，在DHT中一个对象通常和一组 (key，value) 相关，其中 key 是对象名的散列值，value是对象或者对象的引用。</p>
<p>绝大多数DHT系统使用间接方法，即拥有对象的对等结点保存对象，但是对象的引用被创建并存储在另一个结点上，这个结点的ID最接近关键字。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211018131504178.png" alt="image-20211018131504178"></p>
<h4 id="DHT算法-——-chord"><a href="#DHT算法-——-chord" class="headerlink" title="DHT算法 —— chord"></a>DHT算法 —— chord</h4><ul>
<li>算法要素：</li>
</ul>
<ol>
<li><p>标识符空间：对等结点和数据项(比如一个需要共享的文件)同时按照顺时针分布在一个环上，我们将数据项的标识符称为k（即key，关键字），对等节点的标识符为 N(即node，结点)。最接近 N ≥ k 的对等结点称作关键字 k 的后向结点并且拥有数值 (k，v)，其中 k是关键字(数据项的散列值)，v是拥有对象的对等结点服务器的信息。 也就是说文件这类数据存储在拥有数据项的对等结点上，但是数据项的散列值key以及对等结点的信息value被作为一对(k，v) 存储在 k 的后向结点上。</p>
</li>
<li><p>指针表：为了找到目标关键字所在的对等结点，需要通过结点间的转发来不断查找，因此设计了指针表。 Chord 要求每一个结点维护 m 的后向结点以及一个前向结点的信息，每个结点创建一个称为指针表的路由表。Chord 环中每个结点的第一个指针给出了后向结点的ID。</p>
<p>通过指针表每个结点就能认识到哈希表中其它结点的信息。</p>
</li>
</ol>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211018132607924.png" alt="image-20211018132607924"></p>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211018132804577.png" alt="image-20211018132804577"></p>
<ul>
<li>算法关键方法 —— 查找</li>
</ul>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211018132723392.png" alt="image-20211018132723392"></p>
<p><code>lookup(key)</code> 函数调用 <code>find_successor(id)</code> 函数来找到这个ID的后向结点，在查找后向结点时可以通过前向结点来迭代查找，因为前向结点的第一个指针（<code>finger[1]</code>）给出了后向结点的ID。</p>
<p>一个结点需要其它结点的帮助来找到关键字 key 的前向结点，这一步可以将 <code>find_closest_predecessor(id)</code>函数作为远程程序调用<code>RPC</code>来完成。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211026140716013.png" alt="image-20211026140716013"></p>
<h4 id="DHT算法-——-Pastry"><a href="#DHT算法-——-Pastry" class="headerlink" title="DHT算法 —— Pastry"></a>DHT算法 —— Pastry</h4><p>待续。。。。。</p>
<h4 id="DHT算法-——-Kademlia"><a href="#DHT算法-——-Kademlia" class="headerlink" title="DHT算法 —— Kademlia"></a>DHT算法 —— Kademlia</h4><p>待续。。。。</p>
<h3 id="套接字Socket"><a href="#套接字Socket" class="headerlink" title="套接字Socket"></a>套接字Socket</h3><h5 id="套接字的数据结构"><a href="#套接字的数据结构" class="headerlink" title="套接字的数据结构"></a>套接字的数据结构</h5><p>套接字并没有存储待发送或者待接收数据的缓冲区，它既不能发送也不能接收数据，套接字只是起到一个引用或标签的作用。缓冲区和必要的变量在操作系统中创建。</p>
<ul>
<li>族：定义了协议簇。通常是 <code>PF_INET</code>、<code>PF_INET6（下一代因特网）</code>。</li>
<li>类型：套接字的四种类型。<code>SOCK_STREAM(用于TCP)</code>、<code>SOCK_DGRAM(用于UDP)</code>、<code>SOCK_SEQPACKET(用于SCTP)</code>、<code>SOCK_RAW(用于直接使用ISP服务的应用)</code>。</li>
<li>协议：定义了族中特定协议。对于 TCP&#x2F;IP 协议族字段设置为0。</li>
<li>本地套接字地址。套接字地址由 长度字段、族字段、端口号字段、IP地址字段构成。</li>
<li>远程套接字地址。</li>
</ul>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211026143525933.png" alt="image-20211026143525933"></p>
<h5 id="UDP通信过程"><a href="#UDP通信过程" class="headerlink" title="UDP通信过程"></a>UDP通信过程</h5><p>UDP通信中客户和服务器每一端只使用一个套接字，服务器创建的套接字永远运行，而且服务器只创建一个套接字。客户端的套接字在每次通信结束时被销毁关闭。</p>
<ul>
<li>服务器进程：服务器进程被动开启。首先通过<code>socket()</code> 函数创建套接字，在这个程序调用中填充了套接字的前三个字段，但是本地和远程套接字地址字段仍然未定义。之后服务器进程调用<code>bind()</code> 函数来填充本地套接字地址字段（信息来自操作系统）。然后调用 <code>recvfrom()</code>函数阻塞服务器进程直到一个客户数据报到达。当下一个数据报到达时，服务器进程接触阻塞并且从数据报中抽取出发送套接字地址，填充到套接字的远程套接字地址字段。这样完成了全部套接字字段的填充，通过<code>sento()</code>函数来完成数据的发送。</li>
<li>客户端进程：客户进程主动开启。首先通过<code>socket()</code>函数创建一个套接字并填充到前三个字段，它不需要通过<code>bind()</code>函数来填充本地套接字地址，这个操作由操作系统自动完成，它会选择一个临时端口号。之后进程调用<code>sendto()</code>函数，并提供远程套接字地址信息，这个套接字地址必须由客户进程的用户提供。套接字完成填充就进行数据发送，接着调用<code>recvfrom()</code>函数，阻塞了客户进程直到响应来自服务器进程。此外没有必要从这个函数中提取远程套接字地址，因为此处不需要调用<code>sendto()</code>函数。</li>
<li>总结：服务端和客户端的<code>recvfrom()</code>函数行为不同，在服务器进程中，<code>recvfrom()</code>函数首先被调用获取远程套接字地址然后调用<code>sendto()</code>发送数据。在客户端进程中，<code>sendto()</code>函数先调用发送数据，此时远程套接字地址由程序使用者提供。</li>
</ul>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211026143823590.png" alt="image-20211026143823590"></p>
<h5 id="TCP通信过程"><a href="#TCP通信过程" class="headerlink" title="TCP通信过程"></a>TCP通信过程</h5><p>TCP是面向连接的协议，所以需要先建立连接再发送或者接收数据。TCP服务端使用两个不同的套接字，一个用于建立连接，一个用于数据传输。设置两个套接字的目的是为了将建立阶段和数据传输阶段分隔开。客户端只使用一个套接字用于连接建立和数据交换。</p>
<ul>
<li><p>服务器进程：首先调用<code>socket()</code>和<code>bind()</code>函数创建监听套接字，它只在建立连接阶段使用。之后服务器调用<code>listen()</code>函数允许客户端开始接收客户，<strong>完成客户连接</strong>并将它们放入到等待被服务的列表。接着服务器进程开始循环并且逐一对客户进行服务，每次循环过程中调用<code>accept()</code>函数从已连接客户的等待列表中去除一个客户，对其进行服务。当<code>accept()</code>函数返回时，它会创建一个新的套接字用来进行数据传输，监听套接字此时就移入到后台，并且新的套接字称为活动套接字。服务器进程此时使用连接建立阶段获取的客户端套接字地址作为远程套接字地址。</p>
<p>TCP服务器使用 <code>send()</code>以及<code>recv()</code>函数在两者之间进行数据传递。这两个函数比UDP中的<code>sendto()</code>、<code>recvfrom()</code>更简单，它不需要提供远程套接字地址，因为连接已经在两者之间建立起来了。同时由于TCP多用于传输无边界报文，所以<code>send()</code>、<code>recv()</code>函数可能被调用用来多次处理大量数据传输。</p>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="/passageImg/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95.assets/image-20211026163336899.png" alt="image-20211026163336899"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">XjX-zc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/10/26/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B(1)/">http://example.com/2021/10/26/自顶向下(1)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">iStitches</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/loserii/blogimg/blob/master/img/202204021422918.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/31/hello-world/"><img class="prev-cover" src="/img/loading.gif" data-original="https://upimage.alexhchu.com/2020/10/21/f5ac68ddaaf64.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hello World</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"><img class="next-cover" src="/img/loading.gif" data-original="/img/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深入理解Java虚拟机—垃圾收集器与内存分配策略</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" title="深入理解Java虚拟机—Java内存区域"><img class="cover" src="/img/loading.gif" data-original="/img/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-11</div><div class="title">深入理解Java虚拟机—Java内存区域</div></div></a></div><div><a href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" title="深入理解Java虚拟机—垃圾收集器与内存分配策略"><img class="cover" src="/img/loading.gif" data-original="/img/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-11</div><div class="title">深入理解Java虚拟机—垃圾收集器与内存分配策略</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">XjX-zc</div><div class="author-info__description">生活原本沉闷,但跑起来就会有风</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/iStitches"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="iconfont icon-social-rss card_icon"></i></a><a class="social-icon" href="https://github.com/iStitches" target="_blank" title="Github"><i class="iconfont icon-icon-Github card_icon"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_43684985?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><i class="iconfont icon-icon-csdn card_icon"></i></a><a class="social-icon" href="https://space.bilibili.com/407787894" target="_blank" title="Bilibili"><i class="iconfont icon-icon_bilibili card_icon"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1093453695&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="iconfont icon-icon-QQ card_icon"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">开发菜鸡,欢迎大家光临,一起学习进步！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text">协议分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-x2F-IP-%E5%90%84%E5%B1%82%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">TCP&#x2F;IP 各层描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">2.1.</span> <span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">2.2.</span> <span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">2.3.</span> <span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">2.4.</span> <span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">2.5.</span> <span class="toc-text">物理层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E4%B8%8E%E8%A7%A3%E5%B0%81%E8%A3%85"><span class="toc-number">2.6.</span> <span class="toc-text">封装与解封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82-1"><span class="toc-number">3.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.</span> <span class="toc-text">应用程序接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">3.2.</span> <span class="toc-text">套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80"><span class="toc-number">3.2.1.</span> <span class="toc-text">套接字地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%88HTTP%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">超文本传输协议（HTTP）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE-HTTPS"><span class="toc-number">3.4.</span> <span class="toc-text">安全应用层协议 HTTPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%88FTP%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">文件传输协议（FTP）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.5.1.</span> <span class="toc-text">控制连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.5.2.</span> <span class="toc-text">数据连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%88SMTP%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">简单电子邮件传输协议（SMTP）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84"><span class="toc-number">3.6.1.</span> <span class="toc-text">电子邮件传输模式架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E4%BC%A0%E8%BE%93%E4%BB%A3%E7%90%86-SMTP"><span class="toc-number">3.6.2.</span> <span class="toc-text">报文传输代理 SMTP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EWeb%E7%9A%84%E9%82%AE%E4%BB%B6"><span class="toc-number">3.6.3.</span> <span class="toc-text">基于Web的邮件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86-TELNET%E3%80%81SSH"><span class="toc-number">3.7.</span> <span class="toc-text">远程登陆 TELNET、SSH</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TELNET"><span class="toc-number">3.7.1.</span> <span class="toc-text">TELNET</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSH"><span class="toc-number">3.7.2.</span> <span class="toc-text">SSH</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F-DNS"><span class="toc-number">3.8.</span> <span class="toc-text">域名系统 DNS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">3.8.1.</span> <span class="toc-text">域名系统结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90"><span class="toc-number">3.8.2.</span> <span class="toc-text">域名解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E6%8A%A5%E6%96%87"><span class="toc-number">3.8.3.</span> <span class="toc-text">DNS报文</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%AD%89%E6%A8%A1%E5%BC%8F-%EF%BC%88P2P%EF%BC%89"><span class="toc-number">3.9.</span> <span class="toc-text">对等模式 （P2P）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%A3%E5%88%97%E8%A1%A8-Distributed-Hash-Table%EF%BC%8C-DHT"><span class="toc-number">3.9.1.</span> <span class="toc-text">分布式散列表 (Distributed Hash Table， DHT)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DHT%E7%AE%97%E6%B3%95-%E2%80%94%E2%80%94-chord"><span class="toc-number">3.9.2.</span> <span class="toc-text">DHT算法 —— chord</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DHT%E7%AE%97%E6%B3%95-%E2%80%94%E2%80%94-Pastry"><span class="toc-number">3.9.3.</span> <span class="toc-text">DHT算法 —— Pastry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DHT%E7%AE%97%E6%B3%95-%E2%80%94%E2%80%94-Kademlia"><span class="toc-number">3.9.4.</span> <span class="toc-text">DHT算法 —— Kademlia</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97Socket"><span class="toc-number">3.10.</span> <span class="toc-text">套接字Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.10.0.1.</span> <span class="toc-text">套接字的数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UDP%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">3.10.0.2.</span> <span class="toc-text">UDP通信过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">3.10.0.3.</span> <span class="toc-text">TCP通信过程</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/hello-world/" title="Hello World"><img src="/img/loading.gif" data-original="https://upimage.alexhchu.com/2020/10/21/f5ac68ddaaf64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2022/03/31/hello-world/" title="Hello World">Hello World</a><time datetime="2022-03-31T09:49:07.771Z" title="发表于 2022-03-31 17:49:07">2022-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/26/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B(1)/" title="计算机网络 自顶向下方法(应用层)"><img src="/img/loading.gif" data-original="https://gitee.com/loserii/blogimg/blob/master/img/202204021422918.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络 自顶向下方法(应用层)"/></a><div class="content"><a class="title" href="/2021/10/26/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B(1)/" title="计算机网络 自顶向下方法(应用层)">计算机网络 自顶向下方法(应用层)</a><time datetime="2021-10-26T08:47:02.000Z" title="发表于 2021-10-26 16:47:02">2021-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" title="深入理解Java虚拟机—垃圾收集器与内存分配策略"><img src="/img/loading.gif" data-original="/img/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解Java虚拟机—垃圾收集器与内存分配策略"/></a><div class="content"><a class="title" href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" title="深入理解Java虚拟机—垃圾收集器与内存分配策略">深入理解Java虚拟机—垃圾收集器与内存分配策略</a><time datetime="2021-07-11T14:06:00.000Z" title="发表于 2021-07-11 22:06:00">2021-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" title="深入理解Java虚拟机—Java内存区域"><img src="/img/loading.gif" data-original="/img/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解Java虚拟机—Java内存区域"/></a><div class="content"><a class="title" href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" title="深入理解Java虚拟机—Java内存区域">深入理解Java虚拟机—Java内存区域</a><time datetime="2021-07-11T13:06:00.000Z" title="发表于 2021-07-11 21:06:00">2021-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/10/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E6%8B%93%E5%B1%95/" title="TCP三握四挥知识拓展"><img src="/img/loading.gif" data-original="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TCP三握四挥知识拓展"/></a><div class="content"><a class="title" href="/2021/05/10/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E6%8B%93%E5%B1%95/" title="TCP三握四挥知识拓展">TCP三握四挥知识拓展</a><time datetime="2021-05-10T10:12:00.000Z" title="发表于 2021-05-10 18:12:00">2021-05-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By XjX-zc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>