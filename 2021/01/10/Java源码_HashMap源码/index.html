<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>HashMap源码解读 | iStitches</title><meta name="keywords" content="源码解读"><meta name="author" content="XjX-zc"><meta name="copyright" content="XjX-zc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HashMap一、JDK 1.7 的HashMap1. 数据结构123public class HashMap&lt;K,V&gt;         extends AbstractMap&lt;K,V&gt;          implements Map&lt;K,V&gt;, Cloneable, Serializable   HashMap 继承了 AbstractMap 抽象类，实现了">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap源码解读">
<meta property="og:url" content="http://example.com/2021/01/10/Java%E6%BA%90%E7%A0%81_HashMap%E6%BA%90%E7%A0%81/index.html">
<meta property="og:site_name" content="iStitches">
<meta property="og:description" content="HashMap一、JDK 1.7 的HashMap1. 数据结构123public class HashMap&lt;K,V&gt;         extends AbstractMap&lt;K,V&gt;          implements Map&lt;K,V&gt;, Cloneable, Serializable   HashMap 继承了 AbstractMap 抽象类，实现了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.jpg">
<meta property="article:published_time" content="2021-01-10T10:47:00.000Z">
<meta property="article:modified_time" content="2022-04-02T02:35:59.834Z">
<meta property="article:author" content="XjX-zc">
<meta property="article:tag" content="源码解读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/01/10/Java%E6%BA%90%E7%A0%81_HashMap%E6%BA%90%E7%A0%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HashMap源码解读',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-02 10:35:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/mybkcss.css"><link rel="stylesheet" href="/css/myfootercss.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_3294417_y9wnoregopg.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/myfont.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="iStitches" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">iStitches</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E5%85%B3%E4%BA%8E"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly%E4%B8%BB%E9%A2%98"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HashMap源码解读</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-10T10:47:00.000Z" title="发表于 2021-01-10 18:47:00">2021-01-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T02:35:59.834Z" title="更新于 2022-04-02 10:35:59">2022-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/">JAVA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HashMap源码解读"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="一、JDK-1-7-的HashMap"><a href="#一、JDK-1-7-的HashMap" class="headerlink" title="一、JDK 1.7 的HashMap"></a>一、JDK 1.7 的HashMap</h2><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt;</span><br><span class="line">         <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; </span><br><span class="line">         <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<ul>
<li>HashMap 继承了 AbstractMap 抽象类，实现了 Cloneable、Serializable接口。HashMap的拷贝是一种浅拷贝，即拷贝对象的改变会影响到原对象；HashMap是线程不安全的，不保证插入的键值对有序，但是允许存储键为null的值；HashTable是线程安全的，但是不能存储键为 null的值。</li>
<li>jdk 1.7 中的HashMap 是基于 数组+链表 的模式构建的。虽然 HashMap定义了hash函数来避免冲突，但是还是会存在两个 key在计算后桶的位置一样，因此考虑使用 链表的方式解决冲突；</li>
</ul>
<span id="more"></span>

<ul>
<li>结构： Entry节点(包括键、值、next、hash)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry &#123;</span><br><span class="line">    <span class="comment">/** 键对象*/</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">/** 值对象*/</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">/** 指向下一个Entry对象*/</span></span><br><span class="line">    Entry next;</span><br><span class="line">    <span class="comment">/** 键对象哈希值*/</span></span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<ul>
<li>由于是数组组成，因此 O(1)的平均查找、插入、删除时间；</li>
</ul>
<img src="/img/loading.gif" data-original="/passageImg/Java源码解读.assets/1628a5174a8f1f3a" alt="img" style="zoom: 50%;" />

<table>
<thead>
<tr>
<th>结构</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>数组（主）</td>
<td>（1）底层的核心是数组(table[]) ，数组中存储的是结点Entry。                                                                             （2）数组的下标是经过处理的键Key的hash值。                                                                                                                                  （3）数组元素 &#x3D; 1个Entry结点 &#x3D; hash值+key+value+next指针 &#x3D; 1个链表头结点                                                            （4）数组大小 &#x3D; HashMap的容量</td>
<td></td>
</tr>
<tr>
<td>单链表（辅）</td>
<td>（1）每个链表 &#x3D; 哈希表的桶（bucket）                                                                                                                                  （2）链表的结点值 &#x3D;  1个键值对                                                                                                                                               （3）链表长度 &#x3D; 桶的大小</td>
<td>链表的主要作用是用来解决Hash冲突的。发生冲突时，新元素插入到链表头中；新元素总是添加到数组中，旧元素移动到单链表中。</td>
</tr>
<tr>
<td></td>
<td>HashMap的键值对数量 &#x3D; 数组中的键值对数量 + 链表中的键值对数量</td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-重要参数"><a href="#2-重要参数" class="headerlink" title="2. 重要参数"></a>2. 重要参数</h3><p>重要参数包括三个： 容量、负载因子、扩容阈值</p>
<h5 id="容量："><a href="#容量：" class="headerlink" title="容量："></a>容量：</h5><p>容量（Capicity）是指 HashMap中的数组长度；而 Size 指的是HashMap中存储的键值对的数量；</p>
<p>容量的范围必须是 2的整数次幂；最大容量是 2^30；初始容量是 16；</p>
<h5 id="负载因子："><a href="#负载因子：" class="headerlink" title="负载因子："></a>负载因子：</h5><p>负载因子是用来描述 HashMap在扩容前能够存储达到多满的一种程度；</p>
<p>负载因子越大，说明能够填满的元素越多，空间利用率就越高，但是相对应的Hash冲突的概率就会越大；</p>
<p>负载因子越小，说明能填满的元素越少，空间利用率越低，对应Hash越不容易冲突，查找效率更高。</p>
<h5 id="扩容阈值："><a href="#扩容阈值：" class="headerlink" title="扩容阈值："></a>扩容阈值：</h5><p>当容量 &gt; 扩容阈值时需要进行扩容操作。</p>
<p>扩容是将 当前容量扩大为原容量的2倍，从而使哈希表具有2倍的桶数；</p>
<p>扩容阈值 &#x3D; 容量大小 × 负载因子  ，默认为 12</p>
<h3 id="3-构造方法分析"><a href="#3-构造方法分析" class="headerlink" title="3. 构造方法分析"></a>3. 构造方法分析</h3><p>构造方法包括四种，默认构造方法、根据容量进行初始化、根据容量和负载因子进行初始化、根据子Map进行初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定容量及负载因子构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="comment">//校验初始容量</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity:&quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">//当初始容量超过最大容量，初始容量为最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="comment">//校验初始负载因子    </span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="comment">//设置负载因子</span></span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">//设置扩容阈值</span></span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">        <span class="comment">//空方法，让其子类重写例如LinkedHashMap</span></span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认构造方法，采用默认容量16，默认负载因子0.75</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定容量构造方法，负载因子默认0.75</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据子Map进行初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置容量大小 &amp; 加载因子 = 默认</span></span><br><span class="line">        <span class="built_in">this</span>(Math.max((<span class="type">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该方法用于初始化 数组 &amp; 阈值，下面会详细说明</span></span><br><span class="line">        inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将传入的子Map中的全部元素逐个添加到HashMap中</span></span><br><span class="line">        putAllForCreate(m);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>重点：</strong>构造方法初始化只是设置了初始容量大小（capicity）、负载因子（Load factor），并没有真正的初始化哈希表。哈希表中数组的初始化，必须等到第一次 <code>put()</code>操作时进行。</p>
<h3 id="4-插入-put-方法分析"><a href="#4-插入-put-方法分析" class="headerlink" title="4. 插入 put() 方法分析"></a>4. 插入 put() 方法分析</h3><p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1jMDkwMmU5MjM3Yzg0YzBkLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 源码分析：主要分析： HashMap的put函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span></span><br><span class="line">（分析<span class="number">1</span>）<span class="comment">// 1. 若 哈希表未初始化（即 table为空) </span></span><br><span class="line">        <span class="comment">// 则使用 构造函数时设置的阈值(即初始容量) 初始化 数组table  </span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123; </span><br><span class="line">        inflateTable(threshold); </span><br><span class="line">    &#125;  </span><br><span class="line">        <span class="comment">// 2. 判断key是否为空值null</span></span><br><span class="line">（分析<span class="number">2</span>）<span class="comment">// 2.1 若key == null，则将该键-值 存放到数组table 中的第1个位置，即table [0]</span></span><br><span class="line">        <span class="comment">// （本质：key = Null时，hash值 = 0，故存放到table[0]中）</span></span><br><span class="line">        <span class="comment">// 该位置永远只有1个value，新传进来的value会覆盖旧的value</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line"></span><br><span class="line">（分析<span class="number">3</span>） <span class="comment">// 2.2 若 key ≠ null，则计算存放数组 table 中的位置（下标、索引）</span></span><br><span class="line">        <span class="comment">// a. 根据键值key计算hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        <span class="comment">// b. 根据hash值 最终获得 key对应存放的数组Table中位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 判断该key对应的值是否已存在（通过遍历 以该数组元素为头结点的链表 逐个判断）</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">（分析<span class="number">4</span>）<span class="comment">// 3.1 若该key已存在（即 key-value已存在 ），则用 新value 替换 旧value</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue; <span class="comment">//并返回旧的value</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">（分析<span class="number">5</span>）<span class="comment">// 3.2 若 该key不存在，则将“key-value”添加到table中</span></span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p><strong>分析一、哈希表为空时进行初始化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inflateTable</span><span class="params">(<span class="type">int</span> toSize)</span> &#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 将传入的容量大小转化为：&gt;传入容量大小的最小的2的次幂</span></span><br><span class="line">    <span class="comment">// 即如果传入的是容量大小是19，那么转化后，初始化容量大小为32（即2的5次幂）</span></span><br><span class="line">    <span class="comment">// 初始时传入的是阈值12，大于它的最小的2的整数次幂就是16，即默认容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> roundUpToPowerOf2(toSize);-&gt;&gt;分析<span class="number">1</span>   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 重新计算阈值 threshold = 容量 * 加载因子  </span></span><br><span class="line">    threshold = (<span class="type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用计算后的初始容量（已经是2的次幂） 初始化数组table（作为数组长度）</span></span><br><span class="line">    <span class="comment">// 即 哈希表的容量大小 = 数组大小（长度）</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity]; <span class="comment">//用该容量初始化table  </span></span><br><span class="line"></span><br><span class="line">    initHashSeedAsNeeded(capacity);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析1：roundUpToPowerOf2(toSize)</span></span><br><span class="line"><span class="comment">     * 作用：将传入的容量大小转化为：&gt;传入容量大小的最小的2的幂</span></span><br><span class="line"><span class="comment">     * 特别注意：容量大小必须为2的幂，该原因在下面的讲解会详细分析</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">roundUpToPowerOf2</span><span class="params">(<span class="type">int</span> number)</span> &#123;  </span><br><span class="line">   </span><br><span class="line">       <span class="comment">//若 容量超过了最大值，初始化容量设置为最大值 ；否则，设置为：&gt;传入容量大小的最小的2的次幂</span></span><br><span class="line">       <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY  ? </span><br><span class="line">            MAXIMUM_CAPACITY  : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>





<p><strong>分析二、当key为null时，将key-value插入到数组的第一个位置 table[0]</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">private</span> V <span class="title function_">putForNullKey</span><span class="params">(V value)</span> &#123;  </span><br><span class="line">        <span class="comment">// 遍历以table[0]为首的链表，寻找是否存在key==null 对应的键值对</span></span><br><span class="line">        <span class="comment">// 1. 若有：则用新value 替换 旧value；同时返回旧的value值</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;  </span><br><span class="line">          <span class="keyword">if</span> (e.key == <span class="literal">null</span>) &#123;   </span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    modCount++;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 .若无key==null的键，那么调用addEntry（），将空键 &amp; 对应的值封装到Entry中，并放到table[0]中</span></span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="literal">null</span>, value, <span class="number">0</span>); </span><br><span class="line">    <span class="comment">// 注：</span></span><br><span class="line">    <span class="comment">// a. addEntry（）的第1个参数 = hash值 = 传入0</span></span><br><span class="line">    <span class="comment">// b. 即 说明：当key = null时，也有hash值 = 0，所以HashMap的key 可为null</span></span><br><span class="line">    <span class="comment">// c. 对比HashTable，由于HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null</span></span><br><span class="line">    <span class="comment">// d. 此处只需知道是将 key-value 添加到HashMap中即可，关于addEntry（）的源码分析将等到下面再详细说明，</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line"></span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>





<p><strong>分析三、计算键值对实际在哈希表中应该存储的位置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数使用原型</span></span><br><span class="line"><span class="comment">     * 主要分为2步：计算hash值、根据hash值再计算得出最后数组位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="comment">// a. 根据键值key计算hash值 -&gt;&gt; 分析1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        <span class="comment">// b. 根据hash值 最终获得 key对应存放的数组Table中位置 -&gt;&gt; 分析2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 源码分析1：hash(key)</span></span><br><span class="line"><span class="comment">     * 该函数在JDK 1.7 和 1.8 中的实现不同，但原理一样 = 扰动函数 = 使得根据key生成的哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）</span></span><br><span class="line"><span class="comment">     * JDK 1.7 做了9次扰动处理 = 4次位运算 + 5次异或运算</span></span><br><span class="line"><span class="comment">     * JDK 1.8 简化了扰动函数 = 只做了2次扰动 = 1次位运算 + 1次异或运算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">        h ^= k.hashCode(); </span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）</span></span><br><span class="line">      <span class="comment">// 1. 取hashCode值： h = key.hashCode() </span></span><br><span class="line">     <span class="comment">//  2. 高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16)  </span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">           <span class="type">int</span> h;</span><br><span class="line">            <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">            <span class="comment">// a. 当key = null时，hash值 = 0，所以HashMap的key 可为null      </span></span><br><span class="line">            <span class="comment">// 注：对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null</span></span><br><span class="line">            <span class="comment">// b. 当key ≠ null时，则通过先计算出 key的 hashCode()（记为h），然后 对哈希码进行 扰动处理： 按位 异或（^） 哈希码自身右移16位后的二进制</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数源码分析2：indexFor(hash, table.length)</span></span><br><span class="line"><span class="comment">     * JDK 1.8中实际上无该函数，但原理相同，即具备类似作用的函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">      <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;  </span><br><span class="line">          <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); </span><br><span class="line">          <span class="comment">// 将对哈希码扰动处理后的结果 与运算(&amp;) （数组长度-1），最终得到存储在数组table的位置（即数组下标、索引）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS04NGU5NTAzZmI0OWM0NmFiLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA" alt="示意图"></p>
<p><strong>关键点：</strong>计算哈希码，通过扰动函数去二次处理哈希码，最后用 <code>h&amp;(length-1)</code> 来计算最终的存储位置。</p>
<p><strong>问题（1）：</strong>为什么不采用经过扰动处理的 hashcode 作为最终的存储位置？</p>
<blockquote>
<p>因为经过扰动处理的哈希码的范围可能与数组长度不匹配，这样存储就会出现错误。因此要想办法将哈希码的范围约束在数组长度范围内。</p>
<p>一般想到的解决方案就是将 hash值对 数组范围取模（求余运算）。但是 JDK7中并没有这么做，而是采用了与运算（&amp;）：<code>h &amp; (length-1)</code>来得到最终的存储下标。</p>
</blockquote>
<p><strong>问题（2）：</strong>为什么采用哈希码和数组长度-1 与运算来计算数组的下标？</p>
<blockquote>
<p>我认为关键有两点：</p>
<p>​        <strong>1. 提高运算效率：</strong></p>
<p>与运算的实质是采用取模运算，即用 Hash值对数组长度取模 <code>h % length</code>，但是由于求余运算的效率很低，因此采用与运算来提高效率。而且由于数组的长度为2的整数次幂，那么 <code>h &amp; (length-1)</code>实质上是用 <strong>哈希码与length-1 个1进行与运算，结果就是哈希码对应长度为 length-1 低位的部分</strong>。</p>
<p>​        <strong>2. 保证哈希码的均匀性：</strong></p>
<p>因为下标的求解方法是：将hash值和 数组长度-1 进行与运算。当长度为2^n时，数组长度减1后得到的所有位都为1，那么与运算的结果就是 hash值，一定程度上减小了碰撞的几率；</p>
<p>而如果不是 2^n，那么数组长度-1 后一定会产生0位，0 和任何数求与都为0，那么无论hash值为何值，对应该位为1时的那个位置的桶会一直空着。</p>
</blockquote>
<p><strong>问题（3）：</strong>为什么在计算数组下标前，需要对哈希码进行二次处理(扰动处理)？</p>
<blockquote>
<p>扰动处理的目的就是为了让哈希码分布的更加均匀，使得存储在hashmap中的数组位置更加均匀，从而避免出现 hash冲突。</p>
</blockquote>
<p><strong>问题（4）：</strong>为什么数组的长度一定为 2^n ？</p>
<blockquote>
<p> 因为下标的求解方法是：将hash值和 数组长度-1 进行与运算。当长度为2^n时，数组长度减1后得到的所有位都为1，那么与运算的结果就是 hash值，一定程度上减小了碰撞的几率；</p>
<p>而如果不是 2^n，那么数组长度-1 后一定会产生0位，0 和任何数求与都为0，那么无论hash值为何值，对应该位为1时的那个位置的桶会一直空着。</p>
</blockquote>
<p><strong>分析四、若对应的key已经存在，就使用新value去替换旧value</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">    Object k;</span><br><span class="line">    <span class="comment">// 2.1 若该key已存在（即 key-value已存在 ），则用 新value 替换 旧value</span></span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> oldValue; <span class="comment">//并返回旧的value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modCount++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2 若 该key不存在，则将“key-value”添加到table中</span></span><br><span class="line">addEntry(hash, key, value, i);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>方法很简单，就是顺序查找链表，找到对应值进行覆盖即可。</p>
<p><strong>分析五、若对应的key不存在，就将该key-value添加到数组对应位置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//若 该key对应的值不存在，则将“key-value”添加到table中</span></span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 源码分析：addEntry(hash, key, value, i)</span></span><br><span class="line"><span class="comment">     * 作用：添加键值对（Entry ）到 HashMap中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;  </span><br><span class="line">          <span class="comment">// 参数3 = 插入数组table的索引位置 = 数组下标</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 1. 插入前，先判断容量是否足够</span></span><br><span class="line">          <span class="comment">// 1.1 若不足够，则进行扩容（2倍）、重新计算Hash值、重新计算存储数组下标</span></span><br><span class="line">          <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;  </span><br><span class="line">            resize(<span class="number">2</span> * table.length); <span class="comment">// a. 扩容2倍  --&gt; 分析1</span></span><br><span class="line">            hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;  <span class="comment">// b. 重新计算该Key对应的hash值</span></span><br><span class="line">            bucketIndex = indexFor(hash, table.length);  <span class="comment">// c. 重新计算该Key对应的hash值的存储数组下标位置</span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 若容量足够，则创建1个新的数组元素（Entry） 并放入到数组中--&gt; 分析2</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析1：resize(2 * table.length)</span></span><br><span class="line"><span class="comment">   * 作用：当容量不足时（容量 &gt; 阈值），则扩容（扩到2倍）</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 保存旧数组（old table） </span></span><br><span class="line">    Entry[] oldTable = table;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 保存旧容量（old capacity ），即数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 若旧容量已经是系统默认最大容量了，那么将阈值设置成整型的最大值，退出    </span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  </span><br><span class="line">        threshold = Integer.MAX_VALUE;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 4. 根据新容量（2倍容量）新建1个数组，即新table  </span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 将旧数组上的数据（键值对）转移到新table中，从而完成扩容 -&gt;&gt;分析1.1 </span></span><br><span class="line">    transfer(newTable); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 新数组table引用到HashMap的table属性上</span></span><br><span class="line">    table = newTable;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 重新设置阈值  </span></span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析1.1：transfer(newTable); </span></span><br><span class="line"><span class="comment">   * 作用：将旧数组上的数据（键值对）转移到新table中，从而完成扩容</span></span><br><span class="line"><span class="comment">   * 过程：按旧链表的正序遍历链表、在新链表的头部依次插入</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">      <span class="comment">// 1. src引用了旧数组</span></span><br><span class="line">      Entry[] src = table; </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 获取新数组的大小 = 获取新容量大小                 </span></span><br><span class="line">      <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 通过遍历 旧数组，将旧数组上的数据（键值对）转移到新数组中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123; </span><br><span class="line">      	  <span class="comment">// 3.1 取得旧数组的每个元素  </span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];           </span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 3.2 释放旧数组的对象引用（for循环后，旧数组不再引用任何对象）</span></span><br><span class="line">              src[j] = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line">              <span class="keyword">do</span> &#123; </span><br><span class="line">                  <span class="comment">// 3.3 遍历 以该数组元素为首 的链表</span></span><br><span class="line">                  <span class="comment">// 注：转移链表时，因是单链表，故要保存下1个结点，否则转移后链表会断开</span></span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next; </span><br><span class="line">                 <span class="comment">// 3.4 重新计算每个元素的存储位置</span></span><br><span class="line">                 <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity); </span><br><span class="line">                 <span class="comment">// 3.5 将元素放在数组上：采用单链表的头插入方式 = 在链表头上存放数据 = 将数组位置的原有数据放在后1个指针、将需放入的数据放到数组位置中</span></span><br><span class="line">                 <span class="comment">// 即 扩容后，可能出现逆序：按旧链表的正序遍历链表、在新链表的头部依次插入</span></span><br><span class="line">                 e.next = newTable[i]; </span><br><span class="line">                 newTable[i] = e;  </span><br><span class="line">                 <span class="comment">// 3.6 访问下1个Entry链上的元素，如此不断循环，直到遍历完该链表上的所有节点</span></span><br><span class="line">                 e = next;             </span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">             <span class="comment">// 如此不断循环，直到遍历完数组上的所有数据元素</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析2：createEntry(hash, key, value, bucketIndex);  </span></span><br><span class="line"><span class="comment">   * 作用： 若容量足够，则创建1个新的数组元素（Entry） 并放入到数组中</span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 把table中该位置原来的Entry保存  </span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 在table中该位置新建一个Entry：将原头结点位置（数组上）的键值对 放入到（链表）后1个节点中、将需插入的键值对 放入到头结点中（数组上）-&gt; 从而形成链表</span></span><br><span class="line">    <span class="comment">// 即 在插入元素时，是在链表头插入的，table中的每个位置永远只保存最新插入的Entry，旧的Entry则放入到链表中（即 解决Hash冲突）</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 哈希表的键值对数量计数增加</span></span><br><span class="line">    size++;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  创建新结点时会检查是否需要进行扩容(阈值12)；如果需要就将容量扩大为原来的2倍，然后将旧数组中的值转移到新数组(会重新计算hash和下标点进行插入)，数据转移过程使用的是头插法(头插法在多线程环境下会造成死锁问题)。</p>
<p><strong>问题（1）：</strong>transfer 为什么采用头插而不是尾插？为什么不用二维数组解决冲突？</p>
<blockquote>
<p>因为后插入的数据被使用的频次更高，而单链表无法随机访问只能从头开始遍历查询，所以采用头插.突然又想为什么不采用二维数组的形式利用线性探查法来处理冲突，数组末尾插入也是O(1)，可数组其最大缺陷就是在于若不是末尾插入删除效率很低，其次若添加的数据分布均匀那么每个桶上的数组都需要预留内存.</p>
</blockquote>
<p><strong>问题（2）：</strong>头插法为什么造成死锁问题？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transfer() 方法重要部分</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; next = e.next; <span class="comment">// &lt;--假设线程一执行到这里就被调度挂起了</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">    e.next = newTable[i];</span><br><span class="line">    newTable[i] = e;</span><br><span class="line">    e = next;</span><br><span class="line">&#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>



<img src="/img/loading.gif" data-original="/passageImg/Java源码解读.assets/HashMap01.jpg" alt="img"  />

<p>单线程下：当HashMap 被扩容后，key值为 7和3的节点分别插入到了下标为3的位置。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/HashMap02.jpg" alt="img"></p>
<p>多线程下：如果线程1执行到第一句被挂起了；此时线程2将整个插入操作执行完了（key:7 放在了 key:3的前面）；此时如果线程1又被调度，执行<code>e.next= newTable[i]</code>又会将7连接在3的尾部，这样就形成了环。那么如果对环进行查找时(找一个不存在的量)就会造成死锁。</p>
<h3 id="5-扩容操作-resize-分析"><a href="#5-扩容操作-resize-分析" class="headerlink" title="5. 扩容操作 resize()分析"></a>5. 扩容操作 resize()分析</h3><p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wMDBlMDg4MzFjNDViNjZjLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA" alt="示意图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 保存旧数组（old table） </span></span><br><span class="line">    Entry[] oldTable = table;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 保存旧容量（old capacity ），即数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 若旧容量已经是系统默认最大容量了，那么将阈值设置成整型的最大值，退出    </span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  </span><br><span class="line">        threshold = Integer.MAX_VALUE;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 4. 根据新容量（2倍容量）新建1个数组，即新table  </span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 将旧数组上的数据（键值对）转移到新table中，从而完成扩容 -&gt;&gt;分析1.1 </span></span><br><span class="line">    transfer(newTable); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 新数组table引用到HashMap的table属性上</span></span><br><span class="line">    table = newTable;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 重新设置阈值  </span></span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>扩容操作首先会复制出一个大小为原数组大小二倍的新数组。然后需要遍历旧数组中的每个值，采用和<code>put()</code>方法相同的方式，重新计算每个数据在新数组中的存储位置<code>h &amp; (length-1)</code>，然后将旧数组的值转移到新数组中。对于旧数组的链表结点，在新数组中采用头插法进行插入。最后重新计算扩容阈值，重新计算需要插入数据对应的hash值，然后进行插入。</p>
<p>JDK7 中为了防止 hash 碰撞引起的拒绝服务攻击，在计算 hash 的过程中引入了随机种子。以增强 hash 的随机性，使得键值对均匀分布在桶数组中。在扩容过程中，相关方法会根据容量判断是否需要生成新的随机种子，并重新计算所有节点的hash。</p>
<h3 id="6-获取数据-get-方法分析"><a href="#6-获取数据-get-方法分析" class="headerlink" title="6. 获取数据 get() 方法分析"></a>6. 获取数据 get() 方法分析</h3><p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03OGNmMjFkZjRmMzM1MzE5LnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA" alt="示意图"></p>
<p><code>get()</code> 方法原理和<code>put()</code> 方法类似，都是根据 key计算hash值，然后扰乱处理，结合数组长度计算最终的存放位置。然后到该存放位置去查找，如果找到了就返回，否则就没有找到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析1：getForNullKey()</span></span><br><span class="line"><span class="comment">   * 作用：当key == null时，则到 以哈希表数组中的第1个元素（即table[0]）为头结点的链表去寻找对应 key == null的键</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line"><span class="keyword">private</span> V <span class="title function_">getForNullKey</span><span class="params">()</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历以table[0]为头结点的链表，寻找 key==null 对应的值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从table[0]中取key==null的value值 </span></span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="literal">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> e.value; </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析2：getEntry(key)</span></span><br><span class="line"><span class="comment">   * 作用：当key ≠ null时，去获得对应值</span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 根据key值，通过hash（）计算出对应的hash值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 根据hash值计算出对应的数组下标</span></span><br><span class="line">    <span class="comment">// 3. 遍历 以该数组下标的数组元素为头结点的链表所有节点，寻找该key对应的值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  e != <span class="literal">null</span>;  e = e.next) &#123;  </span><br><span class="line"></span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="comment">// 若 hash值 &amp; key 相等，则证明该Entry = 我们要的键值对</span></span><br><span class="line">        <span class="comment">// 通过equals（）判断key是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;  </span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">            <span class="keyword">return</span> e;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>HashMap的关键点主要包括： 数据结构+重要参数+重点方法</p>
<ul>
<li>数据结构和核心参数</li>
</ul>
<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1jZDUzMTk5YzQ2MjNlZWZhLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA" alt="示意图"></p>
<ul>
<li>添加、查询数据操作</li>
</ul>
<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS04NjJkYWQ4ZmQxMDAxMjc5LnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA" alt="示意图"></p>
<h2 id="二、JDK-1-8-的HashMap"><a href="#二、JDK-1-8-的HashMap" class="headerlink" title="二、JDK 1.8 的HashMap"></a>二、JDK 1.8 的HashMap</h2><p>JDK8 中的 hashMap相较于 JDK7做出了很大的改变，主要包括 数据结构、插入查找方法、扩容操作这三个方面。</p>
<h3 id="1-数据结构-1"><a href="#1-数据结构-1" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p>JDK8 采用的是 数组+链表+红黑树 来实现的。</p>
<p><strong>为什么要引入红黑树？</strong></p>
<p>​        因为如果像 JDK7 那样，采用链地址法解决哈希冲突，那么当链表长度过长时查找是非常耗时的。因此引入红黑树的结构来加快查找过程，并且根据链表的长度来控制链表和红黑树之间的转化，这样一方面提高了查找的效率（时间复杂度从 O(n) 减少为了 O(logn)）；另一方面又不至于浪费很多资源空间。</p>
<p><strong>如何转化？</strong></p>
<ul>
<li><p>没有冲突时，完全采用数组存储；</p>
</li>
<li><p>当出现冲突时，优先使用链表进行存储，如果此时链表长度 &lt;8  ，会一直使用链表存储；</p>
</li>
<li><p>当出现冲突，并且链表长度 &gt;&#x3D;8 时，存储结构转化为红黑树；当链表长度小于6时又会变回链表存储。</p>
</li>
</ul>
<p><strong>红黑树的特点？</strong></p>
<ul>
<li><p>红黑树本质上是一棵二叉搜索树，因此查找的时间复杂度为 O(logn)，效率很高。</p>
</li>
<li><p>红黑树每个结点不是红色就是黑色，而且父子结点必须是不同的颜色。根节点和叶子节点都是黑色。</p>
</li>
<li><p>从1个结点到该子孙结点的所有路径上包含相同数量的黑色结点，因此红黑树是相对接近平横二叉树。</p>
</li>
</ul>
<h3 id="2-重要结构"><a href="#2-重要结构" class="headerlink" title="2. 重要结构"></a>2. 重要结构</h3><p>主要看一下 Node结点和 TreeNode结点</p>
<p><code>Node结点</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;    <span class="comment">//哈希值</span></span><br><span class="line">        <span class="keyword">final</span> K key;       <span class="comment">//key值</span></span><br><span class="line">        V value;           <span class="comment">//value值</span></span><br><span class="line">        Node&lt;K,V&gt; next;    <span class="comment">//链表下一个结点</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Node结点和 JDK7 中的结点结构完全类似。</p>
<p><code>TreeNode 结点：</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父结点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;    <span class="comment">// 左子树</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;   <span class="comment">// 右子树</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// 前一个结点</span></span><br><span class="line">    <span class="type">boolean</span> red;           <span class="comment">// 结点颜色</span></span><br><span class="line">    TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-重要变量"><a href="#3-重要变量" class="headerlink" title="3. 重要变量"></a>3. 重要变量</h3><p>由于引入了红黑树，因此也引入了一些与红黑树相关的临界变量。</p>
<p>（1）桶的树化阈值，即链表转化为红黑树的阈值，当链表长度大于该值时，将链表转化为红黑树</p>
<p><code>static final int TREEIFY_THRESHOLD = 8;</code></p>
<p>（2）桶的还原阈值，当原有红黑树中的结点数小于6时，转换回链表</p>
<p><code>static final int UNTREEIFY_THRESHOLD = 6;</code></p>
<p>（3）最小树化容量阈值，当哈希表中的容量大于该值时，才允许进行树化。为树化阈值的4倍</p>
<p><code>static final int MIN_TREEIFY_CAPACITY = 64;</code></p>
<h3 id="4-插入-put-方法分析-1"><a href="#4-插入-put-方法分析-1" class="headerlink" title="4. 插入 put() 方法分析"></a>4. 插入 put() 方法分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d70bb28ea42" alt="示意图"></p>
<h4 id="4-1-哈希的计算方式"><a href="#4-1-哈希的计算方式" class="headerlink" title="4.1 哈希的计算方式"></a>4.1 哈希的计算方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK8 中的 hash计算方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK7 中的 hash计算方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    h ^= k.hashCode(); </span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>JDK7 中总共采用了9次扰动处理，包括4次位运算、5次异或运算；</p>
<p>JDK8 中总共采用了2次扰动处理，包括1次位运算、1次异或运算；</p>
<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d70cf5e0917" alt="示意图"></p>
<p><strong>问题（1）：这里计算 hash值为什么采用  <code>key.hashcode() ^  h&gt;&gt;&gt;16</code> 这种方式？</strong></p>
<p>因为如果直接使用 hashcode 去进行 <code>index = key.hashcode() &amp; (n-1)</code>运算来计算最终的存储位置，那么相当于 hashcode 的高位都没有用到 (因为n为2的整数次幂，减一后低位都1，高位都为0，0和任何数与运算都为0)；简单的来说，直接使用 hashcode 去计算最终位置会使得取余的计算结果只对低位有效，当hash 值高位变化时低位不变，取余结果仍然一样，容易发生哈希冲突。</p>
<p>因为哈希值为32位，那么如果我将整个hash 值右移16位，得到的结果就是哈希值的高16位；再将高16位和低16位进行异或运算，那就相当于用到了整个 hash部分。无论此时是 hash的高位还是低位发生改变，最终的 hash求余结果一定会发生改变，巧妙地避免了哈希冲突。</p>
<h4 id="4-2-putVal-方法分析"><a href="#4-2-putVal-方法分析" class="headerlink" title="4.2 putVal() 方法分析"></a>4.2 putVal() 方法分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//tab:旧的数组   i:根据hash计算后的存储位置  p:存储位置对应的结点   n:数组长度</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果数组未初始化，先进行数组初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果对应存储位置没有值，生成一个结点插入</span></span><br><span class="line"> <span class="comment">// i = (n-1) &amp; hash  操作类似于 JDK7 中的 indexFor()函数，都是根据hash值和数组长度计算最终位置</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 否则存在hash冲突</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果对应位置的key相同，用新值覆盖旧值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 否则判断当前的数据结构，如果是红黑树的结构</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 否则是链表存储的结构,那么需要遍历的同时记录节点个数，如果大于了8就要转化为红黑树的结构</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// binCount 就是用来记录结点个数	</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 遍历到了链表末尾，说明没有找到，就在末尾插入新结点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 判断结点个数是否大于8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到了链表中的对应结点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 更新p指向下一个结点，继续遍历</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对于i情况的后续操作，发现key已存在，就用新value覆盖旧value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d70ef1a145c" alt="示意图"></p>
<p>JDK8 与 JDK7 的插入操作有了很大的不同：</p>
<ol>
<li><p>第一步都是判断数组是否被初始化，没有初始化就进行初始化（容量大小为大于输入数值的最小的2的整数次幂）；</p>
</li>
<li><p>第二步就是根据 key 计算应该存放的位置，这里的计算方法和JDK7 也不相同，主要体现在扰动函数上，只进行了2次扰动处理；</p>
</li>
<li><p>如果该位置没有值就生成一个新的结点插入；否则有值但是 key可能相同，这样的话进行覆盖就可以了。</p>
</li>
<li><p>但是如果 key不相同却有值，说明存在hash冲突（不同的key经过计算得到相同的存储位置）；就需要根据此时的存储数据结构进行判断，如果是红黑树就采用红黑树的方式插入然后调整；如果是链表就查找链表中是否已经存在，存在就覆盖，不存在就在链表尾插入一个新的。</p>
<p>但是注意链表超过一定长度是需要转化为红黑树进行存储的，因此遍历链表的过程中还需要记录链表的位置，源码中使用<code>binCount</code>进行记录。记录完毕后判断是否需要变换结构。</p>
</li>
<li><p>最后判断是否需要进行扩容处理，如果当前键值对的数量大于扩容阈值，就采用 <code>resize()</code> 方法进行扩容。扩容操作接下来分析。</p>
</li>
</ol>
<h3 id="5-扩容操作-resize-分析-1"><a href="#5-扩容操作-resize-分析-1" class="headerlink" title="5. 扩容操作 resize() 分析"></a>5. 扩容操作 resize() 分析</h3><p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d70f4301afd" alt="示意图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法会在数组初始化和扩容时被调用 </span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      <span class="comment">//oldTab：旧表    oldThr：旧的阈值    oldCap：旧的容量  </span></span><br><span class="line">    </span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">      <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 数组已经进行了初始化</span></span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果旧容量大于最大容量，则不能进行扩容处理</span></span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 否则容量扩大为之前的2倍</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 初始化数组</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 新的扩容阈值为空，就进行重新计算并初始化</span></span><br><span class="line">      <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 将原数组中的值复制到新数组中</span></span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                  oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                </span><br><span class="line">                  <span class="comment">// 原数组中单个结点重新计算hash值存储</span></span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  <span class="comment">// 如果是红黑树结点</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                  <span class="comment">// 如果是链表结点</span></span><br><span class="line">                  <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                      Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          </span><br><span class="line">                          <span class="comment">// 原hash值的最高位的上一位如果为0，则采用原索引</span></span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="comment">//采用尾插法</span></span><br><span class="line">                              <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="comment">// 否则为1，采用新索引</span></span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                      <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                          loTail.next = <span class="literal">null</span>;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                          hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>重点在重新计算数组中元素在新数组中的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原hash值的最高位的上一位如果为0，则采用原索引</span></span><br><span class="line"><span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">    loHead = e;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    loTail.next = e;</span><br><span class="line">  loTail = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则为1，采用新索引</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">    hiHead = e;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    hiTail.next = e;</span><br><span class="line">  hiTail = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据代码，这里只存在两种情况，要么仍然是原位置，要么是原位置+原数组的长度作为新位置。</p>
<p>因为扩容后容量为原来的2倍，相当于把容量的2进制值往左移动1位。在计算存储位置 <code>i = (n-1) &amp; hash</code>时，<code>n-1</code> 的二进制比原来的二进制高位多了一个1，那么原hash 值与这个1相与结果就可能是1或者0了。如果是0，则新计算的存储位置和原存储位置相同；如果是1，新存储位置 &#x3D; 原长度+原来的存储位置。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d7111482968" alt="示意图"></p>
<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d711301a22e" alt="示意图"></p>
<h3 id="6-获取数据-get-方法分析-1"><a href="#6-获取数据-get-方法分析-1" class="headerlink" title="6. 获取数据 get() 方法分析"></a>6. 获取数据 get() 方法分析</h3><p>获取数据类似于插入操作，包括计算存储位置，判断存储的数据结构然后去对应位置查找。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d71332fc308" alt="示意图"></p>
<h3 id="7-总结-1"><a href="#7-总结-1" class="headerlink" title="7. 总结"></a>7. 总结</h3><ul>
<li>数据结构</li>
</ul>
<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d713a14fa7a" alt="示意图"></p>
<ul>
<li>添加、查询数据流程</li>
</ul>
<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d713e10dfce" alt="示意图"></p>
<ul>
<li>扩容机制</li>
</ul>
<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d714a3472fe" alt="示意图"></p>
<h2 id="三、JDK7-和-JDK8-HashMap的区别"><a href="#三、JDK7-和-JDK8-HashMap的区别" class="headerlink" title="三、JDK7 和 JDK8  HashMap的区别"></a>三、JDK7 和 JDK8  HashMap的区别</h2><h3 id="3-1-数据结构不同"><a href="#3-1-数据结构不同" class="headerlink" title="3.1 数据结构不同"></a>3.1 数据结构不同</h3><p>JDK7 的数据结构为 数组+链表，当发生哈希冲突时采用链地址法解决冲突；缺点是当冲突过多导致链表过长时，对链表中数据的查询效率非常低；</p>
<p>JDK8 的数据结构为 数组+链表+红黑树，当发生哈希冲突时优先采用链表解决冲突，但是如果链表的长度大于8，就要将结构转换为红黑树，红黑树的查找时间复杂度为 O(logn) 比 链表的 O(n) 在结点很多的情况下要好很多。如果链表长度低于6时，就没必要使用红黑树了，此时将红黑树转换回链表结构。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d714525211d" alt="示意图"></p>
<h3 id="3-2-插入数据、获取数据"><a href="#3-2-插入数据、获取数据" class="headerlink" title="3.2 插入数据、获取数据"></a>3.2 插入数据、获取数据</h3><p>JDK7 的插入数据首先会检查数组是否初始化，初始化完毕后判断key是否为空，为空直接插在数组第一个位置；然后根据 key对应的哈希值进行扰动处理，这里的扰动处理包括4次位运算和5次异或运算；紧接着根据 <code>index = h &amp; (length-1)</code> 计算出最终的插入位置；如果该位置没有冲突，直接插入；否则需要插入到单链表中，这就涉及到了扩容操作，在扩容之后又重新计算需要插入的数据的位置进行插入。<strong>是先扩容后计算插入位置进行插入</strong></p>
<p>JDK8 的插入数据首先也会检查数据是否初始化，初始化完毕后紧接着计算哈希值，哈希值的计算与JDK7不同，是通过采用 <code>hashcode &amp; (hashcode&gt;&gt;&gt;16)</code>计算得到hash值，然后根据 <code>index=h&amp;(length-1)</code>得出最终插入位置。没有冲突直接插入，如果有冲突，判断当前数据结构的类型进行冲突解决，对于链表而言需要特别注意当结点数大于8时需要转化为红黑树的结构。最后插入完毕后判断是否需要进行扩容操作。<strong>是先插入后判断是否需要扩容</strong></p>
<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d7167830234" alt="示意图"></p>
<h3 id="3-3-扩容机制"><a href="#3-3-扩容机制" class="headerlink" title="3.3 扩容机制"></a>3.3 扩容机制</h3><p>JDK7 中扩容是生成一个大小为原容量2倍的数组，然后重新计算原数组中各个头结点的存储位置，接着插入到新数组中。对于原数组中的链表结构，采用头插法依次插入到新数组中，这种头插法在多线程情况下可能会出现环形链表，因此会出现死循环问题。</p>
<p>JDK8 中扩容也是生成一个大小为原容量2倍的新数组，然后按照扩容规律计算新位置，不同的是它的位置只有两种情况，一种是原位置、一种是原位置+旧容量；接着采用尾插法插入结点，尾插法保证了即使在多线程情况下也不会出现问题。</p>
<p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d71685c05a4" alt="示意图"></p>
<h2 id="四、一些面试问题"><a href="#四、一些面试问题" class="headerlink" title="四、一些面试问题"></a>四、一些面试问题</h2><h3 id="4-1-哈希表如何解决哈希冲突？"><a href="#4-1-哈希表如何解决哈希冲突？" class="headerlink" title="4.1 哈希表如何解决哈希冲突？"></a>4.1 哈希表如何解决哈希冲突？</h3><p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d717abd5222" alt="示意图"></p>
<h3 id="4-2-为什么-HashMap中-String、Integer这样的包装类适合作为键？"><a href="#4-2-为什么-HashMap中-String、Integer这样的包装类适合作为键？" class="headerlink" title="4.2 为什么 HashMap中 String、Integer这样的包装类适合作为键？"></a>4.2 为什么 HashMap中 String、Integer这样的包装类适合作为键？</h3><p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d71ad453bf9" alt="示意图"></p>
<h3 id="4-3-HashMap中的key若为Object类型，需要实现哪些方法？"><a href="#4-3-HashMap中的key若为Object类型，需要实现哪些方法？" class="headerlink" title="4.3 HashMap中的key若为Object类型，需要实现哪些方法？"></a>4.3 HashMap中的key若为Object类型，需要实现哪些方法？</h3><p><img src="/img/loading.gif" data-original="/passageImg/Java%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.assets/16217d71b496f303" alt="示意图"></p>
<h3 id="4-4-HashMap的链表大小超过8个时会自动转化为红黑树，当小于6个时会转换为链表，为什么呢？"><a href="#4-4-HashMap的链表大小超过8个时会自动转化为红黑树，当小于6个时会转换为链表，为什么呢？" class="headerlink" title="4.4 HashMap的链表大小超过8个时会自动转化为红黑树，当小于6个时会转换为链表，为什么呢？"></a>4.4 HashMap的链表大小超过8个时会自动转化为红黑树，当小于6个时会转换为链表，为什么呢？</h3><p>因为根据泊松分布的原理，单个桶中结点个数大于8的概率小于百万分之一，所以将7作为一个分水岭，大于等8时转换为红黑树进行存储；小于等于6时转换回链表的结构。</p>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903589236703239#heading-1">Java集合——HashMap（jdk1.7）</a></p>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/9606.html">《疫苗：Java HashMap的死循环》的相关评论</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039367730?utm_source=tag-newest#HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84">[彻底拿下HashMap面试问题！！！]</a></p>
<p><a target="_blank" rel="noopener" href="http://www.codeinn.net/misctech/1718.html">HashMap常见面试题汇总（一）</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">XjX-zc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/01/10/Java%E6%BA%90%E7%A0%81_HashMap%E6%BA%90%E7%A0%81/">http://example.com/2021/01/10/Java源码_HashMap源码/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">iStitches</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></div><div class="post_share"><div class="social-share" data-image="/img/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"><img class="prev-cover" src="/img/loading.gif" data-original="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计网（一）、数据链路层</div></div></a></div><div class="next-post pull-right"><a href="/2020/12/20/RabbitMQ_%E5%85%A5%E9%97%A8/"><img class="next-cover" src="/img/loading.gif" data-original="/img/RabbitMQ.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RabbitMQ(一)、基础入门</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/04/02/Java%E6%BA%90%E7%A0%81_ArrayList%E3%80%81LinkedList%E3%80%81Vector/" title="ArrayList、LinkedList、Vector源码解读"><img class="cover" src="/img/loading.gif" data-original="/img/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-02</div><div class="title">ArrayList、LinkedList、Vector源码解读</div></div></a></div><div><a href="/2021/04/03/Java%E6%BA%90%E7%A0%81_ReentrantLock_AQS/" title="ReentrantLock源码解读"><img class="cover" src="/img/loading.gif" data-original="/img/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-03</div><div class="title">ReentrantLock源码解读</div></div></a></div><div><a href="/2021/04/01/Java%E6%BA%90%E7%A0%81_Synchorized%E5%89%96%E6%9E%90/" title="Synchronized源码解读"><img class="cover" src="/img/loading.gif" data-original="/img/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-01</div><div class="title">Synchronized源码解读</div></div></a></div><div><a href="/2021/04/06/Java%E6%BA%90%E7%A0%81_concurrentHashMap%E6%BA%90%E7%A0%81/" title="ConcurrentHashMap源码解读"><img class="cover" src="/img/loading.gif" data-original="/img/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-06</div><div class="title">ConcurrentHashMap源码解读</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">XjX-zc</div><div class="author-info__description">生活原本沉闷,但跑起来就会有风</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/iStitches"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="iconfont icon-social-rss card_icon"></i></a><a class="social-icon" href="https://github.com/iStitches" target="_blank" title="Github"><i class="iconfont icon-icon-Github card_icon"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_43684985?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><i class="iconfont icon-icon-csdn card_icon"></i></a><a class="social-icon" href="https://space.bilibili.com/407787894" target="_blank" title="Bilibili"><i class="iconfont icon-icon_bilibili card_icon"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1093453695&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="iconfont icon-icon-QQ card_icon"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">开发菜鸡,欢迎大家光临,一起学习进步！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap"><span class="toc-number">1.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81JDK-1-7-%E7%9A%84HashMap"><span class="toc-number">1.1.</span> <span class="toc-text">一、JDK 1.7 的HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 重要参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%B9%E9%87%8F%EF%BC%9A"><span class="toc-number">1.1.2.0.1.</span> <span class="toc-text">容量：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%EF%BC%9A"><span class="toc-number">1.1.2.0.2.</span> <span class="toc-text">负载因子：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E9%98%88%E5%80%BC%EF%BC%9A"><span class="toc-number">1.1.2.0.3.</span> <span class="toc-text">扩容阈值：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. 构造方法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8F%92%E5%85%A5-put-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. 插入 put() 方法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%89%A9%E5%AE%B9%E6%93%8D%E4%BD%9C-resize-%E5%88%86%E6%9E%90"><span class="toc-number">1.1.5.</span> <span class="toc-text">5. 扩容操作 resize()分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-get-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.1.6.</span> <span class="toc-text">6. 获取数据 get() 方法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.7.</span> <span class="toc-text">7. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JDK-1-8-%E7%9A%84HashMap"><span class="toc-number">1.2.</span> <span class="toc-text">二、JDK 1.8 的HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%87%8D%E8%A6%81%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 重要结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%87%8D%E8%A6%81%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 重要变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8F%92%E5%85%A5-put-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90-1"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 插入 put() 方法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%93%88%E5%B8%8C%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">4.1 哈希的计算方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-putVal-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">4.2 putVal() 方法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%89%A9%E5%AE%B9%E6%93%8D%E4%BD%9C-resize-%E5%88%86%E6%9E%90-1"><span class="toc-number">1.2.5.</span> <span class="toc-text">5. 扩容操作 resize() 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-get-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90-1"><span class="toc-number">1.2.6.</span> <span class="toc-text">6. 获取数据 get() 方法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.2.7.</span> <span class="toc-text">7. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81JDK7-%E5%92%8C-JDK8-HashMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">三、JDK7 和 JDK8  HashMap的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8D%E5%90%8C"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 数据结构不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E3%80%81%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 插入数据、获取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 扩容机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">四、一些面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 哈希表如何解决哈希冲突？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%B8%BA%E4%BB%80%E4%B9%88-HashMap%E4%B8%AD-String%E3%80%81Integer%E8%BF%99%E6%A0%B7%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E9%94%AE%EF%BC%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 为什么 HashMap中 String、Integer这样的包装类适合作为键？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-HashMap%E4%B8%AD%E7%9A%84key%E8%8B%A5%E4%B8%BAObject%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 HashMap中的key若为Object类型，需要实现哪些方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-HashMap%E7%9A%84%E9%93%BE%E8%A1%A8%E5%A4%A7%E5%B0%8F%E8%B6%85%E8%BF%878%E4%B8%AA%E6%97%B6%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%8C%E5%BD%93%E5%B0%8F%E4%BA%8E6%E4%B8%AA%E6%97%B6%E4%BC%9A%E8%BD%AC%E6%8D%A2%E4%B8%BA%E9%93%BE%E8%A1%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 HashMap的链表大小超过8个时会自动转化为红黑树，当小于6个时会转换为链表，为什么呢？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/10/26/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B(1)/" title="计算机网络 自顶向下方法(应用层)"><img src="/img/loading.gif" data-original="https://blogimg-1303834209.cos.ap-guangzhou.myqcloud.com/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络 自顶向下方法(应用层)"/></a><div class="content"><a class="title" href="/2021/10/26/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B(1)/" title="计算机网络 自顶向下方法(应用层)">计算机网络 自顶向下方法(应用层)</a><time datetime="2021-10-26T08:47:02.000Z" title="发表于 2021-10-26 16:47:02">2021-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" title="深入理解Java虚拟机—垃圾收集器与内存分配策略"><img src="/img/loading.gif" data-original="/img/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解Java虚拟机—垃圾收集器与内存分配策略"/></a><div class="content"><a class="title" href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" title="深入理解Java虚拟机—垃圾收集器与内存分配策略">深入理解Java虚拟机—垃圾收集器与内存分配策略</a><time datetime="2021-07-11T14:06:00.000Z" title="发表于 2021-07-11 22:06:00">2021-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" title="深入理解Java虚拟机—Java内存区域"><img src="/img/loading.gif" data-original="/img/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解Java虚拟机—Java内存区域"/></a><div class="content"><a class="title" href="/2021/07/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" title="深入理解Java虚拟机—Java内存区域">深入理解Java虚拟机—Java内存区域</a><time datetime="2021-07-11T13:06:00.000Z" title="发表于 2021-07-11 21:06:00">2021-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/10/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E6%8B%93%E5%B1%95/" title="TCP三握四挥知识拓展"><img src="/img/loading.gif" data-original="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TCP三握四挥知识拓展"/></a><div class="content"><a class="title" href="/2021/05/10/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E6%8B%93%E5%B1%95/" title="TCP三握四挥知识拓展">TCP三握四挥知识拓展</a><time datetime="2021-05-10T10:12:00.000Z" title="发表于 2021-05-10 18:12:00">2021-05-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/29/hello-world/" title="hello_word测试"><img src="/img/loading.gif" data-original="https://blogimg-1303834209.cos.ap-guangzhou.myqcloud.com/wallhaven-z8dg9y.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hello_word测试"/></a><div class="content"><a class="title" href="/2021/04/29/hello-world/" title="hello_word测试">hello_word测试</a><time datetime="2021-04-29T10:33:00.000Z" title="发表于 2021-04-29 18:33:00">2021-04-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By XjX-zc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>